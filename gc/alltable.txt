database re-connected
      adsense      
'1856862213!ABS SBA!responsivevertical!ABS SBA!<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>\n<!-- responsive-vertical -->\n<ins class="adsbygoogle"\n     style="display:block"\n     data-ad-client="ca-pub-8488699542117607"\n     data-ad-slot="1856862213"\n     data-ad-format="auto"\n     data-full-width-responsive="true"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n</script>!ABS SBA!0!ABS SBA!0'
'2112495580!ABS SBA!fixed_desktop_300_250!ABS SBA!<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>\n<!-- fixed_300_250 -->\n<ins class="adsbygoogle"\n     style="display:inline-block;width:300px;height:250px"\n     data-ad-client="ca-pub-8488699542117607"\n     data-ad-slot="2112495580"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n</script>!ABS SBA!300!ABS SBA!250'
'2427356203!ABS SBA!fixed_desktop_mobile_250_250!ABS SBA!<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>\n<!-- fixed_250_250 -->\n<ins class="adsbygoogle"\n     style="display:inline-block;width:250px;height:250px"\n     data-ad-client="ca-pub-8488699542117607"\n     data-ad-slot="2427356203"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n</script>!ABS SBA!250!ABS SBA!250'
'2670898784!ABS SBA!fixed_desktop_728_90!ABS SBA!<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>\n<!-- fixed_728_90 -->\n<ins class="adsbygoogle"\n     style="display:inline-block;width:728px;height:90px"\n     data-ad-client="ca-pub-8488699542117607"\n     data-ad-slot="2670898784"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n</script>!ABS SBA!728!ABS SBA!90'
'2697807187!ABS SBA!fixed_desktop_mobile_200_200!ABS SBA!<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>\n<!-- fixed_200_200 -->\n<ins class="adsbygoogle"\n     style="display:inline-block;width:200px;height:200px"\n     data-ad-client="ca-pub-8488699542117607"\n     data-ad-slot="2697807187"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n</script>!ABS SBA!200!ABS SBA!200'
'3234005567!ABS SBA!fixed_desktop_336_280!ABS SBA!<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>\n<!-- fixed_336_280 -->\n<ins class="adsbygoogle"\n     style="display:inline-block;width:336px;height:280px"\n     data-ad-client="ca-pub-8488699542117607"\n     data-ad-slot="3234005567"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n</script>!ABS SBA!336!ABS SBA!280'
'6116464988!ABS SBA!fixed_desktop_468_60!ABS SBA!<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>\n<!-- fixed_468_60 -->\n<ins class="adsbygoogle"\n     style="display:inline-block;width:468px;height:60px"\n     data-ad-client="ca-pub-8488699542117607"\n     data-ad-slot="6116464988"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n</script>!ABS SBA!468!ABS SBA!60'
'6981678885!ABS SBA!fixed_desktop_970_90!ABS SBA!<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>\n<!-- fixed_970_90 -->\n<ins class="adsbygoogle"\n     style="display:inline-block;width:970px;height:90px"\n     data-ad-client="ca-pub-8488699542117607"\n     data-ad-slot="6981678885"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n</script>!ABS SBA!970!ABS SBA!90'
'7132887972!ABS SBA!fixed_desktop_160_600!ABS SBA!<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>\n<!-- fixed_160_600 -->\n<ins class="adsbygoogle"\n     style="display:inline-block;width:160px;height:600px"\n     data-ad-client="ca-pub-8488699542117607"\n     data-ad-slot="7132887972"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n</script>!ABS SBA!160!ABS SBA!600'
'7168179431!ABS SBA!fixed_mobile_300_200!ABS SBA!<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>\n<!-- fixed_mobile_300_200 -->\n<ins class="adsbygoogle"\n     style="display:inline-block;width:300px;height:200px"\n     data-ad-client="ca-pub-8488699542117607"\n     data-ad-slot="7168179431"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n</script>!ABS SBA!300!ABS SBA!200'
'7711808216!ABS SBA!responsivehorizontal!ABS SBA!<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>\n<!-- responsive-horizontal -->\n<ins class="adsbygoogle"\n     style="display:block"\n     data-ad-client="ca-pub-8488699542117607"\n     data-ad-slot="7711808216"\n     data-ad-format="auto"\n     data-full-width-responsive="true"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n</script>!ABS SBA!0!ABS SBA!0'
'8167913254!ABS SBA!fixed_mobile_300_50!ABS SBA!<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>\n<!-- fixed_mobile_300_50 -->\n<ins class="adsbygoogle"\n     style="display:inline-block;width:300px;height:50px"\n     data-ad-client="ca-pub-8488699542117607"\n     data-ad-slot="8167913254"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n</script>!ABS SBA!300!ABS SBA!50'
'8189130995!ABS SBA!responsivesquare!ABS SBA!<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>\n<!-- responsive-square -->\n<ins class="adsbygoogle"\n     style="display:block"\n     data-ad-client="ca-pub-8488699542117607"\n     data-ad-slot="8189130995"\n     data-ad-format="auto"\n     data-full-width-responsive="true"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n</script>!ABS SBA!0!ABS SBA!0'
'8662737279!ABS SBA!fixed_mobile_300_100!ABS SBA!<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>\n<!-- fixed_mobile_300_100 -->\n<ins class="adsbygoogle"\n     style="display:inline-block;width:300px;height:100px"\n     data-ad-client="ca-pub-8488699542117607"\n     data-ad-slot="8662737279"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n</script>!ABS SBA!300!ABS SBA!100'
'9990985608!ABS SBA!fixed_desktop_300_600!ABS SBA!<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>\n<!-- fixed_300_600 -->\n<ins class="adsbygoogle"\n     style="display:inline-block;width:300px;height:600px"\n     data-ad-client="ca-pub-8488699542117607"\n     data-ad-slot="9990985608"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n</script>!ABS SBA!300!ABS SBA!600'
      ai      
      c      
'1!ABS SBA!Introduction!ABS SBA!*Write a c file and make static and\n shared library. Call library in main.!ABS SBA!<h>\n*Source File\n</h>\n\n\nRefer:\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap1_0</m>\n\n\n<h>\n*Header file\n</h>\n\n\nRefer:\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap1_1</m>\n\n\n<h>\n*Object File\n</h>\n\n\nRefer:\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap1_2</m>\n\n\n<h>\n*Declaration and Definition\n</h>\n\n\nRefer:\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap1_3</m>\n\n\n<h>\n*Pre-processing, Compiling, Linking, Loading and Running\n</h>\n\n\nRefer:\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap1_4</m>\n\n\n<h>\n*Executable File Format\n</h>\n\n\nRefer:\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap1_5</m>\n\n\n<h>\n* Segments (.bss, .code, .data etc)\n</h>\n\n\nRefer:\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap1_6</m>\n\n\n<h>\n*Creating static library\n</h>\n\n\nRefer:\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap1_7</m>\n\n\n<h>\n*Creating dynamic library\n</h>\n\n\nRefer:\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap1_8</m>\n\n\n<h>\n*Discussion on where c fits\n</h>\n\nC\'s type system and error checks exist only at compile-time. The compiled code runs in a stripped down run-time model with no safety checks for bad type casts,bad array indices, or bad pointers. There is no garbage collector to manage memory. Instead the programmer manages heap memory manually. All this makes C fast but fragile.\n\nPerl and Java are more "portable" than C (you can run them on different computers without a recompile). Java and C++ are more structured than C.  Structure is useful for large projects. C works best for small projects where performance is important and the programmers have the time and skill to make it work in C. In any case, C is a very popular and influential language. This is mainly because of C\'s clean (if minimal) style, it\'s lack of annoying or regrettable constructs, and the relative ease of writing a C compiler.'
'2!ABS SBA!Data type, Operator and expression!ABS SBA!*Write a funtion to accept multidimensional array\n as an argument.!ABS SBA!<h>\n*Data types and sizes\n  - Integer\n  - Floating point type\n  - Pointer\n - Array\n - Enum\n</h>\n\nC provides a standard, minimal set of basic data types. Sometimes these are called "primitive" types.\nMore complex data structures can be built up from these basic types.\n\nInteger Types\nThe "integral" types in C form a family of integer types.\n\n- char ASCII character -- at least 8 bits.  8 bits provides a signed range of -128..127  or an unsigned range is 0..255. char is also required to be the "smallest addressable unit"\n\n- short Small integer -- at least 16 bits which provides a signed range of\n-32768..32767. Typical size is 16 bits.\n\n- int Default integer -- at least 16 bits, with 32 bits being typical. Defined\nto be  the "most comfortable" size for the computer.\n\n- long Large integer -- at least 32 bits. Typical size is 32 bits which gives a signed range of about -2 billion ..+2 billion. Some compilers support "long long" for 64 bit  ints.\n\nThe integer types can be preceded by the qualifier unsigned which disallows representing negative numbers, but doubles the largest positive number representable.\n\nExtra: Portability Problems\nIt is a good idea to use typedefs to set up types like Int32 for 32 bit int and Int16 for 16 bit int. It makes it processor architecture independent.  Various typedef are available in stdint.h\n\n<<stdint.h>\n<cc>\n#ifndef __int8_t_defined\n# define __int8_t_defined\ntypedef signed char             int8_t;\ntypedef short int               int16_t;\ntypedef int                     int32_t;\n# if __WORDSIZE == 64\ntypedef long int                int64_t;\n# else\n__extension__\ntypedef long long int           int64_t;\n# endif\n#endif\n\n/* Unsigned.  */\ntypedef unsigned char           uint8_t;\ntypedef unsigned short int      uint16_t;\n#ifndef __uint32_t_defined\ntypedef unsigned int            uint32_t;\n# define __uint32_t_defined\n#endif\n#if __WORDSIZE == 64\ntypedef unsigned long int       uint64_t;\n#else\n__extension__\ntypedef unsigned long long int  uint64_t;\n#endif\n.\n.\n.\n</cc>\n\nchar Constants\n<c>\n\'A\' uppercase \'A\' character\n\'\\n\' newline character\n\'\\t\' tab character\n\'x00\' the "null" character -- integer value 0 (different from the char digit \'0\')\n\'\\012\' the character with value 12 in octal, which is decimal 10\n</c>\n\n\nInteger constants\nNumbers in the source code such as 234 default to type int. They may be followed by  an \'L\' (upper or lower case) to designate that the constant should be a long such as 42L.  An integer constant can be written with a leading 0x to indicate that it is expressed in hexadecimal -- 0x10 is way of expressing the number 16. Similarly, a constant may be written in octal by preceding it with "0" - 012 is a way of expressing the number 10.\n\nType Combination and Promotion\nThe integral types may be mixed together in arithmetic expressions since they are all basically just integers with variation in their width. For example, char and int can be combined in arithmetic expressions such as (\'b\' + 5), int and long like (5+10L).\n\nPitfall -- int Overflow\n(k*1024) may not work when k is int in low address bit memory. Way to fix the code is to   rewrite it as (k * 1024L) -- the long constant forced the promotion of the int.\n\nFloating point Types\nfloat Single precision floating point number typical size: 32 bits double precision floating point number typical size: 64 bits long double possibly even bigger floating point number (somewhat obscure)\n\nConstants in the source code such as 3.14 default to type double unless the are suffixed with an \'f\' (float) or \'l\' (long double). Single precision equates to about 6 digits of precision and double is about 15 digits of precision.\n\nfloating point numbers is that they are inexact (1.0/3.0 + 1.0/3.0 + 1.0/3.0) // is this equal to 1.0 exactly?\n- Do not Use  equality (==) -- use inequality (<) comparisons instead.\n\n\nArray\nAn array is a data structure which can store a fixed-size sequential collection of elements of the same type.\n\n<c>\nscore\n |\n v\n0       1       2        3                   99     100\n---------------------------------           -----------\n|      |       |       |          . . . .   |      |   x <-do not use\n---------------------------------           -----------\nint score[100];\n\nArray declaration\n\n- type arrayname[arraysize]\nfloat a[5];\nint x,y,b[5];\n\nArray Initialization\nint a[5]=(1,3,5,};//rest initialized with 0\nint a[]={1,3,5,7,9};\nint age[2][3]={{4,8,12},{19,6,-1}}\n\n\n           0th col     1st col        2nd col\n         ---------------------------------------\n0th row  |           |            |\n         ---------------------------------------\n1st row  |           |            |\n         ---------------------------------------\n\n0th row                                     1st row\n0th col     1st col     2nd col             0th col         1st col       2nd col\n---------------------------------------     ---------------------------------------\n|          |           |            |       |           |           |           |\n---------------------------------------     ---------------------------------------\n</c>\n\nPassing array argument\n<c>\nint func(int score[2][3])\nint func(int score[][3]){}\nint func(int (*score)[3]){}\nfunc(a);//pass by address, value changed in func\n</c>\n\n\nPointer\nA pointer is a value which represents a reference to another value sometimes known as the pointer\'s "pointee".\n\nPointer operators\n<c>\n * (Deference operator)   - means "the value of"\n & (address-of operator)   - means "address of"\n\n int a=5;\n\n        5000|               |\n    a-> 5004|     5         |<----+\n                                  |\n int *pa=&a;                |     |\n        6000|               |     |\n   pa-> 6004|   5004        |<----+\n\nstruct fraction {\nint numerator;\nint denominator;\n};\n\n\nstruct fraction *f1, *f2;\n\n\n                                                -------------\n      -------------                             |     7     | denominator\n f1 |             |  -------------+             +-----------+\n      -------------               |             |     22    | numerator\n               ^                  +---------->  -------------\n               |                                  /\n    struct fraction*                           struct fraction\n                                              (the whole block\n                                              of memory)\n</c>\n\nexpression                  Type\n<c>\nf1                          struct fraction*\n*f1                         struct fraction\n(*f1).numerator             int\n</c>\n\ncomplex declarations\n<c>\nstruct fraction** fp; a pointer to a pointer to a struct fraction\nstruct fraction fract_array[20]; array of 20 struct fraction\nstruct fraction *fract_ptr_array[20]; an array of 20 pointers to struct fraction\nstruct fraction (*pfa)[100];\nstruct fraction (*(*pf)())();\n\nf(int daytab[2][13]) { ... }\n\nIt could also be\nf(int daytab[][13]) { ... }\n\nSince the number of rows is irrelevant, or it could be\nf(int (*daytab)[13]) { ... }\n\nWhich says that the parameter is a pointer to an array of 13 integers.\nThe parentheses are necessary since brackets [] have higher precedence\nthan *. Without parentheses, the declaration would be\n\nint *daytab[13] // array of pointer to ints\n</c>\n\nThere is an important difference between these definitions:\n<c>\nchar amessage[] = "now is the time"; /* an array */\nchar *pmessage = "now is the time"; /* a pointer */\nchar (*(*x())[])()\nx: function returning pointer to array[] of pointer to function returning char\nchar (*(*x[3])())[5]\nx: array[3] of pointer to function returning pointer to array[5] of char\n</c>\n\nDynamic allocation\n<c>\nmalloc : memory allocation\nfree      : memory deallocation\n\nint *intptr;\nchar *charpt;\nintptr=(int*)malloc(sizeof(int));\ncharptr=(char*)malloc(sizeof(char)*6);\nfree(intptr);\nfree(charptr);\n</c>\n\nMemory leak - Memory allocated is not de-allocated.\nDangling pointer - A pointer that points to a variable that has been de-allocated.\n\nPointer arithmetic\n<c>\nint *pi;\nchar *pc;\n++pi;//jumps 4 bytes in 32 bit processor\n++pc;//jumps 1 byte\n</c>\n\nArray & Pointers\n<c>\nint a[10];\nint *b=&a[0];\n\nconst char *pc="string";\nchar ac[]="string";\n\n           -------------------------------------\npc ------->|\n           -------------------------------------\n</c>\nPointer to a block of memeory\n<c>\n\nac\n-----------------------------------\n|\n------------------------------------\nArray of memory fragments. No address\n</c>\n\nEnum\nAn enumeration is a list of constant integer values.\n<c>\nenum boolean { NO, YES };\nenum months { JAN = 1, FEB, MAR, APR, MAY, JUN,\nJUL, AUG, SEP, OCT, NOV, DEC };\n/* FEB = 2, MAR = 3, etc. */\neum {No,YES}; // global\n\nboolean value=NO;\n\n$cat main.c\n#include <stdio.h>\nstruct SomeItem{\nenum {MOVIE,MUSIC} itemType;\nunion{\nint movieid;\nchar moviename[255];\n};\n};\n\n\nint main(int argc, char *argv[]){\nstruct SomeItem someitem;\nsomeitem.itemType=MUSIC;\nsomeitem.movieid=10;\nreturn 0;\n}\n</c>\n\n<h>\n*Constant\n</h>\n\nConst\nThe qualifier const can be added to the left of a variable or parameter type to declare that the code using the variable will not change the variable.\n\n<c>\nvoid foo(const struct fraction* fract);\nint i, *pi, *const cpi = &i;\nconst int j=func();\nchar amessage[] = "now is the time"; /* an array */\nchar *pmessage = "now is the time"; /* a pointer */\nconst int *p; // pointer to constant\nint * const p;//const pointer to integer\nconst int * const p;//const pointer to integer const\n</c>\n\nConst must be defined or initialized at the time of declaration.\n\nConst has internal linkage similar to static.\n\n<h>\n*Variable Declaration and Definition\n</h>\n\nDeclaration - Asserts the existence of a variable, function or type defined elsewhere in the program. A variable may be declared by preceding its type with the keyword extern.\n\nconst declaration are file scope and must be initialized or defined at the time of declaration.\n\nstatic variable and functions are file scoped and they can not be defined in other files like extern.\n\n$ cat a.c\n<c>\nextern int a;\nextern const int b=10;\n</c>\n\n$ cat b.c\n<c>\n#include <stdio.h>\nint a=10;//defined here\nconst  int b=20; // error while linking\nint main(){\nreturn 0;\n}\n</c>\n\n$ gcc -c a.c -o a.o\n<c>\na.c:2: warning: \'b\' initialized and declared \'extern\'\n</c>\n$ gcc -c b.c -o b.o\n$ gcc -o aa a.o b.o\n<c>\nb.o:(.rodata+0x0): multiple definition of \'b\'\na.o:(.rodata+0x0): first defined here\ncollect2: ld returned 1 exit status\n\nint a; // just declaration\nvoid func();//just declaration\n\nc++\nint a // declaration and definition\nextern a // declaration\n</c>\n\nDeclaration can be made multiple times.\n\nDefinition - Allocates storage for a variable of a specified type and\noptionally initializes the variable\n\n<c>\nint a=10; //declaration and definition\nvoid func(){// declaration and definition\n</c>\n}\n\n- Definition must be only once.\n\n<h>\n* Operator\n - Assignment operator and expression\n - Arithmetic operator\n - Relational operator\n - Conditional operator\n</h>\n\n\nAn operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations.\n\n- Assignment operator and expression\nHere\'s the list of assignment shorthand operators...\n\n<c>\n+=, -= Increment or decrement by RHS\n*=, /= Multiply or divide by RHS\n%= Mod by RHS\n>>= Bitwise right shift by RHS (divide by power of 2)\n<<= Bitwise left shift RHS (multiply by power of 2)\n&=, |=, ^= Bitwise and, or, xor by RHS\n\n- Arithmetic Operators\n+ Addition\n- Subtraction\n/ Division\n* Multiplication\n% Remainder (mod)\n\n- Unary Increment Operators: ++ --\n</c>\n\nThe unary ++ and -- operators increment or decrement the value in a variable.\n<c>\nvar++ //post variant\n++var //pre variant\n</c>\n\n- Relational Operators\nThese operate on integer or floating point values and return a 0 or 1 boolean value.\n\n<c>\n== Equal\n!= Not Equal\n> Greater Than\n< Less Than\n>= Greater or Equal\n<= Less or Equal\n</c>\n\nProblem.\n<c>\nwhile(x=3);//legal\nwhile(x==3);//legal\n</c>\n\n- Logical Operators\nThe value 0 is false, anything else is true.\n<c>\n! Boolean not (unary)\n&& Boolean and\n|| Boolean or\n</c>\n\n- Conditional Operators ?:\n<c>\nExp1 ? Exp2 : Exp3;\n</c>\nWhere Exp1, Exp2, and Exp3 are expressions.\n\n- Misc Operators\n<c>\nsizeof() Returns the size of an variable\n& Returns the address of an variable\n* Pointer to a variable\n</c>\n\n<h>\n*Bitwise operator\n</h>\n\nBitwise Operators\nC includes operators to manipulate memory at the bit level.\n\n<c>\n~ Bitwise Negation (unary)  flip 0 to 1 and 1 to 0 throughout\n& Bitwise And\n| Bitwise Or\n^ Bitwise Exclusive Or\n>> Right Shift by right hand side (RHS) (divide by power of 2)\n<< Left Shift by RHS (multiply by power of 2)\n</c>\n\n- Note & and && are different\n<c>\nunsigned int a = 60; /* 60 = 0011 1100 */\nunsigned int b = 13; /* 13 = 0000 1101 */\nint c = 0;\nc = a & b; /* 12 = 0000 1100 */\nprintf("Line 1 - Value of c is %d\n", c );\nc = a | b; /* 61 = 0011 1101 */\nprintf("Line 2 - Value of c is %d\n", c );\nc = a ^ b; /* 49 = 0011 0001 */\nprintf("Line 3 - Value of c is %d\n", c );\nc = ~a; /*-61 = 1100 0011 */\nprintf("Line 4 - Value of c is %d\n", c );\nc = a << 2; /* 240 = 1111 0000 */\nprintf("Line 5 - Value of c is %d\n", c );\nc = a >> 2; /* 15 = 0000 1111 */\n</c>\n\n<h>\n*Type conversion\n</h>\n\nWhen an operator has operands of different types, they are converted to a common type according to a small number of rules. In  general, the only automatic conversions are those that convert a promotion "narrower" operand into "wider" one without losing information, such as converting an integer into floating point in an expression like f + i.\n\nTruncation\nExpressions that might lose information, like assigning a longer integer type to a shorter, or a floating-point type to an integer, may draw a warning, but they are not illegal.\n<h>\n*Conditional expression\n</h>\n\nConditional Expression ?:\nExp1 ? Exp2 : Exp3;\nWhere Exp1, Exp2, and Exp3 are expressions.'
'3!ABS SBA!Array Pointers References!ABS SBA!*Modify function argument to accept\n pointer to array.\n*Implement a function to accept pointer to\n int and check were boundary overflow is\n not checked by the compiler.!ABS SBA!<h>\n*Defnining and Initialzing Array\n</h>\n\n- Define and initialize static array\n- Array has to be initialized with constant variable that is qualified at compile time\n\n<c>\nint ia[get_size()]  // get_size() is function and resolved at run time\nconst int size=get_size(); // size resolved at run time\nint ia[size]; // error\nint ia[10*2-10]; // resolved at compile time\n</c>\n\n- Local copy are uninitialized where as global copy is initialized to 0.\n- Uninitialized stati c or global array goes to .bss section in the binary.\n- Array is initialized in {} block\n\n<c>\nint arr[]={1,2,3} // array size 3\n</c>\nor\n<c>\nInt arr[3]={1,2,3}\nInt arr[5]={1,2,3} // rest initialized with 0\n</c>\n\nUninitialized const array takes garbage value\n<c>\nconst int arr[3];// garbage value\n\nC++ const uninitialized array is an error\nconst int arr[3]={1}; // rest initialized with 0\nconst int *arr=new arr[3]() // c++ value initialized\n</c>\n\nBreaking array boundary is not an exception and it memory over writing\n<c>\nint ary[1];\nary[2]=0;\n</c>\n\nFunction array arguments are actually pointer to array.\n<c>\nvoid func(int ap[4]);\nVoid func(int ap[]);\nvoid func(int *ap); //all are same\nfunc (arr);\n</c>\n\n-Pointer to array and multidimensional array\n<c>\nvoid func(int (*arr)[10]);\nvoid func(int arr[][10]);\nvoid func(int arr[4][10]);// all same\n</c>\n\n- Array can not be copied or assigned\n<c>\nint ia2[](ia); // error\nia2 = ia1; //error\n</c>\n\n- Array size can not be known.\n<c>\nsizeof(arr)/sizeof(&arr[0])\n</c>\n\n- Array memory management is in users hand. Chance of memory overwriting.\n\n<c>\nvoid func(int pa[6]){\npa[6]=8;\n}\nint pa[4];\nfunc(pa);\n</c>\n\n- Character array can be initialized with string null terminated.\n<c>\nchar ca[] = "C++";\n</c>\n\n- Character array can be initialized character wise, many not be null\nterminated\n<c>\nchar cal[] = {\'C\', \'+\', \'+\', \'\\0\' };\n</c>\n\n- In case of character strings use strn string function for manipulation, si.e\n<c>\nstrncpy, strncat.\n</c>\n\n<h>\n*Defining and initializing Pointers\n</h>\n\n<c>\ntype * pointer_name[,*pointer,name2,..];\nchar * terry = "hello"; //character string\nconst char *terry;//pointer to constant char\nchar *const terry;//const pointer to char\nconst char *const terry;//const pointer to char const\n</c>\n\nVarious library function involving char pointer manipulation\n<c>\nstr[n]cpy,str[n]cat,str[n]cmp,strdup,bcopy,memccopy,\nmemcpy,memmove,string,wcscpy,wcsncpy,index, rindex,\nstrcasecmp,strchr,strcmp, strcoll, strcspn,  strfry,\nstrlen,strncasecmp, strpbrk, strrchr,strsep, strspn,\nstrstr, strtok, strxfrm\n</c>\n\n- Dynamically allocating array, allocating on heap\n<c>\n- void *realloc(void *ptr, size_t size);// buffer remain uninitialized\nint pia = malloc(sizeof(int)*10); // uninitialized\n\n- void *realloc(void *ptr, size_t size);// initialized buffer with char 0;\nint pia=calloc(sizeof(int)*10);\n\n- void *realloc(void *ptr, size_t size);// re-allocate uninitialized buffer of new size if continuous memory is available for new size.\nint pia=malloc(sizeof(int)*10);\npia=realloc(sizeof(int)*20);\n</c>\n\nIf run on empty buffer malloc is called. 0 size free the memory\n\n<c>\n- void *realloc(void *ptr, size_t size);, frees the allocated memory\nfree(pia);\n</c>\n\n\n- Its legal to dynamically allocate empty array unless dereferenced\n<c>\nchar arr[0]; // error\nchar arr = new char[0];// ok\nchar arr = new char[get_size()];//get_size() can return 0;\n</c>\n\n\n<h>\n*Using Pointers to access array elements\n</h>\n\n- Pointer works in dynamic allocation\n\n- Array of pointers\n<c>\nclassA *arrp=new classA[10];\n</c>\n\n- Pointer to array of size 10\n<c>\nclassA (*ptoarr)=new classA[10];\nclassA arryofarry[3][10;\nptoarr=&arryofarry[2];\n\nint (*pa)[10];\nint *pi[10];\n\nint arr[4][10]\npa=arr;\npa++\n\n\nint (*pa)[10];\nint arr[4][10];\npa=arr;\ni=0;\nfor(j=0;j<4;j++){\nfor(k=0;k<10;k++)\narr[j][k]=i;\n++i;\n}\n++pa;\nfor(j=0;j<10;j++)\ncout<<pa[0][j];\n</c>\n\n<h>\n*Pointers and const qualifiers\n</h>\n\nread from the right to left.\n<c>\nconst char *terry;//pointer to constant char\nchar *const terry;//const pointer to char\nconst char *const terry;//const pointer to char const\n</c>\n\n<h>\n*Dynamic allocated arrays\n</h>\n\n- malloc, calloc, realloc and free  are used for dynamic allocation\n<c>\n#include <stdlib.h>\n\nvoid *calloc(size_t nmemb, size_t size);\nvoid *malloc(size_t size);\nvoid free(void *ptr);\nvoid *realloc(void *ptr, size_t size);\n</c>\n\n<h>\n*Multidimensional array arugment to function\n</h>\n\n$ cat main.c\n<c>\n#include <stdio.h>\n\nvoid printarray(int (*arr)[4]){\nint i=0,j=0;\nfor (i=0;i<4;i++){\nfor (j=0;j<4;j++)\nprintf("%d ",arr[i][j]);\nprintf("\n");\n}\n}\nvoid preparearray(int (*arr)[4]){\nint i=0,j=0;\nfor (i=0;i<4;i++)\nfor (j=0;j<4;j++)\narr[i][j]=i;\n}\n\nint main(int argc,char *argv[]){\nint arr[4][4];\npreparearray(arr);\nprintarray(arr);\nreturn 0;\n}\n\n$ ./a.out\n0 0 0 0\n1 1 1 1\n2 2 2 2\n3 3 3 3\n</c>'
'4!ABS SBA!Control structures!ABS SBA!*Modify for loop to while loop!ABS SBA!<h>\n*Statement and Block\n</h>\n\nA single statement is any valid string in C which ends with a semi colon.\ne.g.\n<c>\na = 6;\n; // empty statement\nprintf ("I love C because...");\n</c>\n\nA compound statement is any number of single statements grouped together in curly braces. The curly braces do not end with a semi colon and stand in place of a single statement. Any pair of curly braces may contain local declarations after the opening brace. e.g.\nBlock statement\n<c>\n{\nint i;\na = 6;\n}\n\n{\nint a; // second definition but in different statement block\na = 6;\nprintf ("I love C because...");\n}\n</c>\n\n<h>\n*Statements\n - If\n - Switch\n - While\n - For\n - do while\n</h>\n\nIf\n<c>\n if (<expression>) <statement> // simple form with no {}\'s or else clause\n if (<expression>) { // simple form with {}\'s to group statements\n <statement>\n <statement>\n }\n\nif (<expression>) { // full then/else form\n<statement>\n}\nelse {\n<statement>\n}\n</c>\n\nSwitch\nThe switch statement is a sort of specialized form of if used to efficiently separate different blocks of code based on the value of an integer.\n\n<c>\nswitch (<expression>) {\ncase <const-expression-1>:\n<statement>\nbreak;\ncase <const-expression-2>:\n<statement>\nbreak;\ncase <const-expression-3>: // here we combine case 3 and 4\ncase <const-expression-4>:\n<statement>\nbreak;\ndefault: // optional\n<statement>\n}\n</c>\n\nWhile Loop\nThe while loop evaluates the test expression before every loop, so it can execute zero times if the condition is initially false. It requires the parenthesis like the if.\n\n<c>\nwhile (<expression>) {\n<statement>\n}\n</c>\n\nDo-While Loop\nLike a while, but with the test condition at the bottom of the loop.  The loop body will always execute at least once. The do-while is an unpopular area of the language, most everyone tries to use the straight while if at all possible.\n\n<c>\ndo {\n<statement>\n} while (<expression>)\n</c>\n\n<h>\n*Break and Continue\n</h>\n\nBreak\nThe break statement will move control outside a loop or switch statement.\n<c>\nwhile (<expression>) {\n<statement>\n<statement>\nif (<condition which can only be evaluated here>)\nbreak;\n<statement>\n<statement>\n}\n</c>\n\n// control jumps down here on the break\nContinue\nThe continue statement causes control to jump to the bottom of the loop, effectively skipping over any code below the continue.\n<c>\nwhile (<expression>) {\n...\nif (<condition>)\ncontinue;\n...\n...\n// control jumps here on the continue\n}\n</c>\n\n<h>\n*Goto and Labels\n</h>\n\nA goto statement in C programming language provides an unconditional jump from the goto to a labeled statement in the same function.\nNOTE: Use of goto statement is highly discouraged in any programming language because it makes difficult to trace the control flow of a program, making the program hard to understand and hard to modify. Any program that uses a goto can be rewritten so that it doesn\'t need the goto.\n\nSyntax\nThe syntax for a goto statement in C is as follows:\n\n<c>\ngoto label;\n..\n.\nlabel: statement;\n</c>'
'5!ABS SBA!Function!ABS SBA!*Recursion\n - Implement fibonacci series\n -Implement factorial!ABS SBA!<h>\n*struct\n - Structures and functions\n - Array of structure\n - Self referential structure\n - Typedef\n - Unions\n - Bit-fields\n</h>\n\nA structure is a collection of one or more variables, possibly of different types, grouped together under a single name for convenient handling.\nA structure is user defined type.\nAll members are public.\n\n<c>\nstruct fraction{\nint numerator;\nint denominator;\n};\n</c>\n\nA struct declaration defines a type. The right brace that terminates the list of members may be followed by a list of variables, just as for any basic type.  That is,\n\n<c>\nstruct { ... } x, y, z;\n</c>\n\nis syntactically analogous to\n<c>\nint x, y, z;\n</c>\n\nstruct initialization\nA structure can be initialized by following its definition with a list of initializers, each a constant expression, for the members:\n\n<c>\nstruct maxpt = { 320, 200 };\n</c>\n\nStructure as member\n\n<c>\nstruct point{\nint x;\nint y;\n};\n\n\nstruct rect{\nstruct point p1;\nstruct point p2;\n};\n\nstruct {\nint len;\nchar *str;\n} *p;  //instantiation\n</c>\n\nthen\n<c>\n++p->len\n</c>\nIncrements len, not p, because the implied parenthesization is ++(p->len).\n\nStructure and Function\n - pass by value\n - pass by address\n\n<c>\nstruct addpoints(const struct point p1, const stuct point p2){\nstuct point result;\n...\nreturn result;\n}\n\nstruct addpoints(const struct point *p1,const struct point *p20){\n...\nreturn result;\n}\n</c>\n\nRecursively defined structures\n- when two structures refer to each other, one must be declared in\n incomplete(prototype) fashion\n\n<c>\nstruct HUMAN;\nstruct PEN{\nchar name[NAME_LIMIT];\nchar species[NAME_LIMIT];\nstruct HUMAN *owner;\n}fido={"Fido","Canis lupus familiaries"};\nstruct HUMAN{\nchar name[NAME_LIMIT];\nstruct PEN pets[PET_LIMIT];\n}sam={"Sam",{fido}};\n</c>\n\nArray of Structures\nConsider writing a program to count the occurrences of each C keyword.\n\n<c>\nstruct key {\nchar *word;\nint count;\n} keytab[NKEYS];\n</c>\n\nInitialize\n\n<c>\nstruct key {\nchar *word;\nint count;\n} keytab[] = {\n"auto", 0,\n"break", 0,\n"case", 0,\n"char", 0,\n"const", 0,\n"continue", 0,\n"default", 0,\n/* ... */\n"unsigned", 0,\n"void", 0,\n"volatile", 0,\n"while", 0\n};\n</c>\n\nTypedefs\n\n<c>\ntypedef struct{\n} pstruct; //typedef\npstruct p;\n</c>\n\n- Self referential structure\nConsider simple tree structure where each node has value and it pointer to left and right node of the tree.\n\n<c>\nstruct tnode { /* the tree node: */\nint data; /* number of occurrences */\nstruct tnode *left; /* left child */\nstruct tnode *right; /* right child */\n};\n</c>\n\n\nUnion\nA union is a variable that may hold (at different times) objects of different types and sizes, with the  compiler keeping track of size and alignment requirements\n\nunion-name.member\nor\nunion-pointer->member\n\n<c>\nunion u_tag {\nint ival;\nfloat fval;\nchar *sval;\n} u;\n</c>\n\nThe variable u will be large enough to hold the largest of the three types;\n\n<c>\nstruct {\nchar *name;\nint flags;\nint utype;\nunion {\nint ival;\nfloat fval;\nchar *sval;\n} u;\n} symtab[NSYM];\n</c>\n\nthe member ival is referred to as\n<c>\nsymtab[i].u.ival\n</c>\n\nand the first character of the string sval by either of\n<c>\n*symtab[i].u.sval\nsymtab[i].u.sval[0]\n</c>\n\n\n- union can be used to find polarity of machine\n<c>\nunion{\nunsigned Int i;\nchar *c[4];\n}un;\nun.i=1\nif(un.c[0])\nprintf("little endian\n")\nElse\nprintf("big endian");\n</c>\n\nBit fields\nIf space is a serious concern, select the number of bits used for each member\nA bit-field, or field for short, is a set of adjacent bits within a single implementation-defined storage unit that we will call a "word."\n\n<c>\nstruct  {\nunsigned int is_keyword:1;\nunsigned is_extern: 1;\nunsigned is_static: 1;\n}flags;\n\nflags.is_extern = flags.is_static = 1; //turn on\nflags.is_extern = flags.is_static = 0; // turn off\n</c>\nif (flags.is_extern == 0 && flags.is_static == 0) // to test them\n\nFiles are not arrays and they do not have addresses, so the &\noperator cannot be applied on them.\n\nAlmost everything about fields is implementation-dependent. Whether a field may overlap a word boundary is implementation-defined.  Fields need not be names; unnamed fields (a colon and width only) are used for padding. The special width 0 may be used to force alignment at the next word boundary.'
'6!ABS SBA!Complex Data Types!ABS SBA!*Check machine is little endian or big endian using union!ABS SBA!<h>\n*Function Introduction\n</h>\n\nFunction\nA small program(subroutine) that performs a particular task\n- Input : parameter / argument\n- Perform what ? : function body\n- Output :  return value\n\nModular programming design\n- Large and complex task can be divided into smaller and simple task which is more easily solved (implemented).\n- Also called\n - structured design\n - Top-down design\n - Divide-and-Conquer\n\n/*\nComputes double of a number.\nWorks by tripling the number, and then subtracting to get back to double.\n*/\n<c>\nstatic int Twice(int num) {\nint result = num * 3;\nresult = result - num;\nreturn(result);\n}\n</c>\n\n<h>\n*Scope rule\n</h>\n\nThe scope of a name is the part of the program within which the name can be used.\nGlobal variable\n- Declared, outside function block\n- Accessible everywhere\n\n- Global variable is destroyed only when a program is terminated\n- Global variable is initialized before main function enters\n\nLocal variable ( automatic variable?)\n- Declared inside function body\n- Accessible only in the function\n- Local variable is created when a function is called and is destroyed when a function returns\n- Storage allocation on stack.\n\nStatic variable ( declared in a function)\n- (Usually) accessible in the function\n- Initialized to 0\n- Goes to initialized or uninitialized section and not on stack\n- Static variable persists until the program is terminated\n\n<c>\nmain() { ... }\nint sp = 0; // global variable, extern is allowed in other file\nstatic sps=0; // extern is not allowed in other file\ndouble val[MAXVAL];\nvoid push(double f) { ... }\ndouble pop(void) { ... }\n</c>\n\n$ cat test1.c\n<c>\nint sp=20;\n</c>\n$ cat main.c\n<c>\n#include <stdio.h>\nextern int sp;\nint main(){\nprintf("sp %d\n",sp);\nreturn 0;\n}\n</c>\n\n<h>\n*Header rule\n</h>\n\nA header file is a file with extension .h which contains C function declarations and macro definitions and to be shared between several source files.\n\n<h>\n*Block structure\n</h>\n\nVariables can be defined in a block-structured fashion within a function.\nDeclarations of variables (including initializations) may follow the left brace that introduces any compound statement, not just the one that begins a function. Variables declared in this way hide any identically named variables in outer blocks, and remain in existence until the matching right brace.\n\nFor example, in\n\n<c>\nif (n > 0) {\nint i; /* declare a new i */\nfor (i = 0; i < n; i++)\n...\n}\n</c>\n\nor\nsimple block {\n<c>\nusing namespace abc;\nvar=10;//var in abv\n}\n{\nusing namespace def;\nvar=20;//var in def\n}\n</c>\n\n<h>\n*Function declaration and Definition\n</h>\n\nFunction declaration does not have block.\n<c>\nvoid func();\nextern funct();\n</c>\n\nFunction declaration goes to header file.\n\nFunction definition has {} block.\nFunction when called callee function data is allocated on stack.\n<c>\nvoid func(){\n}\n</c>\nFunction definition goes to source file.\n\nFunction call stack\nSupports the function call/return mechanism\n- Each time a function calls another function, a stack frame (also known as an activation record)  is pushed onto the stack\n- Maintains the return address that the called function needs to return to the calling function\n- Contains automatic variables - parameters and any local variables the function declares\n- When the callee functions returns\n - Stack frame for the function call is popped\n - Control transfers to the return address in the popped stack frame\nStack overflow\n- Due memory limitation new stack allocation is not possible\n\n<h>\n*Value and reference parameters\n</h>\n\nFunction caller passes argument to function callee as value. There is no reference in c.\n\n<c>\nint i=0;\nint *pa=&i;\nchar *ps;\nvoid func(int);\nvoid func(int*);\nvoid func(char **);\n\nfunc(i);\nfunc(pa);\nfunc(&ps,10);\n\nvoid func(char **pps,int isize){\n*pps=malloc(isize*sizeof(char));\n}\n</c>\n\n<h>\n*Inline function\n</h>\n\n The compiler will insert the complete body of the inline function in every place in the code where that function is used.\n- Reduce overhead for function call & return\n- Effective when a function is short and simple\n\n<c>\ninline int cube(int n){\nreturn n*n*n;\n}\n</c>\n\n<h>\n*Recursion\n</h>\n\nC functions may be used recursively; that is, a function may call itself either directly or indirectly.\n\n<c>\n#include <stdio.h>\n/* printd: print n in decimal */\nvoid printd(int n)\n{\nif (n < 0) {\nputchar(\'-\');\nn = -n;\n}\nif (n / 10)\nprintd(n / 10);\nputchar(n % 10 +\'0\');\n}\n\n--------------\nvoid printd(int 12)\n{\nif (n < 0) {\nputchar(\'-\');\nn = -n;\n}\nif (n / 10)\nprintd(n / 10);      -----------------\nputchar(n % 10 +\'0\');                 |\n}                                     |\n-------------                         |\n-------------                         |\nvoid printd(int 1) <----------------\n{\nif (n < 0) {\nputchar(\'-\');\nn = -n;\n}\nif (n / 10)\nprintd(n / 10);\nputchar(n % 10 +\'0\');\n}\n-------------\n</c>\n\n<h>\n*Preprocessor\n - File inclusion\n  - Macro\n  - Conditional inclusion\n</h>\n\nFile inclusion\nFile inclusion makes it easy to handle collections of #defines and declarations (among other things). Any source line of the form\n\n<c>\n#include "filename"\n</c>\nor\n<c>\n#include <filename>\n</c>\n\nMacro\nA definition has the form\n\n<c>\n#define name replacement text\n#define paste(front, back) front ## back\n</c>\nConditional Inclusion\nConditional inclusion provides a way to include code selectively, depending\non the value of conditions evaluated during compilation.\n\n<c>\n#if SYSTEM == SYSV\n#define HDR "sysv.h"\n#elif SYSTEM == BSD\n#define HDR "bsd.h"\n#elif SYSTEM == MSDOS\n#define HDR "msdos.h"\n#else\n#define HDR "default.h"\n#endif\n#include HDR\n</c>'
'7!ABS SBA!Input and Output!ABS SBA!*Try various buffering, character, line and file\n buffering. Check out speed differences.!ABS SBA!<h>\n*Standard Input and Output\n</h>\n\nStandard Input\nInput from system console\n\n<c>\nint getchar(void)\nprog <infile   //prog is user program with getchar\nanotherprog | prog\n</c>\n\nOutput to system console\n<c>\nint putchar(int)\nprog >outfile\nprog | anotherprog\n</c>\n\nVarious unbuffered APIs\n<c>\nint open(const char *pathname, int flags, mode_t mode);\nssize_t read(int fd, void *buf, size_t count);\nssize_t write(int fd, const void *buf, size_t count);\noff_t lseek(int fd, off_t offset, int whence);\nint close(int fd);\n</c>\n\n<h>\n*Buffered i/o\n</h>\n\n<c>\n          --------------         --------\n          | User Space | <-----> |Buffer|\n          --------------         --------\n                ^\n                |\n                v\n--------------------------------------\n              Kernel\n\n\n FILE *fopen(const char *path, const char *mode);\n FILE *fdopen(int fd, const char *mode);\n int fprintf(FILE *stream, const char *format, ...);\n int fgetc(FILE *stream);\n int fputc(int c, FILE *stream);\n int fclose(FILE *fp);\n</c>\n\n<h>\n*Variable length argument list\n</h>\n\n<c>\n#include <stdarg.h>\ndouble average(int num,...)\n{\nva_list valist;\ndouble sum = 0.0;\nint i;\n/* initialize valist for num number of arguments */\nva_start(valist, num);\n/* access all the arguments assigned to valist */\nfor (i = 0; i < num; i++)\n{\nsum += va_arg(valist, int);\n}\n/* clean memory reserved for valist */\nva_end(valist);\nreturn sum/num;\n}\n</c>\n\nDefine a function with last parameter as ellipses and the one just before the ellipses is always an int which will represent number of arguments.\n\nCreate a va_list type variable in the function definition. This type is defined in stdarg.h header file.\n\nUse int parameter and va_start macro to initialize the  va_list variable to an argument list. The macro va_start is defined in stdarg.h header file.\n\nUse va_arg macro and va_list variable to access each item in argument list.\n\nUse a macro va_end to clean up the memory assigned to va_list variable.\n\n<h>\n*File access\n</h>\n\n<c>\nFILE *fp;\nFILE *fopen(char *name, char *mode);\nint getc(FILE *fp)\n</c>\n\ngetc returns the next character from the stream referred to by fp;\nit returns EOF for end of file or error.\n<c>\nint putc(int c, FILE *fp)\n</c>\n\nputc writes the character c to the file fp and returns the character written, or EOF if an error occurs. Like getchar and putchar, getc and putc may be macros instead of functions.\n\ngetchar and putchar can be defined in terms of getc, putc, stdin, and stdout as follows:\n\n<c>\n#define getchar() getc(stdin)\n#define putchar(c) putc((c), stdout)\n</c>\n\nFor formatted input or output of files, the functions fscanf and fprintf may be used. These are identical to scanf and printf, except that the first argument is a file pointer that specifies the file to be read or written; the format string is the second argument.\n\n<c>\nint fscanf(FILE *fp, char *format, ...)\nint fprintf(FILE *fp, char *format, ...)\n\n#include <stdio.h>\n/* cat: concatenate files, version 1 */\nmain(int argc, char *argv[])\n{\nFILE *fp;\nvoid filecopy(FILE *, FILE *);\nif (argc == 1) /* no args; copy standard input */\nfilecopy(stdin, stdout);\nelse\nwhile(--argc > 0)\nif ((fp = fopen(*++argv, "r")) == NULL) {\nprintf("cat: can\'t open %s", *argv);\nreturn 1;\n} else {\nfilecopy(fp, stdout);\nfclose(fp);\n}\nreturn 0;\n</c>\n\n<h>\n*Line input and output\n</h>\n\nThe standard library provides an input and output routine fgets that is similar to the getline function that we have used in earlier chapters: char *fgets(char *line, int maxline, FILE *fp)\n\nfgets reads the next input line (including the newline) from file fp into the character array line; at most maxline-1 characters will be read. The resulting line is terminated with \'\\0\'. Normally fgets returns line; on end of file or error it returns NULL. (Our getline returns the line length, which is a more useful value; zero means end of file.) For output, the function fputs writes a string (which need not contain a newline) to a file:\n<c>\nint fputs(char *line, FILE *fp)\n</c>\n\nIt returns EOF if an error occurs, and non-negative otherwise.\nThe library functions gets and puts are similar to fgets and fputs, but operate on stdin and stdout. Confusingly, gets deletes the terminating \'\\n\', and puts adds it.\n\nTo show that there is nothing special about functions like fgets and fputs, here they are, copied from the standard library on our system:\n\n<c>\n/* fgets: get at most n chars from iop */\nchar *fgets(char *s, int n, FILE *iop)\n{\nregister int c;\nregister char *cs;\ncs = s;\nwhile (--n > 0 && (c = getc(iop)) != EOF)\nif ((*cs++ = c) == \' \')\nbreak;\n*cs = \'\\0\';\nreturn (c == EOF && cs == s) ? NULL : s;\n}\n/* fputs: put string s on file iop */\nint fputs(char *s, FILE *iop)\n{\nint c;\nwhile (c = *s++)\nputc(c, iop);\nreturn ferror(iop) ? EOF : 0;\n}\n</c>\n\nFor no obvious reason, the standard specifies different return values for ferror and fputs. It is easy to implement our getline from fgets:\n\n<c>\n/* getline: read a line, return length */\nint getline(char *line, int max)\n{\nif (fgets(line, max, stdin) == NULL)\nreturn 0;\nelse\nreturn strlen(line);\n}\n</c>\n\n<h>\n*Error handling - stderr and exit\n</h>\n\na)Program exit\nA program can exit with exit(int) system call. program return status can be checked later. If program crashes because of signal then system fills the return status. Generally 0 is success and nonzero is failure. $? shell command prints the exit status of last run program\n\n<c>\n$ ls /\nbin coda etc lib misc nfs proc sbin usr\nboot dev home lost+found mnt opt root tmp var\n\n$ echo $?\n0\n</c>\n\n<c>\n$ ls bogusfile\nls: bogusfile: No such file or directory\n</c>\n\n$ echo $?\n<c>\n1\n</c>\n\nb) System call failure\nGlobal variable errno carries the last error encountered in any system call.\nVarious constants i.e EINTR, EROFS etc are defined with particular error\nnumber and errno variable need to be checked against these constants rather\nthen integer. stderror(int) function prints the error description with errno\npassed as an argument.'
'8!ABS SBA!Storage class Specifier!ABS SBA!*Modify global variable defined in one in other c file!ABS SBA!<h>\n*Automatic\n</h>\n\nThe auto storage class is the default storage class for all local variables.\n<c>\n{\nint mount;\nauto int month;\n}\n</c>\n\nThe example above defines two variables with the same storage class, auto can only be used within functions, i.e., local variables.\n\n<h>\n*Const\n</h>\n\nThe purpose of const is to announce objects that may be placed in read-only memory, and perhaps to increase opportunities for optimization.\n\n<h>\n*Global\n</h>\n\nVariable defined in global scope of the file.\nGlobal variables are visible across the program.\nFile using the global variable need to declare it as extern in order to that file compiled.\n\n<h>\n*Extern\n</h>\n\nThe extern storage class is used to give a reference of a global variable that is visible to  ALL the program files.\n\n<c>\n#include <stdio.h>\nint count ; //definition\nextern void write_extern();  //defined somewhere else\n\nmain()\n{\nwrite_extern();\n}\nSecond File: write.c\n#include <stdio.h>\nextern int count; //only declaration, defined somewhere else\nvoid write_extern(void)\n{\ncount = 5;\nprintf("count is %d\n", count);\n</c>\n\n<h>\n*Register\n</h>\n\nRegister declared are opted to be put in registers.\n\n<c>\nregister int x;\nregister char c;\n</c>\n\nThe register declaration can only be applied to automatic variables and to the formal parameters of a function.\n\n<c>\nf(register unsigned m, register long n)\n{\nregister int i;\n...\n}\n</c>\n\nIt is not possible to take the address of a register variable.\n\n<h>\n*Static\n</h>\n\nThe static declaration, applied to an external variable or function, limits the scope of that object to the rest of the source file being compiled.\n\n<<a.c>>\n<c>\nstatic int a; // file scoped\nvoid function(){\nstatic int a; // function scoped\n}\n</c>\n\n\n<h>\n*Volatile\n</h>\n\nThe purpose of volatile is to force an implementation to suppress optimization that could otherwise occur. For example, for a machine with memory-mapped input/output,  a pointer to a device register might be declared as a pointer to volatile, in order to prevent the compiler from removing apparently redundant references through the pointer.\n\nExcept that it should diagnose explicit attempts to change const objects, a compiler  may ignore these qualifiers.\n\n<c>\nPort\n---------------------------------------------\n| control register |     |  data register   |\n---------------------------------------------\n\n\ntypedef short int control;\ntypedef short int data;\n#define ENABLE 0x40\n#define READY 0x80\ntypedef struct port port;\nstruct port\n{\ncontrol c;\ndata d;\n};\ntypedef struct ioport ioport;\nstruct ioport\n{\nport in, out;\n};\n\n//Using the declarations above, assign one memory mapped address to it\nioport *const pio = (ioport *)0xFF70;\n\n// check if control register ready bit is ready for data to be written\nwhile (pio->out.c & READY == 0)\n;\n\n//write carriage return\npio->out.d = \'\\r\';\nwhile (pio->out.c & READY == 0)\n;\npio->out.d = \'\\n\';\n\n//.Compiler start doing the optimization in following ways.\n//Optimization\n\nif (pio->out.c & READY == 0)\nfor (;;)\n;\npio->out.d = \'\\r\';\nif (pio->out.c & READY == 0)\nfor (;;)\n;\npio->out.d = \'\\n\';\nOptimization\nif (pio->out.c & READY == 0)\nfor (;;)\n;\npio->out.d = \'\\r\';\npio->out.d = \'\\n\';\n\n//Further Optimization where \'\\r\' is removed as redundant\nif (pio->out.c & READY == 0)\nfor (;;)\n;\npio->out.d = \'\\n\';\n\n\nSolution\nioport volatile *const pio\n= (ioport *)0xFFA0;\n\n</c>'
'9!ABS SBA!Misc!ABS SBA!Build binary with -g option\n set break point on a function enter\n inside function print pointer to struct fields!ABS SBA!<h>\n*Debugging with gdb\n</h>\n\nThe GNU Debugger (GDB) is used to stop through code, set breakpoints and examine the value of local variables.\n\nMakefile for simple main.c in order to have a binary.\n$ cat Makefile\n<c>\nCFLAGS=-g\nall: main.o\n        gcc $(CFLAGS) -o main main.o\nmain.o: main.c\n        gcc $(CFLAGS) -c main.c -o main.o\nclean:\n        rm -f main.o main\n</c>\n\n[sc@localhost ~]$ gdb main\n<c>\nGNU gdb Red Hat Linux (6.5-16.el5rh)\nCopyright (C) 2006 Free Software Foundation, Inc.\nGDB is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nType "show copying" to see the conditions.\nThere is absolutely no warranty for GDB.  Type "show warranty" for details.\nThis GDB was configured as "x86_64-redhat-linux-gnu"...Using host libthread_db library "/lib64/libthread_db.so.1".\n(gdb) break func\nBreakpoint 1 at 0x400484: file main.c, line 6.\n(gdb) run\nStarting program: /home/sc/main\nBreakpoint 1, func (si=0x7fff2dfdb6c0) at main.c:6\n6       si->i=10;\n(gdb) x /4xb 0x7fff2dfdb6c0\n0x7fff2dfdb6c0: 0x14    0x00    0x00    0x00\n(gdb) bt\n#0  func (si=0x7fff2dfdb6c0) at main.c:6\n#1  0x00000000004004c4 in main (argc=1, argv=0x7fff2dfdb7b8) at main.c:12\n(gdb) l\n1       #include <stdio.h>\n2       struct samples{\n3       int i;\n4       };\n5       void func(struct samples *si){\n6       si->i=10;\n7       printf("%d\n",si->i);\n8       }\n9       int main(int argc,char *argv[]){\n10      struct samples ss;\n\n(gdb) n\n7       printf("%d\n",si->i);\n(gdb) x /4xb 0x7fff2dfdb6c0\n0x7fff2dfdb6c0: 0x0a    0x00    0x00    0x00\n(gdb) p si->i\n$1 = 10\n</c>\n\n<h>\n*64 bit data i/o\n</h>\n\n<c>\nd - input of signed decimal integer\ni - input of a signed integer value\nu - input of an unsigned decimal\no - unsigned octal integer\nx - input of an unsigned hexadecimal\n\n#include <stdio.h>\n#include <inttypes.h>\nint main(){\nuint64_t uval=0x1234567890abcdef;\nint64_t n=0xff;\nprintf("%"PRIu64"\n", uval);\nprintf("%"PRId64"\n",n);\nreturn 0;\n}\n\n$ ./a.out\n1311768467294899695\n255\n\n</c>'
'31!ABS SBA!title!ABS SBA!None!ABS SBA!C Essentials Training'
'32!ABS SBA!subtitle!ABS SBA!None!ABS SBA!3-day session'
'33!ABS SBA!h_Overview!ABS SBA!None!ABS SBA!Understanding structural programming\nUnderstanding advance pointer and arrays\nPractical labs with GNU gcc compiler, gdb debugger'
'34!ABS SBA!h_Duration!ABS SBA!None!ABS SBA!Three days - 24 hours (8 hours a day)\n50% of lecture, 50% of practical labs.'
'35!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'36!ABS SBA!h_Trainer!ABS SBA!None!ABS SBA!<a href="https://www.linkedin.com/in/pravinkumarsinha">http://www.linkedin.com/in/pravinkumarsinha</a>'
'37!ABS SBA!h_Audience!ABS SBA!None!ABS SBA!Professional Software developers\nPeople supporting embedded and medium scale products.'
'38!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'39!ABS SBA!h_Setup!ABS SBA!None!ABS SBA!Linux machine with GNU gcc compiler installed.'
'40!ABS SBA!h2_Lecture!ABS SBA!None!ABS SBA!Lecture session will be course content presentation through the trainer.\nAny source code example related to the topic will be demonstrated, it would\ninclude executing the binaries.\nComplete lecture material can be downloaded from\n<a href="http://minhinc.42web.io/training/advance-c-slides.pdf">http://minhinc.42web.io/training/advance-c-slides.pdf</a>'
'41!ABS SBA!h2_Labs!ABS SBA!None!ABS SBA!Labs session would be completely hands on session where each example\n(with example data and execution instruction) would be provided to the\nstudents. Students can verify their results with the results provided in\nthe material.'
      city      
'0!ABS SBA!all!ABS SBA!11'
'0!ABS SBA!all!ABS SBA!28'
'0!ABS SBA!all!ABS SBA!45'
'0!ABS SBA!all!ABS SBA!102'
'0!ABS SBA!all!ABS SBA!104'
'0!ABS SBA!all!ABS SBA!105'
'0!ABS SBA!all!ABS SBA!106'
'0!ABS SBA!all!ABS SBA!107'
'0!ABS SBA!all!ABS SBA!112'
'0!ABS SBA!all!ABS SBA!115'
'0!ABS SBA!all!ABS SBA!116'
'0!ABS SBA!all!ABS SBA!203'
'0!ABS SBA!all!ABS SBA!213'
'0!ABS SBA!all!ABS SBA!301'
'0!ABS SBA!all!ABS SBA!304'
'0!ABS SBA!all!ABS SBA!305'
'0!ABS SBA!all!ABS SBA!308'
'0!ABS SBA!all!ABS SBA!311'
'0!ABS SBA!all!ABS SBA!313'
'0!ABS SBA!all!ABS SBA!314'
'0!ABS SBA!all!ABS SBA!316'
'0!ABS SBA!all!ABS SBA!317'
'0!ABS SBA!all!ABS SBA!319'
'0!ABS SBA!all!ABS SBA!320'
'0!ABS SBA!all!ABS SBA!321'
'0!ABS SBA!all!ABS SBA!324'
'0!ABS SBA!all!ABS SBA!336'
'0!ABS SBA!all!ABS SBA!337'
'0!ABS SBA!all!ABS SBA!338'
'0!ABS SBA!all!ABS SBA!339'
'0!ABS SBA!all!ABS SBA!341'
'0!ABS SBA!all!ABS SBA!346'
'0!ABS SBA!all!ABS SBA!348'
'0!ABS SBA!all!ABS SBA!350'
'0!ABS SBA!all!ABS SBA!351'
'0!ABS SBA!all!ABS SBA!416'
'0!ABS SBA!all!ABS SBA!425'
'0!ABS SBA!all!ABS SBA!438'
'0!ABS SBA!all!ABS SBA!446'
'0!ABS SBA!all!ABS SBA!455'
'0!ABS SBA!all!ABS SBA!510'
'0!ABS SBA!all!ABS SBA!513'
'0!ABS SBA!all!ABS SBA!517'
'0!ABS SBA!all!ABS SBA!518'
'0!ABS SBA!all!ABS SBA!548'
'0!ABS SBA!all!ABS SBA!1001'
'0!ABS SBA!bangalore!ABS SBA!513'
'0!ABS SBA!bucharesh!ABS SBA!340'
'0!ABS SBA!dublin!ABS SBA!323'
'0!ABS SBA!gurgaon!ABS SBA!513'
'0!ABS SBA!helsinki!ABS SBA!316'
'0!ABS SBA!indore!ABS SBA!513'
'0!ABS SBA!lucknow!ABS SBA!513'
'0!ABS SBA!mysore!ABS SBA!513'
'0!ABS SBA!noida!ABS SBA!513'
'0!ABS SBA!stockholm!ABS SBA!347'
      company      
      country      
'502!ABS SBA!afghanistan'
'401!ABS SBA!Africa'
'302!ABS SBA!albania'
'402!ABS SBA!algeria'
'202!ABS SBA!americanSamoa(USA)'
'303!ABS SBA!andorra'
'403!ABS SBA!angola'
'2!ABS SBA!anguilla(UK)'
'3!ABS SBA!antiguaAndBarbuda'
'102!ABS SBA!argentina'
'304!ABS SBA!armenia'
'4!ABS SBA!aruba(Netherlands)'
'501!ABS SBA!Asia'
'201!ABS SBA!Australia'
'203!ABS SBA!australia_'
'305!ABS SBA!austria'
'306!ABS SBA!azerbaijan'
'5!ABS SBA!bahamas'
'505!ABS SBA!bahrain'
'506!ABS SBA!bangladesh'
'6!ABS SBA!barbados'
'307!ABS SBA!belarus'
'308!ABS SBA!belgium'
'7!ABS SBA!belize'
'404!ABS SBA!benin'
'8!ABS SBA!bermuda(UK)'
'507!ABS SBA!bhutan'
'103!ABS SBA!bolivia'
'9!ABS SBA!bonaire(Netherlands)'
'309!ABS SBA!bosniaandHerzegovina'
'405!ABS SBA!botswana'
'104!ABS SBA!brazil'
'10!ABS SBA!britishVirginIslands(UK)'
'508!ABS SBA!brunei'
'310!ABS SBA!bulgaria'
'406!ABS SBA!burkinaFaso'
'407!ABS SBA!burundi'
'408!ABS SBA!caboVerde'
'509!ABS SBA!cambodia'
'409!ABS SBA!cameroon'
'11!ABS SBA!canada'
'12!ABS SBA!caymanIslands(UK)'
'410!ABS SBA!centralAfricanRepublic(CAR)'
'411!ABS SBA!chad'
'105!ABS SBA!chile'
'510!ABS SBA!china'
'13!ABS SBA!clippertonIsland(France)'
'106!ABS SBA!colombia'
'412!ABS SBA!comoros'
'204!ABS SBA!cookIslands(NewZealand)'
'14!ABS SBA!costaRica'
"413!ABS SBA!coted'Ivoire"
'311!ABS SBA!croatia'
'15!ABS SBA!cuba'
'16!ABS SBA!curacao(Netherlands)'
'312!ABS SBA!cyprus'
'313!ABS SBA!czechRepublic'
'414!ABS SBA!democraticRepublicoftheCongo'
'314!ABS SBA!denmark'
'415!ABS SBA!djibouti'
'17!ABS SBA!dominica'
'18!ABS SBA!dominicanRepublic'
'107!ABS SBA!ecuador'
'416!ABS SBA!egypt'
'19!ABS SBA!elSalvador'
'417!ABS SBA!equatorialGuinea'
'418!ABS SBA!eritrea'
'315!ABS SBA!estonia'
'419!ABS SBA!ethiopia'
'301!ABS SBA!Europe'
'108!ABS SBA!falklandIslands(UK)'
'205!ABS SBA!fiji'
'316!ABS SBA!finland'
'317!ABS SBA!france'
'109!ABS SBA!frenchGuiana(France)'
'206!ABS SBA!frenchPolynesia(France)'
'420!ABS SBA!gabon'
'421!ABS SBA!gambia'
'318!ABS SBA!georgia'
'319!ABS SBA!germany'
'422!ABS SBA!ghana'
'320!ABS SBA!greece'
'20!ABS SBA!greenland(Denmark)'
'21!ABS SBA!grenada'
'22!ABS SBA!guadeloupe(France)'
'207!ABS SBA!guam(USA)'
'23!ABS SBA!guatemala'
'423!ABS SBA!guinea'
'424!ABS SBA!guinea-Bissau'
'110!ABS SBA!guyana'
'24!ABS SBA!haiti'
'25!ABS SBA!honduras'
'321!ABS SBA!hungary'
'322!ABS SBA!iceland'
'513!ABS SBA!india'
'514!ABS SBA!indonesia'
'515!ABS SBA!iran'
'516!ABS SBA!iraq'
'323!ABS SBA!ireland'
'517!ABS SBA!israel'
'324!ABS SBA!italy'
'26!ABS SBA!jamaica'
'518!ABS SBA!japan'
'519!ABS SBA!jordan'
'325!ABS SBA!kazakhstan'
'425!ABS SBA!kenya'
'208!ABS SBA!kiribati'
'326!ABS SBA!kosovo'
'521!ABS SBA!kuwait'
'522!ABS SBA!kyrgyzstan'
'523!ABS SBA!laos'
'327!ABS SBA!latvia'
'524!ABS SBA!lebanon'
'426!ABS SBA!lesotho'
'427!ABS SBA!liberia'
'428!ABS SBA!libya'
'328!ABS SBA!liechtenstein'
'329!ABS SBA!lithuania'
'330!ABS SBA!luxembourg'
'331!ABS SBA!macedonia(FYROM)'
'429!ABS SBA!madagascar'
'430!ABS SBA!malawi'
'525!ABS SBA!malaysia'
'526!ABS SBA!maldives'
'431!ABS SBA!mali'
'332!ABS SBA!malta'
'209!ABS SBA!marshallIslands'
'27!ABS SBA!martinique(France)'
'432!ABS SBA!mauritania'
'433!ABS SBA!mauritius'
'28!ABS SBA!mexico'
'210!ABS SBA!micronesia'
'333!ABS SBA!moldova'
'334!ABS SBA!monaco'
'527!ABS SBA!mongolia'
'335!ABS SBA!montenegro'
'29!ABS SBA!montserrat(UK)'
'434!ABS SBA!morocco'
'435!ABS SBA!mozambique'
'528!ABS SBA!myanmar(Burma)'
'436!ABS SBA!namibia'
'211!ABS SBA!nauru'
'30!ABS SBA!navassaIsland(USA)'
'529!ABS SBA!nepal'
'336!ABS SBA!netherlands'
'212!ABS SBA!newCaledonia(France)'
'213!ABS SBA!newZealand'
'31!ABS SBA!nicaragua'
'437!ABS SBA!niger'
'438!ABS SBA!nigeria'
'214!ABS SBA!niue(NewZealand)'
'215!ABS SBA!norfolkIsland(Australia)'
'1!ABS SBA!NorthAmerica'
'216!ABS SBA!northernMarianaIslands(USA)'
'530!ABS SBA!northKorea'
'337!ABS SBA!norway'
'531!ABS SBA!oman'
'532!ABS SBA!pakistan'
'217!ABS SBA!palau'
'533!ABS SBA!palestine'
'32!ABS SBA!panama'
'218!ABS SBA!papuaNewGuinea'
'111!ABS SBA!paraguay'
'112!ABS SBA!peru'
'534!ABS SBA!philippines'
'219!ABS SBA!pitcairnIslands(UK)'
'338!ABS SBA!poland'
'339!ABS SBA!portugal'
'33!ABS SBA!puertoRico(USA)'
'535!ABS SBA!qatar'
'439!ABS SBA!republicoftheCongo'
'340!ABS SBA!romania'
'341!ABS SBA!russia'
'440!ABS SBA!rwanda'
'34!ABS SBA!saba(Netherlands)'
'35!ABS SBA!saintBarthelemy(France)'
'36!ABS SBA!saintKittsandNevis'
'37!ABS SBA!saintLucia'
'38!ABS SBA!saintMartin(France)'
'39!ABS SBA!saintPierreandMiquelon(France)'
'40!ABS SBA!saintVincentandTheGrenadines'
'220!ABS SBA!samoa'
'342!ABS SBA!sanMarino'
'441!ABS SBA!saoTomeandPrincipe'
'537!ABS SBA!saudiArabia'
'442!ABS SBA!senegal'
'343!ABS SBA!serbia'
'443!ABS SBA!seychelles'
'444!ABS SBA!sierraLeone'
'538!ABS SBA!singapore'
'41!ABS SBA!sintEustatius(Netherlands)'
'42!ABS SBA!sintMaarten(Netherlands)'
'344!ABS SBA!slovakia'
'345!ABS SBA!slovenia'
'221!ABS SBA!solomonIslands'
'445!ABS SBA!somalia'
'446!ABS SBA!southAfrica'
'101!ABS SBA!SouthAmerica'
'113!ABS SBA!southGeorgiaAndTheSouthSandwichIslands(UK)'
'539!ABS SBA!southKorea'
'447!ABS SBA!southSudan'
'346!ABS SBA!spain'
'540!ABS SBA!sriLanka'
'448!ABS SBA!sudan'
'114!ABS SBA!suriname'
'449!ABS SBA!swaziland'
'347!ABS SBA!sweden'
'348!ABS SBA!switzerland'
'541!ABS SBA!syria'
'542!ABS SBA!taiwan'
'543!ABS SBA!tajikistan'
'450!ABS SBA!tanzania'
'544!ABS SBA!thailand'
'545!ABS SBA!timor-Leste'
'451!ABS SBA!togo'
'222!ABS SBA!tokelau(NewZealand)'
'223!ABS SBA!tonga'
'43!ABS SBA!trinidadAndTobago'
'452!ABS SBA!tunisia'
'349!ABS SBA!turkey'
'547!ABS SBA!turkmenistan'
'44!ABS SBA!turksAndCaicosIslands(UK)'
'224!ABS SBA!tuvalu'
'453!ABS SBA!uganda'
'350!ABS SBA!ukraine'
'548!ABS SBA!unitedArabEmirates(UAE)'
'351!ABS SBA!unitedKingdom(UK)'
'45!ABS SBA!unitedStatesOfAmerica(USA)'
'115!ABS SBA!uruguay'
'46!ABS SBA!uSVirginIslands(USA)'
'549!ABS SBA!uzbekistan'
'225!ABS SBA!vanuatu'
'352!ABS SBA!vaticanCity(HolySee)'
'116!ABS SBA!venezuela'
'550!ABS SBA!vietnam'
'226!ABS SBA!wakeIsland(USA)'
'227!ABS SBA!wallisandFutuna(France)'
'1001!ABS SBA!WorldWide'
'551!ABS SBA!yemen'
'454!ABS SBA!zambia'
'455!ABS SBA!zimbabwe'
      cpp      
'1!ABS SBA!Introduction!ABS SBA!*Write a cpp file and make static and\n shared library. Call library in main.!ABS SBA!<h>\n*Source File\n</h>\n\n<c>\n\n             Stages of Program Development    |\n                                              |\n                                              v\n                                   ----------------------\n                                   | Architecture design|\n                                   ----------------------\n                                              |\n                                              v\n                                   ----------------------\n            ---------------------->| Detailed design    |\n            |                      ----------------------\n            |                                 |\n    -------------------                       v\n    |  Redefine design|             ---------------------\n    -------------------      ------>| Edit source files |\n            ^                |      ---------------------\n            |                |                |\n            |                |                v\n            |                |      ----------------------\n            |                |      | Compile source file|\n            |                |      ----------------------\n            |                |                |\n            |                |                v\n            |                |       --------------------\n            |                |       | Link Object files|\n            |                |       --------------------\n            |                |                |\n            |                |                v\n            |                |       ---------------------\n            |                |       | Test and debug    |\n            |                |       | executable program|\n            |                |       ---------------------\n            |                |                |\n            +---------------------------------+\n</c>\n<b>Architecture of c program</b>\nFunction consists of header and body\n - Header contains preprocessor statements and class declarations (except template inclusion case where source is also included)\n - Body, enclosed in {brackets} contains statements, each terminated by semicolon\n\nOne function must be one called main()\n - C start up code calls main function as the entry point in the program.\n\nGlobal variables are initialized prior the entry to main function.\n\nProgram execution starts in main, and progresses, statement by statement, until the last statement in main is completed\n\nDefinition of variable class and functions put in source file.\nA source file contains definition of variable and functions.\n\n<<source.c>>\n<c>\nextern int i; // declaration\nint func(); // declaration\nint i=10;//declaration and definition\nint func(){//definition\n}\n</c>\n\nCompiling one source file needs only declarations of the variable and the function be visible. Definition is not required while generating object file.\n\n<c>\n$ cat source.c\n#include <stdio.h>\n\nint func();\nint main(){\nfunc();\nreturn 0;\n}\n$ g++ -c source.c -o source.o <-- compiling without definition\n$ nm source.o\n                 U _Z4funcv <--- U is undefined\n                 U __gxx_personality_v0\n0000000000000000 T main\n</c>\n\n<h>\n*Header file\n</h>\n\nHeader contains constants, macros, system wide global variables, preprocessor\nstatements and declarations.\n\nHeader file is included with #include\nexample\n\n<c>\n$ cat header.h\n#ifndef HEADER_H\n#define HEADER_H\n#include <stdio.h>\nconst int i=10;\nextern int j;\nstruct A{\n};\nvoid put_s(const char*);\n#endif\n\n$cat source1.c\n#include "header.h"\nvoid put_s(const char *cp){\nprintf("puts %s\n",cp);\n}\n\n$cat source2.c\n#include "header.h"\nint j=15;\n\n$cat main.c\n#include "header.h"\nint main(int argc, char *argv[]){\nputs("hello world");\nprintf("j %d\n",j);\nreturn 0;\n}\n\n$ g++ source1.c source2.c main.c -o headersource\n$ ./headersource\nhello world\nj 15\n</c>\n\n<h>\n*Object File\n</h>\n\nA file that contains compiled code is known as an object file. Compiler creates object file which is binary file.  It is of three types\n\na) Relocatable file\nThis type of object file contains data and code that can be linked together with other relocatable files to produce an executable binary or a shared object file. It is similar as the .o file produced when we compile a code the following way :\n\n<c>\n$gcc -Wall -c test.c -o test.o\n</c>\nSo the test.o produced after the operation above would be a relocatable file.\n\n<c>\n$ nm mathoperation.o\n\n0000000000000000 T add\n0000000000000027 T div\n                 U fixit <-- Undefined\n0000000000000014 T mul\n\n$ objdump -x mathoperation.o\n</c>\n\n<cc>\nmathoperation.o:     file format elf64-x86-64\nmathoperation.o\narchitecture: i386:x86-64, flags 0x00000011:\nHAS_RELOC, HAS_SYMS\nstart address 0x0000000000000000\n\nSections:\nIdx Name          Size      VMA               LMA               File off  Algn\n  0 .text         0000005a  0000000000000000  0000000000000000  00000040  2**2\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE\n  1 .data         00000000  0000000000000000  0000000000000000  0000009c  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  2 .bss          00000000  0000000000000000  0000000000000000  0000009c  2**2\n                  ALLOC\n  3 .comment      0000002e  0000000000000000  0000000000000000  0000009c  2**0\n                  CONTENTS, READONLY\n  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000ca  2**0\n                  CONTENTS, READONLY\n  5 .eh_frame     00000078  0000000000000000  0000000000000000  000000d0  2**3\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA\nSYMBOL TABLE:\n0000000000000000 l    df *ABS*\t0000000000000000 mathoperation.c\n0000000000000000 l    d  .text\t0000000000000000 .text\n0000000000000000 l    d  .data\t0000000000000000 .data\n0000000000000000 l    d  .bss\t0000000000000000 .bss\n0000000000000000 l    d  .note.GNU-stack\t0000000000000000 .note.GNU-stack\n0000000000000000 l    d  .eh_frame\t0000000000000000 .eh_frame\n0000000000000000 l    d  .comment\t0000000000000000 .comment\n0000000000000000 g     F .text\t0000000000000014 add\n0000000000000014 g     F .text\t0000000000000013 mul\n0000000000000027 g     F .text\t0000000000000033 div\n0000000000000000         *UND*\t0000000000000000 fixit\n\nRELOCATION RECORDS FOR [.text]:\nOFFSET           TYPE              VALUE\n000000000000004d R_X86_64_PC32     fixit-0x0000000000000004\n\nRELOCATION RECORDS FOR [.eh_frame]:\nOFFSET           TYPE              VALUE\n0000000000000020 R_X86_64_PC32     .text\n0000000000000040 R_X86_64_PC32     .text+0x0000000000000014\n0000000000000060 R_X86_64_PC32     .text+0x0000000000000027\n</cc>\n\n<c>\n$ cat mathoperation.c\n\nvoid fixit(int,int);\nint add(int a,int b){\nreturn a+b;\n}\nint mul(int a,int b){\nreturn a*b;\n}\nint div(int a,int b){\nif (b=0)fixit(a,b);\nreturn a/b;\n}\n</c>\n\nb) Shared object file\nThis type of object file is used by the dynamic linker to combine it with the executable and/or other shared object. It is similar as the .so file produced when the code is compiled with the -fPIC (position independent code) flag in the following way :\n\n<c>\n$gcc -c -Wall -Werror -fPIC shared.c -o shared.o\n$gcc -shared -o libshared.so shared.o\n</c>\n\nA shared object file libshared.so is produced as output.\n\nexample.\n<c>\n$gcc -c -fPIC mathoperation.c -o mathoperation.o\n\n$ nm mathoperation.o\n0000000000000000 T add\n0000000000000027 T div\n                 U fixit\n                 U _GLOBAL_OFFSET_TABLE_ <- relocating table\n0000000000000014 T mul\n\n$ gcc -c -fPIC mathoperation.c -o mathoperation.o\n$ gcc -shared -o libmathoperation.so mathoperation.o\n$ ldd libmathoperation.so\n\n\tlinux-vdso.so.1 =>  (0x00007fffbd5fe000)\n\tlibc.so.6 => /lib64/libc.so.6 (0x00007ffd916b4000)\n\t/lib64/ld-linux-x86-64.so.2 (0x00007ffd91c8b000)\n\n$ nm libmathoperation.so\n</c>\n\n<cc>\n0000000000000708 T add\n0000000000201030 B __bss_start\n0000000000201030 b completed.6333\n                 w __cxa_finalize@@GLIBC_2.2.5\n0000000000000620 t deregister_tm_clones\n000000000000072f T div\n0000000000000690 t __do_global_dtors_aux\n0000000000200e00 t __do_global_dtors_aux_fini_array_entry\n0000000000200e10 d __dso_handle\n0000000000200e18 d _DYNAMIC\n0000000000201030 D _edata\n0000000000201038 B _end\n0000000000000764 T _fini\n                 U fixit<c>          <--------- Undefined</c>\n00000000000006d0 t frame_dummy\n0000000000200df8 t __frame_dummy_init_array_entry\n0000000000000840 r __FRAME_END__\n0000000000201000 d _GLOBAL_OFFSET_TABLE_\n                 w __gmon_start__\n00000000000005b8 T _init\n                 w _ITM_deregisterTMCloneTable\n                 w _ITM_registerTMCloneTable\n0000000000200e08 d __JCR_END__\n0000000000200e08 d __JCR_LIST__\n                 w _Jv_RegisterClasses\n000000000000071c T mul\n0000000000000650 t register_tm_clones\n0000000000201030 d __TMC_END__\n</cc>\n\n\nc) Executable file\nThis type of object file is a file that is capable of executing a program when run.\n\n<c>\n$ gcc -Wall test.c -o test\n</c>\nTool - objdump, nm\n\nExample -\n<<main.c>>\n<c>\n#include "sample.h"\nint main(int argc, char *argv[]){\nstruct fraction frtn;\nfrtn.numerator=12;\nfrtn.denominator=5;\nfunc(&frtn);\nreturn 0;\n}\n</c>\n\n<<sample.c>>\n<c>\n#include <stdio.h>\n#include "sample.h"\nvoid func(struct fraction *f){\nprintf("value %d\n",f->numerator/f->denominator);\n}\n</c>\n\n<<sample.h>>\n<c>\n#ifndef SAMPLE_H\n#define SAMPLE_H\nstruct fraction {\nint numerator;\nint denominator;\n};\nvoid func(struct fraction *f);\n#endif\n</c>\n\n$ objdump -r sample.o\n<c>\nsample.o:     file format pe-i386\n\nRELOCATION RECORDS FOR [.text]:\nOFFSET   TYPE              VALUE\n0000001b dir32             .rdata\n00000020 DISP32            _printf\n\n\nRELOCATION RECORDS FOR [.eh_frame]:\nOFFSET   TYPE              VALUE\n00000020 DISP32            .text\n</c>\n\n\n$ nm sample.o\n<c>\n00000000 b .bss\n00000000 d .data\n00000000 r .eh_frame\n00000000 r .rdata\n00000000 r .rdata$zzz\n00000000 t .text\n00000000 T _func\n          U _printf\n</c>\n\n$ ldd a.out\n<c>\nlinux-vdso.so.1 =>  (0x00007fffffbfe000)\nlibc.so.6 => /lib64/libc.so.6 (0x00007f96f51ee000)\n/lib64/ld-linux-x86-64.so.2 (0x00007f96f55c3000)\n</c>\n\n<h>\n*Declaration and Definition\n</h>\n\nDeclaration - Asserts the existence of a variable, function or type defined elsewhere in the program. A variable may be declared by preceding its type with the keyword extern.\n\n<c>\nint a; // just declaration\nvoid func();//just declaration\n</c>\n\nc++\n<c>\nint a // declaration and definition\nextern a // declaration\n</c>\n\n- Declaration can be made multiple times.\n\nDefinition - Allocates storage for a variable of a specified type and  optionally initializes the variable.\n\n<c>\nint a=10; //declaration and definition\nvoid func(){// declaration and definition\n}\n</c>\n\n- Definition must be only once.\n- How are declarations written so that variables are properly declared during compilation?\n- How are declarations arranged so that all the pieces will be properly connected when the program is loaded?\n- How are declarations organized so there is only one copy?\n- How are external variables initialized?\n\n<h>\n*Pre-processing, Compiling, Linking, Loading and Running\n</h>\n\n<c>\n---------------  ---------------  --------------- ---------------\n|source file  |  | source file |  | source file | | source file |\n---------------  ---------------  ---------------  --------------\n      |                 |                |               |\n      v                 v                v               v\n---------------  ---------------  --------------- ---------------\n| object file |  | object file |  | object file |  | object file|\n---------------  ---------------  ---------------  --------------\n      |                 |               |               |\n      |                 |               |               |\n      |                 |               |               |\n      |                 |               |               |\n      |                 v    +----------+               |\n      |                . . . v                          |\n      |              .       .<-------------------------+\n      +------------->. link  .  <------------     +--------+\n                       . . .                |     | Runtime|\n                         |                  +-----| Library|\n                         v                        +--------+\n                  ---------------\n                  | Executable  |\n                  |    Code     |\n                  ---------------\n</c>\n\nPreprocessor - It is a program that runs as part of compilation of a c program.  It is not part of compiler. In simplistic terms, a C Preprocessor is just a text substitution tool and they instruct compiler to do required preprocessing before actual compilation.\nAll preprocessor commands begin with a pound symbol (#). It must be the first non blank character, and for readability, a preprocessor directive should begin in first column. Following section lists down all important preprocessor directives:\n\n<c>\nDirective              Description\n#define                Substitutes a preprocessor macro\n#include               Inserts a particular header from another file\n#undef                 Undefines a preprocessor macro\n#ifdef                 Returns true if this macro is defined\n#ifndef                Returns true if this macro is not defined\n#if                    Tests if a compile time condition is true\n#else                  The alternative for #if\n#elif                   #else an #if in one statement\n#endif                 Ends preprocessor conditional\n#error                 Prints error message on stderr\n#pragma                Issues special commands to the compiler, using\n</c>\n\n\nTool - cpp\n\n$ cat test.h\n<c>\n#ifndef TEST_H\n#define TEST_H\nint func():\n#endif\n$ cat test.cpp\n#include "test.h"\nint main(){\nreturn 0;\n}\n</c>\n\n$ cpp test.cpp\n<c>\n# 1 "test.cpp"\n# 1 "<command-line>"\n# 1 "/usr/include/stdc-predef.h" 1 3 4\n# 1 "<command-line>" 2\n# 1 "test.cpp"\n# 1 "test.h" 1\n\nint func():\n# 2 "test.cpp" 2\nint main(){\nreturn 0;\n}\n</c>\n\nCompiling Source Files\nOnce your program is written in C, it is ready to be translated into a  machine-readable language.\nA compiler translates C statements into machine statements\n- A compiler creates object code, which is an intermediary step between source code and final executable code\n- The compiler checks for syntax errors; e.g., Missing punctuation\n- The compiler performs simple optimization on your code; e.g., eliminate a redundant statement\n\nTool - gcc\n\nLinking Object Files\n- The linker links together all object modules to form an executable image of the program\n- The output of the linker is an executable image, which can be loaded into memory and executed\n- The linker resolves any references to library functions\n - If your program uses a library routine, like sqrt, the linker finds the object code corresponding to this routine and links it within the final executable image\n- The linker is automatically invoked by the compiler\n\nLoading Your Program\nThe loader loads your program into the computer\'s memory\nOn most systems, this is performed automatically by the operating system\nwhen you run the program\nMost embedded systems require you to explicitly run a loader program\nto get the program into memory\n\nTool - gcc\n\n<h>\n*Executable File Format\n</h>\n\nExecutable file format which once loaded by a suitable executable loader, can be directly Executed by the CPU rather than become interpreted by software.\nIn addition to the binary application code, the executable may contain headers and tales with relocation and fix up information as well as various kinds of meta data.\nELF(Executable and Linkable File Format) - unix/linux\nCOFF(Command Object File Format) - windows\nPE - windows\nMZ - DOS\nMach-O (mac OS and iOS)\n\nELF Header\n\n<cc>\n#define EI_NIDENT 16\ntypedef struct {\ne_ident[EI_NIDENT];\nunsigned char e_type;\nElf32_Half e_machine;\nElf32_Half e_version;\nElf32_Word e_entry;\nElf32_Addr e_phoff;\nElf32_Off e_shoff;\nElf32_Off e_flags;\nElf32_Word e_ehsize;\nElf32_Half e_phentsize;\nElf32_Half e_phnum;\nElf32_Half e_shentsize;\nElf32_Half e_shnum;\nElf32_Half e_shstrndx;\n} Elf32_Ehdr;\n\n 1. e_ident\n In order to support all this the initial information in ELF file contains information\n on how to interpret the file independent of the processor on which the executable is running.\n Name     Value      Purpose\n EI_MAG     0          File identification\n EI_MAG1    1          File identification\n EI_MAG2    2          File identification\n EI_MAG3    3          File identification\n EI_CLASS   4          File class\n EI_DATA    5          Data encoding\n EI_VERSION 6          File version\n EI_PAD     7          Start of padding bytes\n EI_NIDENT  16         Size of e_ident[]\n\n    EI_MAG The first four bytes above hold the magic number 0x7fELF\n    EI_CLASS An ELF can have two classes, 32 bit or 64 bit. This makes the file format portable.\n    EI_DATA This member gives the information on data encoding, big endian or little endian format.\n    EI_VERSION This member provides information on object file version.\n    EI_PAD This member marks the start of unused bytes in the e_indent array of information.\n    EI_NIDENT This member provides the size of array e_indent. This helps in parsing the ELF file.\n\n 2. e_type\n This member identifies the type of object file. For example, an object file can be of\n  following types :\n Name    Value    Meaning\n ET_NONE  0       No file type\n ET_REL   1       Relocatable file\n ET_EXEC  2       Executable file\n ET_DYN   3       Shared object file\n ET_CORE  4       Core file\n NOTE: The above list is not exhaustive but still gives information on main object\n  file types that ELF can refer to.\n\n 3. e_machine\n This member gives information on architecture that an ELF file requires.\n Name            Value      Meaning\n ET_NONE           0          No machine\n EM_M32            1          AT&T WE 32100\n EM_SPARC          2          SPARC\n EM_386            3          Intel Architecture\n EM_68K            4          Motorola 68000\n EM_88K            5          Motorola 88000\n EM_860            7          Intel 80860\n EM_MIPS           8          MIPS RS3000 Big-Endian\n EM_MIPS_RS4_BE   10          MIPS RS4000 Big-Endian\n RESERVED       11-16         Reserved for future use\n\n 4. Additional Members\n Apart from the above three members, it also has the following members:\n e_version: Provides the ELF object file version information.\n e_entry: Provides the virtual address information of the entry point to which\n  the system must transfer the control so that the process can be initiated.\n e_phoff: Holds the offset to program header table. This information is stored in\n  terms of bytes. In absence of a program header table, the information\n  contained by this member is zero.\n e_shoff: Holds the offset to section header table. As with e_phoff, this\n  information too is stored in form of bytes and in absence of a section\n  header table, the information contained by this field is zero.\n e_flags: Holds information related to process specific flags.\n e_ehsize: Holds information related to ELF header size in byes.\n e_phentsize: Holds information related to size of one entry in the object\n  file\'s program header table. Note that all the entries are same in size.\n e_phnum: Holds the information related to number of entries in program header table.\n e_shentsize: Holds the information related to size of one entry in the\n  section header table. The size is represented in form of number of bytes.\n e_shnum: Gives the information related to the number of entries in the section header table.\n</cc>\n\nTool - readelf used to list the object data\n<c>\nmain() {\n  printf("Hello World\n");\n}\n</c>\n\n$ readelf -h hello.o\n\n<cc>\nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF64\n  Data:                              2\'s complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              REL (Relocatable file)\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x0\n  Start of program headers:          0 (bytes into file)\n  Start of section headers:          312 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           0 (bytes)\n  Number of program headers:         0\n  Size of section headers:           64 (bytes)\n  Number of section headers:         13\n  Section header string table index: 10\n</cc>\n\n\n$ readelf -S hello.o\n\n<cc>\nThere are 13 section headers, starting at offset 0x138:\nSection Headers:\n  [Nr] Name              Type             Address           Offset\n       Size              EntSize          Flags  Link  Info  Align\n  [ 0]                   NULL             0000000000000000  00000000\n       0000000000000000  0000000000000000           0     0     0\n  [ 1] .text             PROGBITS         0000000000000000  00000040\n       0000000000000015  0000000000000000  AX       0     0     4\n  [ 2] .rela.text        RELA             0000000000000000  00000598\n       0000000000000030  0000000000000018          11     1     8\n  [ 3] .data             PROGBITS         0000000000000000  00000058\n       0000000000000000  0000000000000000  WA       0     0     4\n  [ 4] .bss              NOBITS           0000000000000000  00000058\n       0000000000000000  0000000000000000  WA       0     0     4\n  [ 5] .rodata           PROGBITS         0000000000000000  00000058\n       000000000000000c  0000000000000000   A       0     0     1\n  [ 6] .comment          PROGBITS         0000000000000000  00000064\n       000000000000002e  0000000000000001  MS       0     0     1\n  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  00000092\n       0000000000000000  0000000000000000           0     0     1\n  [ 8] .eh_frame         PROGBITS         0000000000000000  00000098\n       0000000000000038  0000000000000000   A       0     0     8\n  [ 9] .rela.eh_frame    RELA             0000000000000000  000005c8\n       0000000000000018  0000000000000018          11     8     8\n  [10] .shstrtab         STRTAB           0000000000000000  000000d0\n       0000000000000061  0000000000000000           0     0     1\n  [11] .symtab           SYMTAB           0000000000000000  00000478\n       0000000000000108  0000000000000018          12     9     8\n  [12] .strtab           STRTAB           0000000000000000  00000580\n       0000000000000013  0000000000000000           0     0     1\n</cc>\nThe readelf program is capable of performing disassembly:\n\n$ readelf -i 1 hello.o\n\n<cc>\n0x00000000  pushl       %ebp\n0x00000001  movl        %esp,%ebp\n0x00000003  pushl       $0x0\n0x00000008  call        0x08007559\n0x0000000d  addl        $4,%esp\n0x00000010  movl        %ebp,%esp\n0x00000012  popl        %ebp\n0x00000013  ret\n</cc>\n\nThe .rel.text section contains the re-locations for the .text section of\nthe file, and we can display them as follows:\n\n$ readelf -r hello.o\n\n<c>\nRelocation section data:.rel.text (0x2 entries)\nTag: 00004 Value 00301 R_386_32    (0 )\nTag: 00009 Value 00b02 R_386_PC32  (0 printf)\n</c>\n\n$ readelf -l hello\n\n<cc>\nElf file type is EXEC (Executable file)\nEntry point 0x400440\nThere are 9 program headers, starting at offset 64\n\nProgram Headers:\n  Type           Offset             VirtAddr           PhysAddr\n                 FileSiz            MemSiz              Flags  Align\n  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040\n                 0x00000000000001f8 0x00000000000001f8  R E    8\n  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238\n                 0x000000000000001c 0x000000000000001c  R      1\n      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]\n  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000\n                 0x0000000000000714 0x0000000000000714  R E    200000\n  LOAD           0x0000000000000e10 0x0000000000600e10 0x0000000000600e10\n                 0x0000000000000224 0x0000000000000228  RW     200000\n  DYNAMIC        0x0000000000000e28 0x0000000000600e28 0x0000000000600e28\n                 0x00000000000001d0 0x00000000000001d0  RW     8\n  NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254\n                 0x0000000000000044 0x0000000000000044  R      4\n  GNU_EH_FRAME   0x00000000000005ec 0x00000000004005ec 0x00000000004005ec\n                 0x0000000000000034 0x0000000000000034  R      4\n  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000\n                 0x0000000000000000 0x0000000000000000  RW     10\n  GNU_RELRO      0x0000000000000e10 0x0000000000600e10 0x0000000000600e10\n                 0x00000000000001f0 0x00000000000001f0  R      1\n\nSection to Segment mapping:\nSegment Sections...\n   00\n   01     .interp\n   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame\n   03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss\n   04     .dynamic\n   05     .note.ABI-tag .note.gnu.build-id\n   06     .eh_frame_hdr\n   07\n   08     .init_array .fini_array .jcr .dynamic .got\n</cc>\n\n<h>\n* Segments (.bss, .code, .data etc)\n</h>\n\nUnix/Linux process virtual address space\n\n<c>\nhigh address -----------------------------\n             |                           |    command line arguments\n             |                           |  /  and environment\n             -----------------------------\n             |           stack           |\n             - - - - - - - - - - - - - - -\n             |             |             |\n             |             |             |\n             |             v             |\n             |                           |\n             |                           |\n             |                           |\n             |             ^             |\n             |             |             |\n             |             |             |\n             - - - - - - - - - - - - - - -\n             |           heap            |\n             -----------------------------\n             | uninitialized data        |  initialized to\n             |          (bss)            | / zero by exec\n             ----------------------------+\n             | initialized data          |   read from\n             -----------------------------   | program line\n             |            text           |  / by exec\nlow address  |                           | /\n             +---------------------------+\n</c>\n\nWhen an executable program is read into system memory by the kernel and executed, it becomes a process. We can consider system memory to be divided into two distinct regions.\n\nOne is user space, and the other is kernel Space. Every process has is own user space (about 2GB virtual space,32bit) and are prevented from interfering with one another. The mode change which is from user mode to kernel mode is called a context switch.\n\n<c>\n         -----------------\n         |  Kernel Space |<----+\n         |               |     |\n         +---------------+     | context switching\n         |               |     |\n         | User Space    |<----+\n         +---------------+\n</c>\n\nText, Data and Stack.\nThe user process is divided into three segments or regions, they are: text, data and stack.\n\nText Segment.\nThe Text segment (a.k.a the Instruction segment) contains the executable program code and constant data. The text segment is marked by the operating system as read- only and can not be modified by the process.  Multiple processes can share the same text segment. Processes share the text segment if a second copy of the program is to be executed concurrently. Sharing can be turned off by using the -N option on the compile time.\n\nData Segment.\nThe data segment, which is contiguous (in a virtual sense) with the text segment, can be subdivided into initialized data (e.g. in C/C++, variables that are declared as static or are static by virtual of their placement) and uninitialized (or 0-initialized data. The uninitialized data area is also called BSS (Block Started By Symbol).\n\nHeap Segment\nDuring its execution lifetime, a process may request additional data segment space. Library memory allocation routines (e.g., new, malloc, calloc, etc.) in turn make use of the system calls brk and sbrk to extend the size of the data segment. The newly allocated space is added to the end of the current uninitialized data area. This area of available memory is also called "heap".\n\nStack Segment.\nThe stack segment is used by the process for the storage of automatic identifier, register variables, and function call information. The stack grows towards the uninitialized data segment.\n\nThe u area.\nIn addition to the text, data, and stack segment, the OS also maintains for each process a region called the u area (User Area). The u area contains information specific to the process (e.g. open files, current directory, signal action, accounting information) and a system stack segment for process use.  If the process makes a system call (e.g., the system call to write in the function in main ), the stack frame information for the system is stored in the system stack segment. Again, this information is kept by the OS in an area that the process doesn\'t normally have access to. Thus, if this information is needed, the process must use special system call to access it.  Like the process itself, the contents of the u area for the process are paged in and out bye the OS.\n\nProcess Memory Addresses.\nThe system keeps track of the virtual addresses associated with each user process segment. This addresses information is available to the process and can be obtained by referencing the external variables etext, edata, and end. The addresses (not the contents) of these three variable correspond respectively to the first valid address above the text, initialized data, and uninitialized data segments.\n\n<c>\n#include <iostream>\nextern int etext, edata, end;\nusing namespace std;\nint main( ){\ncout << "Adr etext: " << hex << &etext << "\t ";\ncout << "Adr edata: " << hex << &edata << "\t ";\ncout << "Adr end: " << hex << &end << "\n";\n\nchar *s1 = "hello"; //in initialized data segmenta\nstatic int a=1; //in initialized data segment\nstatic int b; //in uninitialized data segment\nchar s2[] = "hello"; //in the stack area.\nint * c = new int;\n\ncout <<hex << s1 << endl;\ncout <<hex << &a << endl;\ncout <<hex << &b << endl;\ncout <<hex << s2 << endl;\ncout <<hex << c << endl;\ndelete c;\nreturn 0;\n}\n</c>\n\n$g++ add.cpp\n$./a.out\n<c>\nAdr etext: 0x400e4d     Adr edata: 0x602090     Adr end: 0x6021c0\nhello\n0x60208c\n0x6021b8\nhello\n0X23ce010\n</c>\n\n\n<h>\n*Creating static library\n</h>\n\nA static library is set of object files that were copied into a single file. The static file is created with the archiver (ar).\n\n<<calc_mean.c>>\n<c>\n//#include <stdio.h>\ndouble mean(double a, double b) {\nreturn (a+b) / 2;\n}\n</c>\n\n<<calc_mean.h>>\n<c>\ndouble mean(double, double);\n</c>\n\nCreating the static library\nFirst, calc_mean.c is turned into an object file:\n\n<c>\n$gcc -c calc_mean.c -o calc_mean.o\n</c>\n\nThen, the archiver (ar) is invoked to produce a static library (named libmean.a) out of the object file calc_mean.o.\n\n<c>\n$ar  rcs libmean.a      calc_mean.o\n</c>\n\nNote: the library must start with the three letters lib and have the suffix .a.\n\n$cat calc.c\n<c>\n#include <stdio.h>\n#include "calc_mean.h"\nint main(){\nprintf ("mean of 3, 6 is %f\n",mean(3,6));\nreturn 0;\n}\n</c>\n\n$ gcc -c calc_mean.c -o calc_mean.o\n$ ar cr libmean.a calc_mean.o\n$ gcc -c calc.c -o calc.o\n$ gcc -o calc calc.o -L. -lmean\n$ ./calc\n<c>\n\nmean of 3, 6 is 4.500000\n</c>\n\n$ gcc -o calc  -L. -lmean calc.o\n<c>\ncalc.o: In function \'main\':\ncalc.c:(.text+0x2f): undefined reference to \'mean\'\ncollect2: error: ld returned 1 exit status\n</c>\n\n$ nm libmean.a\n<c>\ncalc_mean.o:\n0000000000000000 T mean\n</c>\n\n<h>\n*Creating dynamic library\n</h>\n\nShared library (also known as a shared object, or as a dynamically linked library) is similar to a archive in that it is a grouping of object files.  When a shared library is linked into a program, the final executable does not actually contain the code that is present in the shared library. Instead, the executable merely contains a reference to the shared library.\n\nThe program using the library\n<<main.c>>\n<c>\n#include <stdio.h>\n#include "calc_mean.h"\nint main(){\nprintf ("mean of 3, 6 is %f\n",mean(3,6));\nreturn 0;\n}\n</c>\n\n$ gcc -c -fPIC calc_mean.c -o calc_mean.o\n$ gcc -c calc.c -o calc.o\n$ gcc -shared -fPIC -o libmean.so calc_mean.o\n$ ldd libmean.so\n\n<c>\nlinux-vdso.so.1 =>  (0x00007fffadffe000)\nlibc.so.6 => /lib64/libc.so.6 (0x00007f546f7ed000)\n/lib64/ld-linux-x86-64.so.2 (0x00007f546fdc4000)\n</c>\n\n$ gcc -o calc calc.o -L. -lmean\n$ ldd calc\n\n<c>\nlinux-vdso.so.1 =>  (0x00007fffa58de000)\nlibmean.so => not found\nlibc.so.6 => /lib64/libc.so.6 (0x00007f4e10d70000)\n/lib64/ld-linux-x86-64.so.2 (0x00007f4e11146000)\n</c>\n\n$ export LD_LIBRARY_PATH=.\n$ ./calc\n\nmean of 3, 6 is 4.500000\nIn order to avoid LD_LIBRARY_PATH programmer can add\n-Wl,rpath,<lib path> to the command link line\n\n$ pwd\n/home/sc\n\n$ echo $LD_LIBRARY_PATH\n\n$ rm calc\n$ gcc -o calc calc.o -L. -lmean -Wl,-rpath=/home/sc/\n$ ./calc\nmean of 3, 6 is 4.500000\n\n$ gcc -o calc calc.o -L. -lmean\n\n$ ./calc\n./calc: error while loading shared libraries: libmean.so: cannot open shared object file: No such file or directory\n\n<h>\n*Function calling convention\n</h>\n\nA calling convention describes how the arguments are passed and values returned by functions.\n\nIt also specifies how the function names are decorated.\n\n\n1) C calling convention (__cdecl)\n<c>\nint __cdecl sumExample (int a, int b);\n</c>\n\n- Arguments are passed from right to left, and placed on the stack.\n- Stack cleanup is performed by the caller.\n- Function name is decorated by prefixing it with an underscore character \'_\' .\n- The default calling convention for C and C++ programs. The advantage of this calling convention is that it allows functions with a variable number of arguments to be used. The disadvantage is that it creates larger executable.\n\n2) Standard calling convention (__stdcall)\n<c>\nint __stdcall sumExample (int a, int b);\n</c>\n\n- Arguments are passed from right to left, and placed on the stack.\n- Stack cleanup is performed by the called function.\n- Function name is decorated by prepending an underscore character and appending a \'@\' character and the number of bytes of stack space required.\n- It is used to call Win32 API functions. It does not allow functions to have a variable number of arguments.\n\n3) Fast calling convention (__fastcall)\n<c>\nint __fastcall sumExample (int a, int b);\n</c>\n\n- The first two function arguments that require 32 bits or less are placed into registers ECX and EDX. The rest of them are pushed on the stack from right to left.\n- Arguments are popped from the stack by the called function.\n- Function name is decorated by by prepending a \'@\' character and appending a \'@\' and the number of bytes (decimal) of space required by the arguments.\n- __fastcall attempts to put arguments in registers, rather than on the stack, thus making function calls faster.\n\n\n4) Thiscall\n- Arguments are passed from right to left, and placed on the stack. this is placed in ECX. Stack cleanup is performed by the called function.\n- Thiscall calling convention is the default calling convention used by C++ member functions that do not use variable arguments.\n\n<h>\n*Function naming convention\n</h>\n\nName mangling is changing function names to avoid name conflict. Used in function overloading.\n\n<c>\nvoid fun(int x) {\n    cout<<x<<endl;\n}\nvoid fun(float x) {\n    cout<<x<<endl;\n}\nint main() {\n    fun(10);\n    fun(10.5f);\n\n    return 0;\n}\n</c>\n\nMangled name for funtion void fun(int x) is <c>?fun@@YAXH@Z</c>\nMangled name for funtion void fun(float x) is <c>?fun@@YAXM@Z</c>\n\nTool - nm\n\n<c>\n#ifndef SAMPLE_H\n#define SAMPLE_H\n#include <iostream>\nusing namespace std;\nstruct fraction {\nint numerator;\nint denominator;\n};\nclass cfraction{\nint numerator;\nint denominator;\npublic:\ncfraction(int,int);\nvoid func();\n};\n#endif\n\n#include "sample.h"\ncfraction::cfraction(int n,int d){\nnumerator=n;\ndenominator=d;\n}\nvoid cfraction::func(){\ncout<<numerator/denominator;\n}\n</c>\n\n$ g++ -c sample.cpp -o sample.o\n\n$ nm sample.o\n<cc>\n00000000 b .bss\n00000000 d .ctors\n00000000 d .data\n00000000 r .eh_frame\n00000000 r .rdata$zzz\n00000000 t .text\n0000004b t ___tcf_0\n0000008a t __GLOBAL__sub_I__ZN9cfractionC2Eii\n0000005d t __Z41__static_initialization_and_destruction_0ii\n0000001e T __ZN9cfraction4funcEv\n00000000 T __ZN9cfractionC1Eii\n00000000 T __ZN9cfractionC2Eii\n         U __ZNSolsEi\n         U __ZNSt8ios_base4InitC1Ev\n         U __ZNSt8ios_base4InitD1Ev\n         U __ZSt4cout\n00000000 b __ZStL8__ioinit\n         U _atexit\n</cc>\n\n<h>\n*Function prototype\n</h>'
'2!ABS SBA!Functions!ABS SBA!*Write a function to accept multidimentional \narray as an argument!ABS SBA!<h>\n*Function calling convention\n</h>\n\nA calling convention describes how the arguments are passed and values returned by functions.\n\nIt also specifies how the function names are decorated.\n\n1) C calling convention (<c>__cdecl</c>)\n<c>\nint __cdecl sumExample (int a, int b);\n</c>\n\n- Arguments are passed from right to left, and placed on the stack.\n- Stack cleanup is performed by the caller.\n- Function name is decorated by prefixing it with an underscore character \'_\' .\n- The default calling convention for C and C++ programs. The advantage of this calling convention is that it allows functions with a variable number of arguments to be used. The disadvantage is that it creates larger executable.\n\n2) Standard calling convention (<c>__stdcall</c>)\n<c>\nint __stdcall sumExample (int a, int b);\n</c>\n\n- Arguments are passed from right to left, and placed on the stack.\n- Stack cleanup is performed by the called function.\n- Function name is decorated by prepending an underscore character and appending a \'@\' character and the number of bytes of stack space required.\n- It is used to call Win32 API functions. It does not allow functions to have a variable number of arguments.\n\n3) Fast calling convention (<c>__fastcall</c>)\n<c>\nint __fastcall sumExample (int a, int b);\n</c>\n\n- The first two function arguments that require 32 bits or less are placed into registers ECX and EDX. The rest of them are pushed on the stack from right to left.\n- Arguments are popped from the stack by the called function.\n- Function name is decorated by by prepending a \'@\' character and appending a \'@\' and the number of bytes (decimal) of space required by the arguments.\n- __fastcall attempts to put arguments in registers, rather than on the stack, thus making function calls faster.\n\n4) Thiscall\n- Arguments are passed from right to left, and placed on the stack. this is placed in ECX. Stack cleanup is performed by the called function.\n- Thiscall calling convention is the default calling convention used by C++ member functions that do not use variable arguments.\n\n<h>\n*Function naming convention\n</h>\n\nName mangling is changing function names to avoid name conflict. Used in function overloading.\n\n<c>\nvoid fun(int x) {\n    cout<<x<<endl;\n}\nvoid fun(float x) {\n    cout<<x<<endl;\n}\nint main() {\n    fun(10);\n    fun(10.5f);\n\n    return 0;\n}\n</c>\n\nMangled name for funtion void fun(int x) is <c>?fun@@YAXH@Z</c>\nMangled name for funtion void fun(float x) is <c>?fun@@YAXM@Z</c>\n\nTool - nm\n\n<c>\n#ifndef SAMPLE_H\n#define SAMPLE_H\n#include <iostream>\nusing namespace std;\nstruct fraction {\nint numerator;\nint denominator;\n};\nclass cfraction{\nint numerator;\nint denominator;\npublic:\ncfraction(int,int);\nvoid func();\n};\n#endif\n\n#include "sample.h"\ncfraction::cfraction(int n,int d){\nnumerator=n;\ndenominator=d;\n}\nvoid cfraction::func(){\ncout<<numerator/denominator;\n}\n</c>\n\n$ g++ -c sample.cpp -o sample.o\n\n$ nm sample.o\n<cc>\n00000000 b .bss\n00000000 d .ctors\n00000000 d .data\n00000000 r .eh_frame\n00000000 r .rdata$zzz\n00000000 t .text\n0000004b t ___tcf_0\n0000008a t __GLOBAL__sub_I__ZN9cfractionC2Eii\n0000005d t __Z41__static_initialization_and_destruction_0ii\n0000001e T __ZN9cfraction4funcEv\n00000000 T __ZN9cfractionC1Eii\n00000000 T __ZN9cfractionC2Eii\n         U __ZNSolsEi\n         U __ZNSt8ios_base4InitC1Ev\n         U __ZNSt8ios_base4InitD1Ev\n         U __ZSt4cout\n00000000 b __ZStL8__ioinit\n         U _atexit\n</cc>\n\n<h>\n*Function prototype\n</h>\n\nFunction prototype provide the interface between the programmer\nwho defines the function and programmers who use it.\n\ntype name ( argument1, argument2, ...) statement\n\n- type is the type of data returned by the function.\n- name is the name by which it will be possible to call the function.\n- arguments (as many as wanted can be specified).\n- statement is the function\'s body. It can be a single instruction or a\n- block of instructions.\nIn the later case it must be delimited by curly brackets {}.\n\nFunction prototype generally placed in header files.\n<<header.h>>\n<c>\nclass A{\nvoid func();\n};\n</c>\n\n<<source.cpp>>\n<c>\nA::func(){\n}\n</c>\n\n<h>\n*Function stack frame\n*Return\n</h>\n\nThe stack frame, also known as activation record is the collection of all data on the stack associated with one subprogram call.\nThe stack frame generally includes the following components:\n\n- The return address\n- Argument variables passed on the stack\n- Local variables (in HLLs)\n- Saved copies of any registers modified by the subprogram that need to be restored (e.g. $s0 - $s8 in MAL).\n\nAutomatic variables are therefore represented as an offset from the stack pointer, such as 4($sp) or 8($sp).\n\n<c>\nint     function(int a, double b)\n{\n int     x, y;\n ...\n return  x;\n}\n</c>\n\nPossible stack frame for function:\nAddress Content\n<c>\n$sp --> F080    Saved return address\n        F084    a\n        F088    b\n        F090    x\n        F094    y\n        F098    Saved register value\n        F09C    Saved register value\n</c>\n\nFunction can return object(value) or reference. Do not return reference or pointer to local variable, as function de-allocate stack once it returns.\nReturn type of overloaded function does not contribute to overloading.\n\n<h>\n*Inline functions\n</h>\n\n- If a function is inline, the compiler places a copy of the code of that function at each point where the function is called at compile time.\n- Any change to an inline function could require all clients of the function to be recompiled.\n- To inline a function, place the keyword inline before the function name and define the function before any calls are made to the function.\n- The compiler can ignore the inline qualifier in case defined function is more than a line.\n- An inline function does type check and it is not MACRO.\n\nAutomatic In-lining\n- A function definition in a class definition is an inline function definition, even without the use of the inline specifier.\n- Inline function definition must be in header files.\n\n<c>\n#include <iostream>\nusing namespace std;\ninline void func(){ // non class function inline\ncout<<"global inline func"<<endl;\n}\nclass classA {\npublic:\ninline const string& shorterstring(const string &s1, const string &s2); //inline\nvoid uppercase(const string& s);\n};\nconst string& classA::shorterstring(const string &s1, const string &s2){\nreturn s1.size() < s2.size() ? s1:s2;\n}\ninline void classA::uppercase(const string& s){\ns.toUpperCase();\n}\nint main() {\nclassA clsA;\ncout<<clsA.shorterstring("one","three")<<endl;\nfunc();\nreturn 0;\n}\n</c>\n\n<h>\n*Virtual function\n</h>\n\n- Virtual function can belong to a class where it supports polymorphism\n- Virtual function makes entry in vtable.\n<c>\nclass A{\nint a;\nvirtual void f(int);\n};\n\n----------\n| a:int  |\n---------- vtble    ----------\n| vptr   |--------->| &A::f()|\n----------          ----------\n\nstruct P {\nint p1;\nvirtual void pvf();\n};\nstruct S : P {\nint s1;\nvoid pvf(); // overrides P::pvf and R::pvf\nvoid rvf(); // overrides R::rvf\nvoid svf(); // new\n};\n\nP*, S*\n  -----> --------------      --------------\n         | P::vfptr  -|----->|  &S::pvf   |\n         --------------      --------------\n         | P::p1      |\n         --------------\n</c>\n\n- static function can not be virtual as this pointer is not the implicit first argument.\n\n<h>\n*Function overloading\n</h>\n\n- Multiple definitions for the same function name in the  same scope.  The definition of the function must differ from each other by the types and/or the number of arguments in the argument list.\n- Can not overload function declarations that differ only by return type.\n\n<c>\nvoid print(int i) {\ncout << "Printing int: " << i << endl;\n}\nvoid print(double f) {\ncout << "Printing float: " << f << endl;\n}\n//void print(long double l) {\n//cout<<"Printing long:"<<l<<endl;\n//}\nvoid print(char* c) {\ncout << "Printing character: " << c << endl;\n}\nint main(int argc, char *argv[]) {\nint i=10;\ndouble d=20.10;\nlong double ld=10.10001;\nchar *cp="ORACLE";\nprint(i);\nprint(d);\nprint(ld);\nprint(cp);\nreturn 0;\n}\n</c>\n\nOverloading and ambiguity\n- There can be ambiguity when exact matching type is not available and intermediate conversion is required where target type is more than one..\n- If both functions are available that is without the overloaded argument and with overloaded argument but with default values.\n\nIn order to overcome ambiguity look the following rule is followed\na) Select candidates. Same function name.\nb) Select viable function. Select function which has equal number of matching arguments.\nc) Select best match function. Function that require minimum conversion.\n\n<c>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid print(int i){cout<<"print int"<<endl;}\nvoid print(float f){cout<<"print float"<<endl;}\nvoid print(char c){cout<<"print char"<<endl;}\nvoid print(double d){cout<<"print double"<<endl;}\nvoid print(int *i){cout<<"print int*"<<endl;}\nclass complex{\npublic:\ncomplex(double){}\n};\n\nclass longdouble{\nfriend double operator+(longdouble&, int);\n//friend double operator+(longdouble&, double);\npublic:\nlongdouble(int){};\noperator double(){return 4.4;}\ndouble operator+(const complex&){\ncout<<"::operator+complex"<<endl;\n}\n};\ndouble operator+(longdouble& l, int i){\n//double operator+(longdouble& l, double i){\ncout<<"global operator+"<<endl;\n}\nint main(){\nlongdouble ld(16.08);\ndouble res=ld+15.05;\n//double res=ld+15;\nprint(10.4);\nreturn 0;\n}\n</c>\n\n$g++ main.cpp\n<c>\nmain.cpp: In function \'int main()\':\nmain.cpp:38: warning: passing \'double\' for argument 1 to \'longdouble::longdouble(int)\'\nmain.cpp:39: error: ISO C++ says that these are ambiguous, even though the worst conversion\n  for the first is better than the worst conversion for the second:\nmain.cpp:34: note: candidate 1: double operator+(longdouble&, int)\nmain.cpp:39: note: candidate 2: operator+(double, double) <built-in>\nmain.cpp:39: warning: passing \'double\' for argument 2 to \'double operator+(longdouble&, int)\'\n</c>\n\n<h>\n*Function default parameters\n</h>\n\n- When a function is defined, a default value can be specified for each of the last parameters.\n- This value will be used if the corresponding argument is left blank when calling to the function.\n- This is done by using the assignment operator and assigning values for  the arguments in the function definition. If a value for that parameter  is not passed when the function is called, the default given value is used, but if a value is specified, this default value is ignored and the passed value is used instead.\n\n<c>\n#include <iostream>\nusing namespace std;\nint sum(int a, int b=20) {\nint result;\nresult = a + b;\nreturn (result);\n}\n\nint sum(int a, int b){//error multiple definition\nReturn a+b;\n}\n\nint main () {\nint a = 100;\nint b = 200;\nint result;\nresult = sum(a, b);\ncout << "Total value is :" << result << endl;\nresult = sum(a);\ncout << "Total value is :" << result << endl;\nreturn 0;\n}\n</c>\n\n<h>\n*Pass by value, pass by reference\n</h>\n\nTwo way parameter to function can be passed\n- By value\n- By reference\n\nBy value\nValue is of the argument passed by callee the function is exactly copied in the caller parameter variable.\n\n<c>\nvoid swap(int *v1, int *v2){\nint tmp=*v2;\n*v2=*v1;\n*v1=tmp;\n}\nvoid swapptr(int **v1, int **v2){\nint *tmp=*v2;\n*v2=*v1;\n*v1=tmp;\n}\n\nBy reference\nvoid swap(int &v1,int &v2){\nint tmp=v2;\nv2=v1;\nv1=tmp;\n}\nvoid swapptr( int *&v1,int *&v2){\nint *tmp=v2;\nv2=v1;\nv1=tmp;\n}\n</c>\n\nArray Value\n<c>\nvoid printvalue(int arr[10]);\nvoid printvalue(int *arr);\nvoid printvalue(int arr[]);\n</c>\n\nReference\n<c>\nvoid printvalue(int (&arr)[10]);\nvoid printvalue(int (&arr)[10][10]);\n\n#include <iostream>\nusing namespace std;\n\nvoid printptrtoarray(int (*arr)[4]){\nint i=0,j=0;\nfor(i=0;i<4;i++){\nfor(j=0;j<4;j++)\ncout<<arr[i][j]<<" ";\ncout<<endl;\n}\n}\nvoid printarray(int (&arr)[4][4]){\nint i=0,j=0;\nfor (i=0;i<4;i++){\nfor (j=0;j<4;j++)\ncout<<arr[i][j]<<" ";\ncout<<endl;\n}\n}\nvoid preparearray(int (&arr)[4][4]){\nint i=0,j=0;\nfor (i=0;i<4;i++)\nfor (j=0;j<4;j++)\narr[i][j]=i;\n}\nint main(int argc,char *argv[]){\nint arr[4][4];\npreparearray(arr);\nprintarray(arr);\nprintptrtoarray(arr);\nreturn 0;\n}\n$ ./a.out\n0 0 0 0\n1 1 1 1\n2 2 2 2\n3 3 3 3\n0 0 0 0\n1 1 1 1\n2 2 2 2\n3 3 3 3\n</c>\n\n<h>\n*Unamed function parameter\n</h>\n\nUnnamed function parameters are used when a particular parameter is not required but it is in design.\n\n<c>\n                       A\n                 +------------+\n                 | func()=0;  |\n                 +------------+\n                       /\n                        -\n                        |\n    +----------------------------------+\n  B |                                C |\n+-------------+                 +--------------+\n|   func()    |                 |    func()    |\n+-------------+                 +--------------+\n\n\n#include <iostream>\nusing namespace std;\nstruct A{\nvirtual void func(int *)=0;\n};\nstruct B:A{\nvirtual void func(int *);\n};\nstruct C:A{\nvirtual void func(int*);\n};\nvoid B::func(int *){\ncout<<"A::func"<<endl;\n}\nvoid C::func(int *i){\ncout<<"B::func"<<*i<<endl;\n}\nvoid callfunc(A* a){\nint i=10;\na->func(&i);\n}\n\nint main(int argc, char *argv[]){\nB b;\nC c;\ncallfunc(&b);\ncallfunc(&c);\nreturn 0;\n}\n</c>\n$ ./a.out\n<c>\nA::func\nB::func10\n</c>\n\n<h>\n*Variable parameter list\n</h>\n\n<c>\n#include <stdarg.h> \ndouble average(int num,...) \n{ \nva_list valist; \ndouble sum = 0.0; \nint i; \n/* initialize valist for num number of arguments */ \nva_start(valist, num); \n\n\n\n/* access all the arguments assigned to valist */ \nfor (i = 0; i < num; i++)  { \nsum += va_arg(valist, int); \n} \n/* clean memory reserved for valist */ \nva_end(valist); \nreturn sum/num; \n} \n</c>\n\n- Define a function with last parameter as ellipses and the one just before  the ellipses is always an int which will represent number of arguments. \n- Create a va_list type variable in the function definition. This type is  defined in stdarg.h header file. \n\n-Use int parameter and va_start macro to initialize the va_list variable to an argument list. \n- The macro va_start is defined in stdarg.h header file. \n- Use va_arg macro and va_list variable to access each item in argument list. \n- Use a macro va_end to clean up the memory assigned to va_list variable. \n\n<h>\n*Static functions\n</h>\n\n- static keyword makes variable or function scoped.\n- static keyword against global variable or global function makes it scoped to the file.\n- static keyword against class variable or class function makes it scoped to the class data structure.\n- static member function does not receive this pointer as first argument, it can not be virtual.'
'3!ABS SBA!Array Pointers References!ABS SBA!*Modify function argument to accept\n reference to array.\n*Implement a function to accept pointer to\n int and check were boundary overflow is\n not checked by the compiler.!ABS SBA!<h>\n*Defining and initializing Array\n</h>\n\n- Array has to be initialized with constant variable that is qualified at compile time\n<c>\nint ia[get_size()]  // get_size() is function and resolved at run time\nconst int size=get_size(); // size resolved at run time\nint ia[size]; // error\nint ia[10*2-10]; // resolved at compile time\n</c>\n\n- Local copy are uninitialized where as global copy is initialized to 0.\n- Array carrying objects are initialized with default constructor where ever they are declared. If default constructors are not available then array has to be initialized explicitly.\n<c>\n#include <iostream>\nusing namespace std;\n\nconst int array_size=3;\nclass classA{\npublic:\nclassA(){}\nclassA(const char* name):_name(name){}\nconst char* name(){return _name.c_str();}\nprivate:\nstring _name;\n};\nint main(int argc, char *argv[]) {\nclassA arrayclA[array_size]={"one","two","three"};\nconst classA *arrayc2A=new const classA[array_size];\nclassA *arrayc3A=new classA[array_size]();\nconst int *pa=new const int[array_size];\n//const int *pa=new const int[array_size]();\nreturn 0;\n}\n</c>\n\n$ g++ main.cpp\n<c>\nmain.cpp: In function \'int main(int, char**)\':\nmain.cpp:17: error: uninitialized const in \'new\' of \'const int\'\n</c>\n\n- Array can not be copied or assigned\n<c>\nint ia2[](ia); // error\nia2 = ia1; //error\n</c>\n\n- Array size can not be known.\n<c>\nsizeof(arr)/sizeof(&arr[0])\n</c>\n\n- Array memory management is in users hand. Chance of memory overwriting\n<c>\nconst int array_size = 4;\n int main(int argc, char *argv[]) {\n int ia[] = {0, 1, 2};\n char ca[] = "C++";\n char cal[] = {\'C\', \'+\', \'+\', \'\\0\' };\n\n /* array of objects */\n /* equivalent to "hi", "bye", "", ""*/\n string str_arr[array_size] = {"hi", "bye"};\n cout<<ia[0]<<" : "<<ia[1]<<" : "<<ia[2]<<endl;\n cout<<ca<<endl;\n cout<<cal<<endl;\n cout<<str_arr[0]<<" : "<<str_arr[1]<<" : "<<str_arr[2]<<" : "<<str_arr[3]<<endl;\n return 0;\n }\n</c>\n\n- In case of character strings use strn, i.e strncpy, strncat.\n\n<h>\n*Definining and Initializing Pointers\n</h>\n\n<c>\ntype * pointer_name[,*pointer,name2,..];\nchar * terry = "hello"; //character string\nconst char *terry;//pointer to constant char\nchar *const terry;//const pointer to char\nconst char *const terry;//const pointer to char const\n</c>\n\nVarious library function involving char pointer manipulation\n<c>\nstr[n]cpy,str[n]cat,str[n]cmp,strdup,bcopy,memccopy,\nmemcpy,memmove,string,wcscpy,wcsncpy,index, rindex,\nstrcasecmp, strchr, strcmp, strcoll, strcspn,  strfry,\nstrlen,  strncasecmp,  strpbrk, strrchr, strsep, strspn,\nstrstr, strtok, strxfrm\n</c>\n\nDynamically allocating array\n - allocating on heap, size of array can be estimated at run time.\n<c>\n - int *pia = new int[10]; // uninitialized\n            = new int [size_arrary]; // const int size_array=size_of_array();\n            = new int[size_of_array()];\n - int *pia2 = new int[10](); // value initialized\n - const int *pci = new int[10]; //error, not initialized\n - const int *pci = new int[10]();// ok, initialized\n - const string *pcs = new string[10]; // empty string\n</c>\n\nIts legal to dynamically allocate empty array unless dereferenced\n<c>\nchar arr[0]; // error\nchar arr = new char[0];// ok\nchar arr = new char[get_size()];//get_size() can return 0;\n</c>\n\nDynamically allocated array can be deleted with delete [] pia;\n\n<h>\n*Using pointers to access array elements\n</h>\n\n- Pointer works in dynamic allocation\n- Array of pointers\n  classA *arrp=new classA[10];\n\n- Pointer to array of size 10\n<c>\n  classA (*ptoarr)=new classA[10];\n  classA arryofarry[3][10];\n  ptoarr=&arryofarry[2];\n\nint (*pa)[10]; // pointer to array of size 10\n               // array of 10 ints\n++pa;// incrementing will increment 10 ints\nint pi[10];//array of int*\n\nint arr[4][10]\npa=arr;\npa++\n\nint (*pa)[10];\nint arr[4][10];\npa=arr;\ni=0;\nfor(j=0;j<4;j++){\nfor(k=0;k<10;k++)\narr[j][k]=i;\n++i;\n}\n++pa;\nfor(j=0;j<10;j++)\ncout<<pa[0][j];\n</c>\n\nMulti dimensional array\n<c>\nvoid func(int (*a)[10]);\nvoid func(int a[][10]);\nvoid func(int a[4][10]);\nint a[4][10];\nfunc(a);\n</c>\n\n<h>\n*Pointers and const qualifiers\n</h>\n\nread from the right to left.\n<c>\nconst char *terry;//pointer to constant char\nchar *const terry;//const pointer to char\nconst char *const terry;//const pointer to char const\n\nConstant pointers must be initialized at the time of construction\nconst int *pa=new const int[10]; //error not initialized\nconst int *pa=new const int[10](); // value initialized\n</c>\n\n<h>\n*Dynamically allocated arrays\n</h>\n\n- new is used for dynamic allocation\n- new operator calls operator new to allocate byte memory followed by calling default constructor to initialize the object.\n- new without parentheses does not initialize built in types where as calls default constructor for class types\n<c>\nint *pi = new int; // uninitialized\nstring *ps = new string; // initialized to empty string\n</c>\n\n\nnew when unsuccessful throws bad_alloc exception.\n<c>\n                           ----------------\n                           |  exception   |\n                           ----------------\n                                   |\n       +---------------------------------------------------+\n       |                  |             |                  |\n--------------    ---------------  -------------    -------------\n|  bad_cast  |    |runtime_error|  |logic_error|    | bad_alloc |\n--------------    ---------------  -------------    -------------\n\n\n\nnew[] operator can be used to allocate array of values\nnew[] operator calls operator new[] followed by calling default constructor.\nint *pi=new int[100];\n</c>\n\n- value initialized then built in types are initialized where as class types as per the argument. When no argument is passed then default constructor is called.\n- value initialized\n<c>\nstring *ps = new string() ; // default constructor\nint *pi = new int(); // pi points to an int value-initialized to 0\nint *pi = new int(210); // pi points to an int value-initialized to 210\n</c>\n\n- new calls operator new to allocate the bytes of memory followed by object creation by calling default constructor.\n<c>\nclass classA{\npublic:\nclassA(const char* name):_name(name){}\nconst char* name(){return _name.c_str();}\nprivate:\nstring _name;\n};\nint main(int argc, char *argv[]) {\nclassA *pc=new classA("heapallocation");\ncout<<pc->name()<<endl;\nreturn 0;\n}\n</c>\n\n- delete can not be used on a pointer that is not allocated through new\n- delete can happen on NULL pointers.\n- After deletion pointer can still be used but its illegal and undefined.\n- Dynamic allocation to const objects uses new const statement\n<c>\nconst int *pci = new const int(1024);\ndelete pci;\n</c>\n\n- delete[] operator deletes the array allocated through new[]\n<c>\nint *pa=new int[4];\ndelete [] pa;\n</c>\n\n<h>\n*References\n</h>\n\n- A reference serves as an alternative name for an object.\n- A reference is a compound type that is defined by preceding a variable name by the & symbol. A compound type is defined in terms of other types.\n- Think of a variable name as a label attached to the variables location in the memory. Think of a reference as a second label attached to that memory location.\n\n<c>\nint ival = 1024;\nint &refVal = ival;\nint &refVal2; // error\nint &refVal3=10; //error\nint &refVal4=refVal;\nint &ref[];// array of reference not valid error\nint (&ref)[10];//reference to array\nvoid printValuesRef(int (&ref)[10]);\nvoid printValuesArr(int arr[]);\nvoid printValuesArr1(int *arr);\nvoid printValuesArr2(int arr[20]);\nint main(int argc, char *argv[]) {\nint k[10]={0,1,2,3,4,5,6,7,8,9};\nprintValuesRef(k);\nprintValuesArr(k);\nprintValuesArr1(k);\nprintValuesArr2(k);\nreturn 0;\n}\nvoid printValuesRef(int (&ref)[10]) {\nfor(size_t i=0; i != 10; ++i)\ncout<<ref[i]<<endl;\n}\nvoid printValuesArr(int arr[]) {\nfor(size_t i=0; i != 10; ++i)\ncout<<arr[i]<<endl;\n}\nvoid printValuesArr1(int *arr){\nfor(size_t i=0; i != 10; ++i)\ncout<<arr[i]<<endl;\n}\nvoid printValuesArr2(int arr[20]){\nfor(size_t i=0; i != 10; ++i)\ncout<<arr[i]<<endl;\n}\n</c>\n\nv Passing references to objects\n- Reference to object is important when object is big in size and copy is costly operation. const reference is also useful when object need not be modified.\n- Reference to object is mostly useful in stream objects where single object copy is maintained.\n\n<c>\nofstream out1, out2;\nofstream print(ofstream);\nout2 = print(out2); // error; cannot copy stream objects\nofstream print(ofstream&);//ok\nbool isShorter(const string &s1, const string &s2){\nreturn s1.size() < s2.size();\n}\n</c>\n\n- Its always good to have const reference as parameter.\n\nv Returning references\n- When a function returns a reference, it returns an implicit pointer to its return value. This way, a function can be used on the left side of an assignment statement.\n- When returning a reference, be careful that the object being referred to does not go out of scope.\n- It is not legal to return a reference to local var. But you can always return a reference on a static variable.\n\n<h>\n*Independent references and restriction\n</h>\n\n- Independent reference can not exist. Its only possible as class member variable then it has to be initialized in constructor.\n\n<h>\n*Multidimensional array argument to function\n</h>\n\n<c>\n#include <iostream>\nusing namespace std;\n\nvoid printarray(int (&arr)[4][4]){\nint i=0,j=0;\nfor (i=0;i<4;i++){\nfor (j=0;j<4;j++)\ncout<<arr[i][j]<<" ";\ncout<<endl;\n}\n}\nvoid preparearray(int (&arr)[4][4]){\nint i=0,j=0;\nfor (i=0;i<4;i++)\nfor (j=0;j<4;j++)\narr[i][j]=i;\n}\n\nint main(int argc,char *argv[]){\nint arr[4][4];\npreparearray(arr);\nprintarray(arr);\nreturn 0;\n}\n</c>\n$ g++ valueref.cpp\n$ ./a.out\n<c>\n0 0 0 0\n1 1 1 1\n2 2 2 2\n3 3 3 3\n</c>'
'4!ABS SBA!Namespaces!ABS SBA!*Emulate file scope static variable with\n unnamed namespace!ABS SBA!<h>\n*What is namespace\n</h>\n\n-There can be chance of same name collision. Ex. library function xyz() can collide with user function xyz(). This is called namespace collision.\n- Namespace provide a controlled mechanism for preventing name collision.  It provide a separate scope in which functions and variable can be defined.\n- Namespaces partition the global namespace, making it easier to use independently produced libraries.\n\n- Namespace definition\n<c>\nnamespace namespace_one {\n}\n\n#include <iostream>\nusing namespace std;\nclass classA {\npublic:\nconst char* name() {\nreturn "Global class A";\n}\n};\n// first name space\nnamespace first_space{\nvoid func(){\ncout<<"Inside first_space" <<endl;\n}\nclass classA {\npublic:\nconst char* name() {\nreturn "first_space::classA";\n}\n};\n}\n// second name space\nnamespace second_space{\nvoid func(){\ncout << "Inside second_space" << endl;\n}\nclass classA {\npublic:\nconst char* name() {\nreturn "second_space::classA";\n}\n};\n}\n\nint main ()\n{\n\n// Calls function from first name space.\nfirst_space::func();\nclassA clsA_g;\nfirst_space::classA clsA_f;\nsecond_space::classA clsA_s;\ncout<<clsA_g.name()<<endl;\ncout<<clsA_f.name()<<endl;\ncout<<clsA_s.name()<<endl;\n// Calls function from second name space.\nsecond_space::func();\n\nreturn 0;\n}\n</c>\n\n- Namespace can be discontiguous. Writing namespace {} either defines a new namespace or adds to an existing one.\n- Discontiguous namespace can be used for declaration and definition separation, where class definition, function declaration can go in namespace that is defined in a header file where as class implementation and function definition can go in cpp file.\n- When class is implemented in the discontiguous namespace class name would not prepend the namespace name.\n- To fetch global namespace functions :: can be used. i.e ::member_name\n\n\n- Nestested Namespace\n- Namespaces can be nested where you can define one namespace inside\nanother name space as follows:\n<c>\nnamespace namespace_name1 {\n// code declarations\nnamespace namespace_name2 {\nclass classA{\n};\n}\n}\n</c>\n\n- Code in the outer parts of the enclosing namespace may refer to a name in a nested namespaces only through its qualified name.\n- Inner namespace variables can be used with full qualification,\ni.e. namespace_name1::namespace_name2::classA;\n\n<h>\n*Scope resolution\n</h>\n\nEach namespace is a scope and members are accessed with scope resolution operator ::\nTo fetch global namespace functions :: can be used. i.e ::member_name\n\n<h>\n*Using declaration\n</h>\n\n- using declaration introduces only one namespace member at a time.\n<c>\nmap<string, vector < pair<size_t, size_t> > > word_map;\nusing std::map;\nusing std::vector;\nusing std::pair;\nusing std::string;\nusing std::size_t;\n</c>\n\n- using resolution operator\nwhole namespace can be visible in the current scope with using\n<c>\nnamespace statement\n\nusing namespace std;\n// using namespace example\n#include <iostream.h>\nnamespace first\n{\nint var = 5;\n}\nnamespace second\n{\ndouble var = 3.1416;\n}\nint main () {\nusing namespace second;\ncout << var << endl;\ncout << (var*2) << endl;\nreturn 0;\n}\n</c>\nUsing both\n\n<c>\n// using namespace example\n#include <iostream.h>\nnamespace first\n{\nint var = 5;\n}\nnamespace second\n{\ndouble var = 3.1416;\n}\nint main () {\n{\nusing namespace first;\ncout << var << endl;\n}\n{\nusing namespace second;\ncout << var << endl;\n}\nreturn 0;\n}\n</c>\n\n<h>\n*Aliases\n</h>\n\n- An alias to long namespace name can be created. i.e namespace name = namespace_name1::namespace_name2;\n\n<h>\n*Unnamed namespace\n</h>\n\n- Unnamed Namesapces\n- An unnamed namespace is a namespace that is defined without a name. i.e namespace {}\n- Unnammed namespace can not span over files.\n- Variable in global namespace can collide with unnamed namespace\n\n<c>\nint i;\nnamespace {\nint i;\n}\ni=10; // error\n</c>\n\n- Since variables unnamed namespace belongs to the file it is replacement of static variable and functions which also file visibility. static is deprecated in c++ against unnamed namespace.\n- If unnamed namespace is nested, then names in it are accessed in the normal way, using the enclosing namespace name(s).\n\n<c>\nnamespace local {\nnamespace {\nint i;\n}\n}\nlocal::i=42; //ok\n</c>\n\n<h>\n*Overloading and namespaces\n</h>\n\nA given namespace can contain a set of overload member functions.\n1. Find the set of candidate functions. A function is a candidate if a declaration for it is visible at the time of the call and it has the same name as the called function.\n\n2. Select the viable functions from the set of candidates. A function is viable if it has same number of parameters as the call has arguments and if each parameter could be matched by the corresponding argument.\n\n3. Select the single best match from the viable set and generate code to call that function.\nIf the viable set is empty, then the call is in error, having no match\nIf the viable set is nonempty and there is no best match, then the call is ambiguous.\n\n<c>\n#include <iostream>\nusing namespace std;\nint i=10;\nnamespace A{\nvoid print(const char* a){\ncout<<"A::print"<<a<<endl;\n}\n}\nvoid print(string &str){\ncout<<"::print"<<str<<endl;\n}\nint main(){\ncout<<"i"<<::i<<endl;\nusing namespace A;\nprint("abc");\nreturn 0;\n}\n</c>\n\n$ g++ namespace.cpp\n$ ./a.out\n<c>\ni10\nA::printabc\n</c>\n\n<h>\n*Namespace and templates\n</h>\n\nTo provide our own specializations of templates defined in a namespace,\nwe must ensure that the specialization definition is defined as being in\nthe namespace containing the original template definition.'
'5!ABS SBA!Overview of C++!ABS SBA!*Write a simple class with overriden\n constructor and destrutor!ABS SBA!<h>\n*Object oriented programmming\n</h>\n\nA programming language that provides\n - Class\nA mechanism for defining our own abstract data types. Class may have properties, methods and type members. A class defines a new type and a new scope.\n- Object\nAn object is a region in the memory that has a type. Evaluating an expression that is an lvalue yields an object. A variable is an object that has a name.\n- Encapsulation\nIt describes the technique of combining lower-level elements to form a new high-level identity.  Function and structures are examples of encapsulation.\n- Abstraction\nSeparation of implementation from interface; Abstraction hides the implementation details of a type. Programmers worry about internal data structure and users worry about interfaces provided. Private data member are used for encapsulation.\n- Inheritance\nA derived class inherits properties from its base class. Types that are related by inheritance share a common inheritance.\n- Polymorphism\nDerived from a Greek word, " many forms". It is ability to obtain type specific behaviour based on the dynamic type of a reference or pointer.\n\n<h>\n*C++ class\n</h>\n\n- Class\nA mechanism for defining our own abstract data types. Class may have properties, methods and type members. A class defines a new type and a new scope. Class itself is a structure and consume 1 byte if not attributes are defined. Static members to classes belongs to class data structure.\n\n<c>\nclass A{\n};\n\n- Class declaration\nA class may be declared before it is defined.\nclass B;  // declaration\nclass A{ // definition\nB* b;\n};\n</c>\n\n- Class definition\nA class body\n- Abstract class\nA class structure that uses encapsulation to hide its implementation, allowing programmers using the type to think abstractly about what the type does rather than concretely about how the type is represented.\n\n- Concrete class\nA class that exposes its implementation. i.e std::pair. All attributes are public\n\n<h>\n*Attribute and method\n</h>\n\n- Attributes are non function member fields in class. It can built in types or user defined types. It can volatile, const, static const,  reference, const reference, pointer or const pointer types.\n- Methods are function member variable., Methods does not contribute in size of the class and they get first parameter as pointer to object of the class also called this pointer. Methods can be static, virtual or const. Static methods belongs to class data structure where as non  static belongs to object., const member function does not allow attributes to be changed.\n\n<h>\n*Private, protected and public access controls\n</h>\n\n\n\n- Private members accessible to friends and other class members. Private members are used as implementation library. If a class is derived private or protected it is implementation based inheritance.\n- Protected members are accessible to friends, other class members and derived class classes. It different from protected in order that derive class (public or protected inheritance) can also use it. It comes under implementation based inheritance.\n- Public members are accessible to everyone. It is mostly used as interface to the user of class. public inheritance is also a interface base inheritance.\n\n<h>\n*Constructor, synthesised default constructor\n</h>\n\n- Constructor is a member function with name same as class name with no return type. It has special privilege as it is called implicitly an class is instantiated. Constructor can have arguments. when no argument is specified constructor is called default constructor. Explicit default constructor does not implicit type conversion.\n- Copy Constructor takes const reference to same class type as an argument to the function. It is used to copy one object to other of same type.\n- Synthesized constructor are constructors generated through compiler when it is not provided by the programmer. If no constructor is provided then default constructor, copy constructor, assignment operator and destructor is provided through the compiler. If any of the constructor is provided then default constructor is not provided through the compiler though other copy control can be synthesized if not available.\n- Parametrized Constructor\nA constructor can have parameters. This helps to assign initial value to an object at the time of its creation.\n\n<c>\n#include <iostream>\nusing namespace std;\nclass Line{\npublic:\ndouble length( void );\nLine(double);   // This is the constructor declaration\n~Line();  // This is the destructor: declaration\nprivate:\ndouble _length;\n};\n// Member functions definitions including constructor\nLine::Line(double length) {\ncout << "Object is being created" << endl;\n_length=length;\n}\nLine::~Line(void){\ncout << "Object is being deleted" << endl;\n}\ndouble Line::length( void ){\nreturn _length;\n}\n// Main function for the program\nint main( ){\nLine line(10);\ncout << "Length of line : " << line.length() <<endl;\nreturn 0;\n}\n</c>\n\n<h>\n*Copy control\n</h>\n\n- Copy Constructor,Assignment operator and destructor are copy control.\n- Copy constructor is used  at following places\n>The constructor that takes single parameter (const reference) as argument to class type itself.\n>Explicitly or implicitly initialize one object from another of the same type.\n<c>\nstring securityId="99999-99999-99999";\nstring securityId2=securityId;\nstring securityId2(securityId);\n</c>\n\n>Copy an object to pass it as an argument to a function.\n<c>\nstring secuirtyId="123-123-123";\nvoid func(const string secid);\nfunc(secuirtyid);\n</c>\n\n>Copy an object to return it from a function.\n<c>\nstring make_plural(size_t s, const string& str, const string& end) {\nreturn (size == 1?str:str+end);\n}\n</c>\n\n>Initialize the elements in a sequential container.\n<c>\n  vector<string> stringvec(5);\n</c>\n\nThis creates five temporary string object with default constructor and then  creates five vector strings  calling its copy constructor on five temporary objects.\n>Initialize elements in an array from a list of element initializers\n<c>\nstring stringarry[] = { "one", "two", "three"}\n#include <iostream>\nusing namespace std;\nvoid func(string str) {\ncout<<"string : "<<str<<endl;\n}\nclass classA {\npublic:\nclassA() {\ncout<<"default constructor"<<endl;\n}\nclassA(const classA& cls) {\ncout<<"copy constructor"<<endl;\n}\nexplicit classA(const string& str) {\ncout<<"overloaded constructor : "<<str<<endl;\n}\nclassA(const char *cp) {\ncout<<"overload const char constructor :"<<cp<<endl;\n}\nclassA& operator=(const string& str) {\ncout<<"assignment operator "<<str<<endl;\nreturn *this;\n}\n};\nint main(int argc, char *argv[]) {\nclassA clsarr[] = { classA(string("one")),\n    classA(string("two")),\n    classA(string("three"))\n};\nfunc(string());\nreturn 0;\n}\n</c>\n\n- More on copy constructor\n>Copy constructor should be declared private if copy need to be disabled, i.e. ostream.\n>private copy constructor may need to declared but not defined if copy needs to be disabled from friends and member functions.\n\n>Default behaviour of synthesized copy constructor is to do member wise copy. Shallow copy.\n- Synthesized Copy Constructor\n>When copy constructor is synthesized through compiler.\n>Unlike default constructor it is synthesized even though other constructors we define.\n\n- Parametrized constructor\n- Other overloaded constructor can be declared as per the need.\n\n- Assignment operator can be overloaded to define what it means to assign one object of a class type to another of the same type. The assignment operator must be a member of its class and should return a reference to its object. The compiler synthesizes the assignment operator if the class does not explicitly define one.\n- Assignment operator can be of non class type.\n- Assignment operator can be compound type.\n<c>\n#include <iostream>\nusing namespace std;\nclass classA {\npublic:\nclassA(){\n_data="";\n}\nclassA(const classA& c) {\ncout<<"copy constructor"<<endl;\n}\nclassA& operator=(const char* cp) {\ncout<<"char pointer"<<endl;\n_data+=cp;\nreturn *this;\n}\nclassA& operator=(const string& cs) {\ncout<<"constant string"<<endl;\n_data+=cs;\nreturn *this;\n}\nclassA& operator=(char c) {\ncout<<"char"<<endl;\n_data+=c;\nreturn *this;\n}\nclassA& operator+=(const classA& rhs) {\n_data+=rhs._data;\nreturn *this;\n}\nstring& data() {\nreturn _data;\n}\nprivate:\nstring _data;\n};\n\nint main() {\nclassA cls;\ncls = "one";\ncls = string(":two");\ncls=\':\';\nclassA rhs;\nrhs="three";\ncls+=rhs;\ncout<<"cls data : "<<cls.data()<<endl;\nreturn 0;\n}\n</c>\n\n- Destructor\nA destructor is a special member function of a class that is executed whenever an object of it\'s class goes out of scope or whenever the delete expression is applied to a pointer to the object of that class.\n\n- A destructor will have exact same name as the class prefixed with a tilde (~) and it can neither return a value nor can it take any parameters.\n- Destructor can be very useful for releasing resources before coming out of the program like closing files, releasing memories etc.\n\n<c>\n#include <iostream>\nusing namespace std;\nclass Line{\npublic:\ndouble length( void );\nLine();   // This is the constructor declaration\n~Line();  // This is the destructor: declaration\nprivate:\ndouble _length;\n};\n// Member functions definitions including constructor\nLine::Line(void){\ncout << "Object is being created" << endl;\n_length=0;\n}\nLine::~Line(void){\ncout << "Object is being deleted" << endl;\n}\ndouble Line::length( void ){\nreturn _length;\n}\n// Main function for the program\nint main( ){\nLine line;\ncout << "Length of line : " << line.length() <<endl;\nreturn 0;\n}\n</c>\n\n<h>\n*Object\n</h>\n\n- An object is region in memory that has a type. A value is object that has a name.\n<c>\nint i(0);\nstruct A a;\nstruct A a[4]={1,2,3,4};\n</c>\n\n<h>\n*Array of objects\n</h>\n\n- Define and initialize static array\n- Array has to be initialized with constant variable that is qualified at compile time\n<c>\nint ia[get_size()]// get_size() is function and resolved at run time\nconst int size=get_size(); // size resolved at run time\nint ia[size]; // error\nint ia[10*2-10]; // resolved at compile time\n</c>\n\n- Local copy are uninitialized where as global copy is initialized to 0.\n- Array carrying objects are initialized with default constructor where ever they are declared.\nIf default constructors are not available then array has to be initialized explicitly\n<c>\nconst int array_size=3;\nclass classA{\npublic:\nclassA(const char* name):_name(name){}\nconst char* name(){return _name.c_str();}\nprivate:\nstring _name;\n};\n\nint main(int argc, char *argv[]) {\nclassA arrayclA[array_size]={"one","two","three"};\ncout<<arrayclA[0].name()<<" : "<<arrayclA[1].name()<<" : "<<arrayclA[2].name()<<endl;\nreturn 0;\n}\n</c>\n\n- Array can not be copied or assigned\n<c>\nint ia2[](ia); // error\nia2 = ia1; //error\n</c>\n\n- Array size can not be known.\n- sizeof(arr)/sizeof(&arr[0])\n- Array memory management is in users hand. Chance of memory overriding\n<c>\n- const int array_size = 4;\nint main(int argc, char *argv[]) {\nint ia[] = {0, 1, 2};\nchar ca[] = "C++";\nchar cal[] = {\'C\', \'+\', \'+\', \'\\0\' };\n\n/* array  of objects */\n/* equivalent to "hi", "bye", "", ""*/\nstring str_arr[array_size] = {"hi", "bye"};\ncout<<ia[0]<<" : "<<ia[1]<<" : "<<ia[2]<<endl;\ncout<<ca<<endl;\ncout<<cal<<endl;\ncout<<str_arr[0]<<" : "<<str_arr[1]<<" : "<<str_arr[2]<<" : "<<str_arr[3]<<endl;\nreturn 0;\n}\n</c>\n\n- In case of character strings use strn, i.e strncpy, strncat.\n\n\n- Dynamic Allocating arrays\nallocating on heap, size of array can be estimated at run time.\n<c>\nint *pia = new int[10]; // uninitialized\n         = new int [size_arrary]; // const int size_array=size_of_array();\n         = new int[size_of_array()];\nint *pia2 = new int[10](); // value initialized\nconst int *pci = new int[10]; //error, not initialized\nconst int *pci = new int[10]();// ok, initialized\nconst string *pcs = new string[10]; // empty string\n</c>\n\nIts legal to dynamically allocate empty array unless dereferenced\n<c>\nchar arr[0]; // error\nchar arr = new char[0];// ok\nchar arr = new char[get_size()];//get_size() can return 0;\n</c>\n\n- Dynamically allocated array can be deleted with delete [] pia;\n\n<h>\n*Virtual methods\n</h>\n\n- Virtual function can belong to a class where it supports polymorphism\n- Virtual function makes entry in vtable.\n- Virtual function do not support function overloading in polymorphism.\n- When data abstraction is required then virtual function is declared as pure virtual.\n- Data abstraction refers to, providing only essential information to the outside world and hiding their background details,  i.e., to represent the needed information in program without presenting the details.\n- Data abstraction is a programming (and design) technique that relies on the separation of interface and implementation.\n- Data abstraction layer also known as interfaces must not contain any attributes and only operations should be supported either pure virtual or default implementation implemented.\n\n<c>\nclass ITelevision {\npublic:\nvirtual void switchto(bool onoff=0) = 0;\nvirtual void volume(int level) = 0;\nvirtual void channel(int number) = 0;\n};\nclass modeltelevision: public ITelevision {\npublic:\nvirtual void switchto(bool onoff) {\ncout<<"Tv is switched "<<(onoff?" ON ": " OFF ")<<endl;\n}\nvirtual void volume(int level) {\ncout<<"Volume raised to : "<<level<<endl;\n}\nvirtual void channel(int number) {\ncout<<"channel number : "<<number<<endl;\n}\n};\nint main(int argc, char *argv[]) {\nITelevision *tv=new modeltelevision;\ntv->switchto(true);\ntv->channel(5);\ntv->volume(8);\ntv->switchto(false);\nreturn 0;\n}\n</c>\n\n<h>\n*Mutable data members and const methods\n</h>\n\n- A mutable data member that in never a const can be modified even in\nconst member function. A const member function can not modify attribute.\n<c>\nclass widget:QWidget{\nmutable int sizehintcont;\nQSize sizeHint() const;\n};\nQSize widget::sizeHint()const{\n++sizehintcount;\nreturn QSize(10,10);\n}\n</c>\n\n<h>\n*Class relationships, inheritance and containment\n</h>\n\n- Classes can be interrelated by means of inheritance and containment.\nIf a class derives other then it is inheritance. Class carries all parent attributes and methods. Parent attributes and methods can be called in Derived class context. Base class object comes inside of derive class object. Template method.\n\n<c>\nstruct A:B{\n};\nA *, B* --> +-------------+\n            |   B::b:int  |\n            ---------------\n            |   A::a:int  |\n            +-------------+\n</c>\n\n- A class can keep other class as attributes known as containment. Here\ncontainer class can keep or throw the contained class as per need.\n- Container is important in strategy pattern.\n\n<h>\n*Static attributes and static methods.\n</h>\n\n- Data or function member that is not a part of any object but is shared by all objects of a given class. Static is part class structure.\n\n- Static methods can not call member variables not static as they are part of object structure.\n- Static methods does not contain this pointer.\n- No polymorphism on static methods. It can not be virtual.\n- We can define class members static using static keyword. When we declare a member of a class as static it means no matter how many objects of the class are created, there is only one copy of the static\nmember.\n- A static member is shared by all objects of the class. All static data is initialized to zero when the first object is created, if no other initialization is present.\n\n- By declaring a function member as static, you make it independent of any particular object of the class. A static member function can be called even if no objects of the class exist.\n- A static member function can only access static data member, other static member functions and any other functions from outside the class.\n- Static member functions have a class scope and they do not have access to the this pointer of the class.\n\n<c>\n#include <iostream>\nusing namespace std;\nclass Box{\npublic:\nstatic int objectCount;\nBox(double l=2.0, double b=2.0, double h=2.0){\ncout <<"Constructor called." << endl;\nlength = l;\nbreadth = b;\nheight = h;\nobjectCount++;\n}\ndouble Volume(){\nreturn length * breadth * height;\n}\nstatic int getCount(){\nreturn objectCount;\n}\nprivate:\ndouble length;     // Length of a box\ndouble breadth;    // Breadth of a box\ndouble height;     // Height of a box\n};\nint Box::objectCount = 0;\nint main(void){\ncout << "Inital Stage Count: " << Box::getCount() << endl;\nBox Box1(3.3, 1.2, 1.5);    // Declare box1\nBox Box2(8.5, 6.0, 2.0);    // Declare box2\ncout << "Final Stage Count: " << Box::getCount() << endl;\nreturn 0;\n}\n</c>\n\n<h>\n*Friend function and class\n</h>\n\n- A friend function of a class is defined outside that class scope but it has the right to access all private and protected members of the class.\n- Even though the prototypes for friend functions appear in the class definition, friends are not member functions.\n- A friend can be a function, function template, or member function, or a class or class template, in which case the entire class and all of its members are friends.\n- To declare a function as a friend of a class, precede the function Prototype in the class definition with keyword friend as follows:\n\n<c>\n#include <iostream>\nusing namespace std;\nclass Box {\ndouble width;\npublic:\nfriend void printWidth( Box box );\nvoid setWidth( double wid );\n};\nvoid Box::setWidth( double wid ) {\nwidth = wid;\n}\nvoid printWidth( Box box ) {\ncout << "Width of box : " << box.width <<endl;\n}\n\nint main( ) {\nBox box;\nbox.setWidth(10.0);\nprintWidth( box );\nreturn 0;\n}\n</c>\n\n- Friend class similar to friend function gets access to friends all\nattributes and methods. A friend class though have no special access\nto base or derived class of the class to which it friend with.\n\n<c>\nclass A{\nprotected int a;\n};\nclass B:publlic A{\nprivate int b;\nfriend class D;\n};\nclass D{\npublic:\nvoid print(A apar){\ncout<<apar.b;\n}\n};\n</c>'
'6!ABS SBA!Virtual concepts!ABS SBA!!ABS SBA!<h>\n*Object slicing\n</h>\n\n- Unexpected object slicing can happen in which assignment by value\nis not polymorphic.\n\nstruct A\n{\nA(int a) : a_var(a) {}\nint a_var;\n};\nstruct B : public A\n{\nB(int a, int b) : A(a), b_var(b) {}\nint b_var;\n};\nB &getB()\n{\nstatic B b(1, 2);\nreturn b;\n}\nint main()\n{\n// Normal assignment by value to a\nA a(3);\na = getB();\n// a.a_var == 1, b.b_var not copied to a\nB b2(3, 4);\nA &a2 = b2;\n// Partial assignment by value through reference to b2\na2 = getB();\n// b2.a_var == 1, b2.b_var == 4!\nreturn 0;\n}\n\n<h>\n*Calling virtual function for constructor\n</h>\n\n- A constructor can not resolve virtual functions and function would\nresolved at compile time.\nclass A{\npublic:\nA(){\nfunc();\n}\nvirtual void func(){\ncout<<"A::func"<<endl;\n}\n};\nclass B:public A{\npublic:\nvoid func(){\ncout<<"B::func"<<endl;\n}\n};\n\nint main(int argc, char *argv[]){\nA* b=new B;\nreturn 0;\n}\n\n<h>\n*Calling virtual function from non virtual function.\n</h>\n\n- Calling virtual function from non virtual function supports\npolymorphism. Template method.\n\n<h>\n*Non member virtual function.\n</h>\n\n- No non member virtual function can exist as vptr does not exist in file\ncontext.\n\n<h>\n*Dual dispatching\n</h>\n\n- In dual dispatching a function dispatches the request to other concrete\nfunction depending on the run time types of two objects involved in the call.\n\nstruct Figure {\n void printOn( Printer *printer );\n}\nstruct Printer {\n void printCircle( Circle *circle );\n void printRectangle( Rectangle *rectangle );\n}\n\nNext, we write our two printers:\n\nstruct InkjetPrinter :Printer {\n void printCircle( Circle *circle ) {\n cout<<"Inkjet printer prints a cirlce.";\n }\n void printRectangle( Rectangle *rectangle ) {\n cout<<"Inkjet printer prints a rectangle.";\n }\n}\nstruct PostscriptPrinter : Printer {\n void printCircle( Circle *circle ) {\n cout<<"PostScript printer prints a cirlce.";\n }\n void printRectangle( Rectangle *rectangle ) {\n cout<<"PostScript printer prints a rectangle.";\n }\n}\n\nstruct Circle :Figure {\n void printOn( Printer *printer ) {\n printer->printCircle( this );\n }\n}\nstruct Rectangle : Figure {\n void printOn( Printer *printer ) {\n  printer->printRectangle( this );\n}\n}\n\nint main (int argc, char *argv[]){\nconst int FIGURECOUNT=2;\nconst int PRINTERCOUNT=2;\nFigure *figures[]{ new Circle, new Rectangle };\nPrinter *printers[] { new PostscriptPrinter, new InkjetPrinter };\nfor(int i=0;i<FIGURECOUNT;++i){\n for(int j=0;j<PRINTERCOUNT;++j){\n  figures[i]->printOn(printers[j]);\n }\n}\nreturn 0;\n}'
'7!ABS SBA!Copy Control!ABS SBA!*Write copy control for a class!ABS SBA!<h>\n*Copy constructor\n</h>\n\n- Default Constructor\n - Constructor having no parameter is default constructor. Default in the sense if object is constructed with any argument passed then this constructed gets called.\n - A synthesized default constructor is provided by the compiler in case there is no other constructor available for the class.\n\n - Default constructor can be overloaded in fashion that other functions are overloaded in c++. It can have default parameter values also. Overloaded functions comes under two categories\n\n- Copy Constructor\n- Parametrized constructor\n\n- Copy Constructor\n- Copy constructor falls in a category called Copy Control. Copy constructor is used at following places\n- The constructor that takes single parameter (const reference) as argument to class type itself.\n\n- Explicity or implicitly initialize one object from another of the same type.\n<c>\nstring securityId="99999-99999-99999";\nstring securityId2=securityId;\nstring securityId2(securityId);\n</c>\n\n- Copy an object to pass it as an argument to a function.\nstring secuirtyId="123-123-123";\n<c>\nvoid func(const string secid);\nfunc(secuirtyid);\n</c>\n\n- Copy an object to return it from a function.\n<c>\nstring make_plural(size_t s, const string& str, const string& end) {\nreturn (size == 1?str:str+end);\n}\n</c>\n\n- Initialize the elements in a sequential container.\n<c>\nvector<string> stringvec(5);\n</c>\n\nThis creates five temporary string object with default constructor and then creates five vector strings calling its copy constructor on five temporary objects.\n- Initialize elements in an array from a list of element initializers\n<c>\nstring stringarry[] = { "one", "two", "three"}\n\n#include <iostream>\nusing namespace std;\nvoid func(string str) {\ncout<<"string : "<<str<<endl;\n}\nclass classA {\npublic:\nclassA() {\ncout<<"default constructor"<<endl;\n}\nclassA(const classA& cls) {\ncout<<"copy constructor"<<endl;\n}\nexplicit classA(const string& str) {\ncout<<"overloaded constructor : "<<str<<endl;\n}\nclassA(const char *cp) {\ncout<<"overload const char constructor :"<<cp<<endl;\n}\nclassA& operator=(const string& str) {\ncout<<"assignment operator "<<str<<endl;\nreturn *this;\n}\n};\nint main(int argc, char *argv[]) {\nclassA clsarr[] = { classA(string("one")),\n                    classA(string("two")),\n                    classA(string("three"))\n                  };\nfunc(string());\nreturn 0;\n}\n</c>\n\nv Creating and using a copy constructor\n- The copy constructor is a constructor which creates an object by initializing it with an object of the same class, which has been created previously. The copy constructor is used to:\n- Initialize one object from another of the same type.\n- Copy an object to pass it as an argument to a function.\n- Copy an object to return it from a function.\n- If a copy constructor is not defined in a class, the compiler itself defines one, irrespective of other constructor defined by user and makes shallow copy.\n\n<c>\nclassname (const classname &obj) {\n   // body of constructor\n}\n</c>\n\nHere, obj is a reference to an object that is being used to initialize another object.\n\n<h>\n*Synthesized copy constructor\n</h>\n\nWhen copy constructor is synthesized through compiler.\nUnlike default constructor it is synthesized even though other constructors we define.\n- More on copy constructor\nCopy constructor should be declared private if copy need to be disabled,\ni.e. ostream.\nprivate copy constructor may need to declared but not defined if copy needs to be disabled from friends and member functions\nDefault behaviour of synthesized copy constructor is to do member wise copy. Shallow copy.\n\n<h>\n*Explicit qualifier\n</h>\n\n- constructor\'s implicit conversion can be prevented by declaring the constructor explicit.\n<c>\nclass A{\npublic:\nexplicit A(const std::string &str="");\n};\nstring lstr="abc-def";\nvoid func(A a){\n}\nfunc("abc-def");//wrong\nfunc(A(lstr));\n</c>\n\n<h>\n*Preventing copies\n</h>\n\n- declaration copy constructor and equal operator private\n- do not define\n- example ostream\n\n<h>\n*Assignment operator\n</h>\n\nAssignment operator can be member or non member functions.  for member function first member of the function is bound to \'this\' pointer.\n<c>\nstruct A{\nA& operator=(const A&);\n}\nvoid operator=(const A&,const A&);\n</c>\n- synthesized assignment operator\nif assignment operator is not available compiler pushes a synthesized.\n- does member wise copy (shallow for pointer)\n- does array member index wise copy\n<c>\nA a;\nA b=a; // copy constructor\n\n\n#include <iostream>\nusing namespace std;\nclass classA {\npublic:\nclassA(){\n_data="";\n}\nclassA(const classA& c) {\ncout<<"copy constructor"<<endl;\n}\nclassA& operator=(const char* cp) {\ncout<<"char pointer"<<endl;\n_data+=cp;\nreturn *this;\n}\nclassA& operator=(const string& cs) {\ncout<<"constant string"<<endl;\n_data+=cs;\nreturn *this;\n}\n\nclassA& operator=(char c) {\ncout<<"char"<<endl;\n_data+=c;\nreturn *this;\n}\nclassA& operator+=(const classA& rhs) {\n_data+=rhs._data;\nreturn *this;\n}\nstring& data() {\nreturn _data;\n}\nprivate:\nstring _data;\n};\nint main() {\nclassA cls;\ncls = "one";\ncls = string(":two");\ncls=\':\';\nclassA rhs;\nrhs="three";\ncls+=rhs;\ncout<<"cls data : "<<cls.data()<<endl;\nreturn 0;\n}\n</c>\n\n<h>\n*Destructor\n</h>\n\nDestructor is automatically called when an object is released from the memory, either because its scope of existence has finished (for example, if it was defined as a local object within a function and the function ends) or because it is an object dynamically assigned and it is released using operator delete.\n\nThe destructor must have the same name as the class with a tilde (~) as prefix and it must return no value.\n- destructor is synthesised by compiler if not declared\n- destructor can be virtual to support polymorphism and get derived class\n  destructor called with delete on base class pointer.\n- destructor can be called as method.\n\n<c>\n// example on constructors and destructors\n#include <iostream.h>\nclass CRectangle {\nint *width, *height;\npublic:\nCRectangle (int,int);\n~CRectangle ();\nint area (void) {return (*width * *height);}\n};\nCRectangle::CRectangle (int a, int b) {\nwidth = new int;\nheight = new int;\n*width = a;\n*height = b;\n}\nCRectangle::~CRectangle () {\ndelete width;\ndelete height;\n}\nint main () {\nCRectangle rect (3,4), rectb (5,6);\ncout << "rect area: " << rect.area() << endl;\ncout << "rectb area: " << rectb.area() << endl;\nreturn 0;\n}\n</c>'
'8!ABS SBA!Object Model and Polymorphism!ABS SBA!*Check vtable entry through gdb!ABS SBA!<h>\n*Table driven model\n</h>\n\n- In order to maintain uniform representation of objects for all classes table driven object model places attributes and methods to two different tables.\nThe class object contains the pointers to the two member tables. The member function table is a sequence of slots, with each slot addressing a member. The data member table directly holds the data.\n\n<c>\n                                     attribute\n                         |--------> -----------------\n                         |          |         x |\n                         |          --------------\n                         |          |         y |\n                         |          ---------------\n        -------------    |\n        |           |    |\n        |       o---------\n        -------------\n        |           |\n        |       o---------\n        -------------    |\n          Point pt;      |            method\n                         |-------> --------------\n                                   |         o--|---->\n                                   --------------\n                                   |         o--|---->\n                                   --------------\n                                   |         o--|---->\n                                   --------------\n</c>\n\n<h>\n*Object model with single inheritance (SI)\n</h>\n\n<c>\n- class A{\nint a;\nvoid f(int);\nvoid g(int);\nvoid h(int);\n};\n\nclass B:A{\nint b;\nvoid g();\n};\n\nclass C:B{\nint c:\nvoid h();\n};\n\nclass C:\n-------- A*\n| a:int|\n--------\n\n-------- A*,B*\n| a:int|\n| b:int|\n---------\n\nC* pc=new C;\nB* b=(B*)pc;\n\n--------- <-- A*,B*,C*\n| a:int |\n| b:int |\n| c:int |\n---------\n</c>\n\n$ cat main.cpp\n<c>\n#include <iostream>\nusing namespace std;\nstruct A{\nint a;\nvoid f();\nvoid g();\nvoid h();\n};\nstruct B:A{\nint b;\nvoid g();\n};\nstruct C:B{\nint c;\nvoid h();\n};\nint main(){\nC* c=new C;\ncout<<"C* "<<c<<endl;\ncout<<"B* "<<dynamic_cast<B*>(c)<<endl;\ncout<<"A* "<<dynamic_cast<A*>(c)<<endl;\ncout<<"int a "<<&c->a<<endl;\ncout<<"int b "<<&c->b<<endl;\ncout<<"int c "<<&c->c<<endl;\nreturn 0;\n}\n\n----------- <----A*,B*,C* (0xc661010)\n| a:int   | (0xc661010)\n-----------\n| b:int   | (0xc661014)\n-----------\n| c:int   | (0xc661018)\n-----------\n</c>\n\n$ ./a.out\n<c>\nC* 0xc661010\nB* 0xc661010\nA* 0xc661010\nint a 0xc661010\nint b 0xc661014\nint c 0xc661018\n</c>\n\n\n<h>\n*Object model with multiple inheritance(MI)\n</h>\n\n<c>\n- class A{\nint a;\nvoid f(int);\nvoid g(int);\nvoid h(int);\n};\n\nclass B{\nint b;\nvoid g();\n};\n\nclass C:A,B\n{\nint c;\nvoid h();\n};\n\n--------- <---A*,C*\n| a:int |\n--------- <--- B*\n| b:int |\n---------\n| c:int |\n---------\n</c>\n\n$ cat main.cpp\n<c>\n#include <iostream>\nusing namespace std;\n\nstruct A{\nint a;\nvoid f();\nvoid g();\nvoid h();\n};\n\nstruct B{\nint b;\nvoid g();\n};\n\nstruct C:A,B{\nint c;\nvoid h();\n};\n\nint main(){\nC* c=new C;\ncout<<"C* "<<c<<endl;\ncout<<"B* "<<dynamic_cast<B*>(c)<<endl;\ncout<<"A* "<<dynamic_cast<A*>(c)<<endl;\ncout<<"int a "<<&c->a<<endl;\ncout<<"int b "<<&c->b<<endl;\ncout<<"int c "<<&c->c<<endl;\nreturn 0;\n}\n$ ./a.out\nC* 0x176fe010\nB* 0x176fe014\nA* 0x176fe010\nint a 0x176fe010\nint b 0x176fe014\nint c 0x176fe018\n\n----------- <----A*,C* (0x176fe010)\n| a:int   | (0x176fe010)\n----------- <----B*(0x176fe014)\n| b:int   | (0x176fe014)\n-----------\n| c:int   | (0x176fe018)\n-----------\n</c>\n\n<h>\n*Vtable\n</h>\n\n- virtual methods are arranged in a separate table(vtable).\n- Object layout carries a vptr to the vtable.\n- vptr are first field in object layout\n\n<c>\nclass A{\nvirtual func();\nint a;\n};\n\nObject layout           vtble\n-------------         ---------------\n|  vptr     | ------->|  &A::func() |\n-------------         ---------------\n|  a:int    |\n-------------\n</c>\n\n<h>\n*Vtable with virtual methods with SI and MI\n</h>\n\n- SI\nvtable of base class gets merged to derived class vtable.\n\n- MI\nvtable of secondary base class are different than derived or primary base class.\nBase class functions are called with base class this pointer not the actual object pointer\n\n<c>\nclass A{\nint a;\nvirtual void f(int);\nvirtual void g(int);\nvirtual void h(int);\n};\nclass B:A{\nint b;\nvoid g();\n};\nclass C:B{\nint c:\nvoid h();\n};\n\n\n--------- <---A*,B*,C*\n| a:int | vtble  ------------\n| vptr  |--------|  A:f(int)|\n---------        |  B:g(int)|\n| b:int |        |  C:h(int)|\n---------        ------------\n| c:int |\n---------\n\nC *pc;\npc->g(2);\n(*(pc->vptr[1]))(pc,2);\nclass C:A,B{int c:void h();};\n\n--------- <-- A*,C*----------\n| a:int | --------| A::f(int);\n| vptr  |         | C::h(int);\n--------- <-- B*  ------------\n| b:int |\n---------\n| c:int |\n---------\n\nC* pc;\nB* pb;\npb = (B*)pc; // pb = (B*)((char*)pc+delta(B))\npb = pc; // pb = (B*)((char*)pc+delta(B))\npc = pb; // error: cast needed\npc = (C*)pb; // pc = (C*)((char*)pb-delta(B))\n\n\n-delta storage.\nclass A{virtual void f();};\nclass B{virtual void f(); virtual void g();};\nclass C:A , B{void f();};\nA* pa=new C;\nB* pb=new C;\nC* pc=new C;\npa->f();\npb->f();\npc->f();\n</c>\n\nIn order to fix this pointer when calling the base class function in context of derived class object detla mechanism is used.\n\nIn order to shift top to pb* place delta(B) is calculated at compile time.\n\nIn order to have it at run time it is stored in vtable where function entry is a structure itself with first field is a function pointer and second field as delta(B).\n\n<c>\nstruct vtbl_entry{\nvoid  (*fct)();\nint delta;\n};\n\n-------------  vtbl    -------------\n|  vtpr     | -------> | &C::f()| 0 |\n| A part    |          -------------\n-------------\n|           | vtbl    ----------------------\n| vptr      | ------> | &C::f()| - delta(B)|\n| B part    |         ----------------------\n-------------         | &B::g()| 0 |\n|           |         --------------\n| C part    |\n-------------\n\n\nB* pb=new C;\npb->f();\n// register vtbl_entry* vt=&pb->vtbl[index(f)];\n// (*vt->fct)((B*)((char*)pb+vt->delta))\n                    ^\n                    |\n                    +--------- New this pointer\n</c>\n\n<h>\n*Virtual base class\n</h>\n\n- virtual base\n<c>\nclass W {\n virtual void f();\n virtual void g();\n virtual void h();\n virtual void k();\n};\nclass AW:virtual W{ void g();...};\nclass BW:virtual W{ void f();...};\nclass CW:AW, BW { void h();....};\nCW* pcw=new CW;\npcw->f();  //BW::f()\npcw->g();  /AW::g()\npcw->h();  //CW::h()\n((AW*)pcw)->f();   /BW::f();\n\n\n          -----------------\n......... |\n.         | AW part |\nv         |         |\n.         -----------------\n......... |\n.         | BW part |\nv         |         |\n.         -----------------\n.         |         |\n.         | CW part |\nv         |         |        vtbl:\n.         ----------------- ------------------------------\n...>      | vptr ..........>| BW::f | delta(BW)-delta(W) |\n          |         |       | AW::g | -delta(W) |\n          | W part  |       | CW::h | -delta(W) |\n          |         |       | W::k  | 0         |\n          ----------------- ------------------------------\n\n\n\n....> W { f g h k } <...\n|          |\n\n|          |\nAW { g }          BW { f }\n|          |\n\n|          |\n...<... CW { h } ...>...\n</c>\n\nNote that a call \'\'up\'\' through one path of the DAG to a virtual function may result in the call of a function (re-defined) in another path (as happened in the call ((AW*)pcw)->f() in the example above).\n\n<h>\n*Thunk based and Offset based object model\n</h>\n\n-Thunk based object model, vtable entry is not two field structures instead it is has function pointer to virtual function. vtable of base class contains thunk entries for functions which is overridden by derived class. Aduster thunk actually adjust the this pointer first then call the function in unsimilar to offset based approach where base class function entry from the vtable was called with adjusted this pointer.\n\n<h>\n*Thunk based and offset based object model\n</h>\n\n<c>\nstruct P {\nint p1;\nvirtual void pvf();\n};\nstruct R {\nint r1;\nvirtual void pvf(); // new\nvirtual void rvf(); // new\n};\nstruct S : P, R {\nint s1;\nvoid pvf(); // overrides P::pvf and R::pvf\nvoid rvf(); // overrides R::rvf\nvoid svf(); // new\n};\n\n\nR*\n----->  --------------      --------------\n        | R::vfptr   |----->| &R::pvf    |\n        --------------      --------------\n        | R::r1      |      | &R::rvf    |\n        --------------      --------------\n\n\nP*, S*\n-----> --------------      --------------\n       | P::vfptr  -|----->|  &S::pvf   |\n       --------------      --------------\n       | P::p1      |\n       --------------      --------------\nR*---> | R::vfptr   |----> | &thunk1    |\n       --------------      --------------\n       | R::r1      |      | &S::rvf    |\n       --------------      --------------\n       | S::s1      |\n       --------------\n\n       thunk1: this == SdPR; goto S::pvf\n</c>'
'9!ABS SBA!Inheritance!ABS SBA!*Write multiple inheritance class!ABS SBA!<h>\n*Base class and drive class\n</h>\n\n- Base class\nClass from which another class inherits. The members of the base class become members of the derived class.\n\n\n- Derived class\nA class inherits from another class. Member of the base class are also members of the derived class. Parent attributes and methods can be called in Derived class context. Base class object comes inside of derive class\nobject.\n\n<c>\nstruct A:B{\n};\nA *, B* --> +-------------+\n            |   B::b:int  |\n            ---------------\n            |   A::a:int  |\n            +-------------+\n</c>\n\nA derived class can redefine the members of its base (function overriding) and can define new members. A derived-class scope is nested in the scope of its base class, so the derived class can access members of the base class\ndirectly.\n\n- Inheritance allows us to define a class in terms of another class, which makes it easier to create and maintain an application.\n- This also provides an opportunity to reuse the code functionality and fast implementation time.\n- When creating a class, instead of writing completely new data members and member functions, the programmer can designate that the new class should inherit the members of an existing class. This existing class is called the base class, and the new class is referred to as the derived class.\n- The idea of inheritance implements the is a relationship. For example,\nmammal IS-A animal, dog IS-A mammal hence dog IS-A animal.\n\n- A class can be derived from more than one classes, which means it can inherit data and functions from multiple base classes.  class derived-class: access-specifier base-class\n\n<c>\nAccess                public  protected  private\nSame class            yes     yes        yes\nDerived classes       yes     yes        no\nOutside classes       yes     no         no\n</c>\n\n- A derived class inherits all base class methods with following exceptions:\nConstructors, destructors and copy constructors of the base class.\nOverloaded operators of the base class.\nThe friend functions of the base class.\n\n<h>\n*Virtual methods\n</h>\n\n- A member function that defines type-specific behaviour. Calls to a virtual made through a reference or pointer are resolved at run time, based on the type of the object to which the reference or pointer is bound.\n\n<h>\n*Pure virtual methods\n</h>\n\n- A virtual function declared in the class header using =0 at the end of the function\'s parameter list.  A pure virtual is one that need not be (but may be) defined by the class. A class with a pure virtual is an abstract class. If a derived class does not define its own version of an inherited pure virtual, then the derived class is abstract as well.\n\n<h>\n* Changing scope of base member in derived classes\n</h>\n\n\n<c>\npublic      protected   private (inheritance type)\n\npublic     public      protected   private\nprotected  protected   protected   private\nprivate    private     private     private\n  ^\n  |\n  |\n  +----dbase class access control\n</c>\n\n<h>\n*Multiple inheritance\n</h>\n\n- Inheritance in which a class has more than one immediate base class.\nThe derived class inherits the members of all its base classes. Multiple base classes are defined by naming more than one base class in the class derivation list. A separate access label is required for each base class.\n\n- Multiple inheritance is useful when an entity carries multiple identity.\nMultiple type of task can be performed on the same object.  A multi homed computer can be a router or a server.\n\n<c>\n-----------                 ------------\n|  server |                 | router   |\n-----------                 ------------\n    /\\                          / \\\n     -                            -\n     |                            |\n     +----------------------------+\n                    |\n             --------------\n             | machine    |\n             --------------\n\nclass A{}\nclass B{}\nclass C:A,B{};\n---------- <-- A*, C*\n| A Part |\n---------- <-- B*\n| B Part |\n----------\n| C Part |\n----------\n\nC* pc;\npc->bg(2);//bg is class B function\nbg_F1B((B*)((char*)pc+delta(B)),2);\n</c>\n\n<h>\n*Polymorphism\n</h>\n\n- Polymorphism means "many forms". It refers to obtain type specific behaviour based on the dynamic type of a reference or pointer.\n\nIn inheritance base class shows polymorphic behaviour. Base class pointer accept down the line derived class concrete objects.\n\n<c>\n                                          f()\n                                       <|---- B\n                            A  <|----- |      <|------ D\n                            f()        <|---- C        f(),g()\n                                          g()\n\nvoid func(A* pa){  <--- A* is polymorphic and accepts object of derived class B,C,D\npa->f();// always bound to base A::f(). A::f() is not polymorphic\nfunc(new B);\nfunc(new C);\nfunc(new D);\n</c>\n\nWhen a function in base class is virtual then function becomes polymorphic\n<c>\n                                      virtual f()\n                                       <|---- B\n                            A  <|----- |      <|------ D\n                    virtual f()        <|---- C        f(),g()\n                                      Virtual g()\n\nvoid func(A* pa){\nps->f();// polymorphic\n}\nfunc(new B);//pa->f() calls B::f()\nfunc(new D);// pa->f() calls D::f()\n</c>\n\n<h>\n*Friend function and friend class\n</h>\n\n- Friend function and friend class does not follow inheritance rule and class A friend to class B will not be friend to class C that is either parent or derived from class B.\n\n<h>\n*Function overriding\n</h>\n\n- If base class function(non virtual) is also defined in device class, derive class function override the base class function.\n\n- No polymorphism in case of overriding. Base class function call through base class pointer always resolves to base class function only.\n\n<h>\n*Function overloading and default parameter\n</h>\n\n- Function overloading and default parameter does not support polymorphism.\n<c>\n$ cat main.cpp\n#include <iostream>\nusing namespace std;\nstruct A{\nvirtual void func(int x){\ncout<<"A::func"<<endl;\n}\n};\nstruct B:A{\nvoid func(float y){\ncout<<"B::func"<<endl;\n}\n};\n\nint main(){\nA* pa=new B;\npa->func(10); // resolves to A::func\nreturn 0;\n}\n</c>\n\n$ ./a.out\n<c>\nA::func\n</c>\n\n<h>\n*Interface and Implementation inheritance\n</h>\n\n-A publicly derived class inherits the interface of its base class. It has the same interface as its base class. In well designed class hierarchies object of a publicly derived class can be used wherever an object of the base\nclass is expected.\nClasses derived using protected or private inheritance do not inherit the base class interface. Instead these derivations are often referred to as implementation inheritance. The derived class uses the inherited class in its implementation but does not expose the fact of the inheritance as part of its interface..\n\n$ cat main.cpp\n<c>\n#include <iostream>\nusing namespace std;\nclass A{\npublic:\nint pl;\nprivate:\nint pr;\n};\nclass B:private A{ //implementation inheritance\npublic:\nusing A::pl; //still pl can be accessible\nB(){pl=20;}\n//using A::pr;//error\nprivate:\n//using A::pr;//error\n};\nint main(){\nB b;\ncout<<"B::pl"<<b.pl<<endl;\nreturn 0;\n}\n</c>\n\n$ ./a.out\n<c>\nB::pl20\n</c>'
'10!ABS SBA!Generic Programming!ABS SBA!*Use Iostream iterator!ABS SBA!<h>\n*What is generic programming\n</h>\n\nRather than each container class provide methods, a library provide methods that works on all sequential and associative containers.\n\n- include <algorithm>\n- include <numeric>\n\nFunctions available sort, find, accumulate, find_first_of, fill etc.\n\n<h>\n*Iterator vs pointer\n</h>\n\nGeneric algorithms function takes both iterator and pointers as argument.\nIterator have pointer operator overloaded.\n\n<c>\nint search_value=42;\nvector<int>::const_iterator result=find(vec.begin(),vec.end(),search_value);\ncout<<"The value" << search_value\n<< (result == vec.end() ? " not present " : " is present ") << endl;\nlist<int>::const_iterator result=find(lst.begin((),lst.end(),search_value);\n\nint ia[6] = {27,210, 12, 47, 109, 83 };\nint search_value=83;\nint *result=find(ia,ia+6,search_value);\ncout<<"The value"<<search_value\n<<(result == ia+6  ? "is not present" : "is present")<<endl;\n</c>\n\n<h>\n*Read only and write to container algorithms\n</h>\n\nread-only algorithms are only to read from the container and can not write to the container.\n\n<c>\nfind();\naccumulate();\n\nint sum=accumulate(vec.begin(),vec.end(),42); // 42\n               specifies initial value and int type\nstring sum=accumulate(v.begin(),v.end(),string("")); //\n                string("") specifies string type\n</c>\n\nThere are few algorithms which writes to the container.\n\n<h>\n*Five iterator categories\n</h>\n\nThere are five iterator categories.\n1)Input iterator - read, but not write, increment only\n2)Output iterator - write but not read; increment only\n3)forward iterator - read and write; increment ony\n4)bidirectional iterator - read and write; increment and decreament\n5)random access iteratot - read and write; full iterarot arithmetic\n\n\n<h>\n*Insert iterators\n</h>\n\nGeneric algorithms does not change the container size. It is generic in\nthe sense it takes iterator of any type and then calls generic functions\non the iterator. It is an iterator which modifies the container\n\nThese iterator are bound to a container and can be used to insert elements\nto the container.\n\nTwo types of inserter back_inserter and front_inserter.\n\n\n<c>\n----------------------      -----------------  push_back ----------- to -------------\n| Generic algoritms | ----> | back_inserter |   o------  |iterator |--->| container |\n| ex. fill_n        |       -----------------            -----------    -------------\n----------------------\n\nvector<int> vec;\nfill_n(ack_inserter(vec),10,0); // appends 10 elements to vec\n\ncopy(lst.begin(),lst.end(),back_inserter(vec));\n</c>\n\n<h>\n*Iostream iterator\n</h>\n\nostream_iterators are used to write a sequence of value to a stream in much the same way that we might use and iterator to assign a sequence of values to the elements of a container.\n\n<c>\nostream_iterator<string> out_iter(cout,"\n");\nistream_iterator<string> in_iter(cin),eof;\nwhile(in_iter != eof)\n*out_iter++ = *in_iter++;\n</c>\n\n\nLimitations of steam iterators\n- It is not possible to read from an ostream_iterator and it not possible to write to an istream_iterator.\n- Once we assign a value to an ostream_iterator, the write is committed\n- There is no -> operator for ostream-iterator\n\nSorting input from console\n<c>\nistream_iterator<int. cin_it(cin);\nistream_iterator<int> end_of_stream;\nvector<int>(cin_it,end_of_stream);\nsort(vec.begin((),vec.end9));\nostream_iterator<int> output(cout, " ");\nunique_copy(vec.begin(),vec.end(),output);\n</c>'
'11!ABS SBA!Operator overloading!ABS SBA!*Impement prefix and postfix operator!ABS SBA!<h>\n* Basics of operator overloading\n</h>\n\n- Its possible to overload operator and making it a member function.\n- operator can be called in expression way or like a member function\n\n<c>\n#include <iostream>\nusing namespace std;\nclass mystring {\npublic:\nmystring(const mystring& str) {\n_val=str._val;\n}\nmystring(const char* val) {\n_val=val;\n}\nmystring& operator+=(const mystring& val) {\n_val=_val+val._val;\nreturn *this;\n}\nconst string& val() {\nreturn _val;\n}\nprivate:\nstring _val;\n};\nmystring operator+(const mystring& left, const mystring& right) {\nmystring tempstr(left);\ntempstr+=right;\nreturn tempstr;\n}\nint main(int argc, char *argv[]) {\nmystring item="one";\nitem=item+"two";\nitem.operator+=("three");\ncout<<"item : "<<item.val().c_str()<<endl;\nreturn 0;\n}\n</c>\n\n - It makes classes object support operators and can be used in expression.\n- operator to overload\n\n+\t-\t*\t/\t%\t^\n&\t|\t~\t!\t,\t=\n<\t>\t<=\t>=\t++\t--\n<<\t>>\t==\t!=\t&&\t||\n+=\t-=\t/=\t%=\t^=\t&=\n|=\t*=\t<<=\t>>=\t[]\t()\n->\t->*\tnew\tnew []\tdelete\tdelete []\n\n- operators that cannot be overloaded\n   ::\t.*\t.\t?:\n\n- Precautions\n - Overloaded Operators mush have an operand of Class Type\n<c>\n    int operator+(int, int); // error int not class type\n</c>\n - Precedence and Associativity are Fixed\n    x == y+z; // y+z would happen first followed by left to right associativity\n - Take care when overloading short circuit evaluation.\n    & | && || ,\n- Operator\n\n<h>\n*Overloading as method and non member function\n</h>\n\n- Two kinds of operator overloading\n- As member function\n  - The assignment(=), subscript ( [] ), call ( () ), and member access arrow (->)\n  operators must be defined as members. Defining any of these operations as a\n  nonmember function is flagged at compile time as an error.\n  - Like = operator, compound assignment operators (+=, -=, *=, /=) ordinary\n  ought to be members of the class. If not there then compiler will not generate\n  any error if defined as non members.\n  - Other operators that change the state of their object or that are closely tied\n  to their given type - such as increment, decrement , and dereference -\n  usually should be members of the class.\n  - Operator returning lvalue\n- As friend function or non member function\n  - Symmetric operators, such as the arithmetic, equality, relational , and\n  bitwise operators, are better defined as ordinary nonmember functions.\n  - Operator return r-value better fits as non member. i.e. + operator.\n\n\n<h>\n*Overloading binary operator\n</h>\n\n- Generally binary operators are non-member functions.\n<c>\nclassA operator+(const classA &lhs, const classA &rhs);\nclassA operator-(const classA &lhs, const classA &rhs);\nclassA operator*(const classA &lhs, const classA &rhs);\nclassA operator/(const classA &lhs, const classA &rhs);\n\ninline bool operator==(const classA &lhs, const classA &rhs);\ninline bool operator!=(const classA &lhs, const classA &rhs);\n\n#include <iostream>\nusing namespace std;\nclass Box{\ndouble length;\ndouble breadth;\ndouble height;\npublic:\nBox(int l=0,int b=0, int h=0):length(l),breadth(b),height(h){}\ndouble volume(void){\nreturn length * breadth * height;\n}\nBox operator+(const Box& b){\nBox box;\nbox.length = this->length + b.length;\nbox.breadth = this->breadth + b.breadth;\nbox.height = this->height + b.height;\nreturn box;\n}\n};\nint main( ){\nBox box1(10, 5, 2);\nBox box2(4, 10, 4);\nBox box3;\ncout << "Volume of Box1 : " << box1.volume() <<endl;\ncout << "Volume of Box2 : " << box2.volume() <<endl;\nbox3 = box1 + box2;\ncout << "Volume of Box3 : " << box3.volume() <<endl;\nreturn 0;\n}\n</c>\n\nExercise - implement through += operator.\n\n<h>\n*Overloading relational and logical operator\n</h>\n\n- There are various relational operators supported by C++ language like (<, >, <=, >=, ==, etc.) which can be used to compare C++ built-in data types.\n\n<c>\n#include <iostream>\nusing namespace std;\nclass Distance {\nint feet;\nint inches;\npublic:\nDistance(int f=0, int i=0) {\nfeet = f;\ninches = f;\n}\nfriend bool operator <(const Distance& dl, const Distance &dr);\n};\nbool operator <(const Distance& dl, const Distance &dr) {\nif(dl.feet < dr.feet) {\nreturn true;\n}\nif(dl.feet == dr.feet && dl.inches < dr.inches) {\nreturn true;\n}\nreturn false;\n}\nint main()\n{\nDistance d1(11, 10), d2(5, 11);\nif( d1 < d2 )   {\ncout << "d1 is less than d2 " << endl;\n}   else   {\ncout << "d2 is less than d1 " << endl;\n}\nreturn 0;\n}\n</c>\n\n<h>\n*Overloading unary operator\n</h>\n\n- The unary operators operate on a single operand.\n  - The increment (++) and decrement (--) operators.\n  - The unary minus (-) operator.\n  - The logical not (!) operator.\n\n\n- This operator appears on the left side of the object, as in !obj, -obj, and ++obj but sometime they can be used as postfix as well like obj++ or obj--.\n\n<c>\n#include<iostream>\nusing namespace std;\nclass Distance{\nprivate:\nint feet;\nint inches;\npublic:\nDistance(int f=0,int i=0){\nfeet = f;\ninches = i;\n}\nint gfeet() {\nreturn feet;\n}\nint ginches() {\nreturn inches;\n}\nDistance(const Distance& d) {\nfeet=d.feet;\ninches=d.inches;\n}\nDistance operator- ()\n{\nfeet = -feet;\ninches = -inches;\nreturn Distance(feet, inches);\n}\nDistance& operator++() {\nif(++inches == 12) {\ninches=0;\n++feet;\n}\nreturn *this;\n}\n\nDistance operator++(int) {\nDistance d(*this);\n++*this;\nreturn d;\n}\n};\nint main()\n{\nDistance d1(11, 10), d2(-5, 11);\n-d1;\ncout<<"feet : inches "<<d1.gfeet()<<" : "<<d1.ginches()<<endl;\n-d2;\ncout<<"feet : inches "<<d2.gfeet()<<" : "<<d2.ginches()<<endl;\nd1.operator++(0);\ncout<<"feet : inches "<<d1.gfeet()<<" : "<<d1.ginches()<<endl;\nd2.operator++();\ncout<<"feet : inches "<<d2.gfeet()<<" : "<<d2.ginches()<<endl;\nreturn 0;\n}\n</c>\n\n<h>\n*Overloading assignment operator\n</h>\n\n- Assignment operator can be of non class type.\n- Assignment operator can be compound type.\n\n<c>\n#include <iostream>\nusing namespace std;\nclass classA {\npublic:\nclassA(){\n_data="";\n}\nclassA(const classA& c) {\ncout<<"copy constructor"<<endl;\n}\n\nclassA& operator=(const char* cp) {\ncout<<"char pointer"<<endl;\n_data+=cp;\nreturn *this;\n}\nclassA& operator=(const string& cs) {\ncout<<"constant string"<<endl;\n_data+=cs;\nreturn *this;\n}\nclassA& operator=(char c) {\ncout<<"char"<<endl;\n_data+=c;\nreturn *this;\n}\nclassA& operator+=(const classA& rhs) {\n_data+=rhs._data;\nreturn *this;\n}\nstring& data() {\nreturn _data;\n}\nprivate:\nstring _data;\n};\nint main() {\nclassA cls;\ncls = "one";\ncls = string(":two");\ncls=\':\';\nclassA rhs;\nrhs="three";\ncls+=rhs;\ncout<<"cls data : "<<cls.data()<<endl;\nreturn 0;\n}\n}\n</c>\n\n<h>\n*Overloading [] operator\n</h>\n\n- Classes that represent containers from which individual elements can be retrieved usually define the subscript operator, operator[];\n- Subscript operator can be used to provide lvalue and rvalue;\n\n<c>\nint &const[](const size_t);\nconst int &operator[](const size_t) const;\n\n#include <iostream>\nusing namespace std;\nclass classA {\npublic:\nclassA(){\n_data="";\n}\nclassA(const classA& c) {\ncout<<"copy constructor"<<endl;\n}\nclassA& operator=(const char* cp) {\ncout<<"char pointer"<<endl;\n_data+=cp;\nreturn *this;\n}\nclassA& operator=(const string& cs) {\ncout<<"constant string"<<endl;\n_data+=cs;\nreturn *this;\n}\nclassA& operator=(char c) {\ncout<<"char"<<endl;\n_data+=c;\nreturn *this;\n}\nclassA& operator+=(const classA& rhs) {\n_data+=rhs._data;\nreturn *this;\n}\nstring& data() {\nreturn _data;\n}\nprivate:\nstring _data;\n};\nint main() {\nclassA cls;\ncls = "one";\ncls = string(":two");\ncls=\':\';\nclassA rhs;\nrhs="three";\ncls+=rhs;\ncout<<"cls data : "<<cls.data()<<endl;\nreturn 0;\n}\n</c>\n\n<h>\n* Creating a conversion function\n</h>\n\n - A conversion operator defines a conversion that converts a value of a class type to some other type.\n\n<c>\n#include <iostream>\n#include <stdexcept>\nusing namespace std;\nclass classA {\npublic:\nclassA(int i=0):_val(i) {\nif(i<0 || i>255)\nthrow out_of_range("Bad classA initializer");\n}\noperator int() const {return _val;}\nprivate:\nstd::size_t _val;\n};\nint main() {\nclassA *cls;\ntry {\ncls=new classA(10);\n}\ncatch(const exception& e) {\ncout<<"exception cought : "<<e.what()<<endl;\nreturn -1;\n}\ncout<<" cls value : "<<*cls;\ndelete cls;\nreturn 0;\n}\n</c>\n\n<h>\n* Conversion & class types\n</h>\n\n<c>\nusing namespace std;\nclass classA {\npublic:\nclassA(int i=0) {\n_val=i;\n}\noperator int() const {\nreturn _val;\n}\nprivate:\nsize_t _val;\n};\nclass classB {\npublic:\nclassB(int i=0) {\n_val=i;\n}\noperator classA() const {return _val%256;}\nprivate:\nsize_t _val;\n};\nvoid calc(int i) {\ncout<<"calc(int) : "<<i;\n}\n\nint main() {\nclassB intval(1);\nclassA cls(intval);\ncalc(cls);\n//calc(intval);\nreturn 0;\n}\n</c>'
'12!ABS SBA!Templates!ABS SBA!*write specialized template for adding any two\n entities!ABS SBA!<h>\n*Generic class\n</h>\n\n- Templates are the foundations of generic programming, which involves writing code in a way that is independent of any particular type.\n- A template is a blueprint or formula for creating a generic class or a function. The library containers like iterators and algorithms are examples of generic programming and have been developed using template concept.\n- There is a single definition of each container, such as vector, but we can define many different kinds of vectors for example, vector <int> or vector <string>.\n- Templates can be used to define functions as well as classes\n\n\n<h>\n*Class template\n</h>\n\n - The general form of a generic class declaration is shown here:\ntemplate <class type> class class-name {\n.\n.\n.\n}\n\n- Here, type is the placeholder type name, which will be specified when a class is instantiated. You can define more than one generic data type by using a comma-separated list.\n\n<c>\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <string>\n#include <stdexcept>\nusing namespace std;\ntemplate <class T>\nclass Stack {\nprivate:\nvector<T> elems;     // elements\npublic:\nvoid push(T const&);  // push element\nvoid pop();               // pop element\nT top() const;            // return top element\nbool empty() const{       // return true if empty.\nreturn elems.empty();\n}\n};\ntemplate <class T>\nvoid Stack<T>::push (T const& elem) {\nelems.push_back(elem);\n}\ntemplate <class T>\nvoid Stack<T>::pop () {\nif (elems.empty()) {\nthrow out_of_range("Stack<>::pop(): empty stack");\n}\nelems.pop_back();\n}\ntemplate <class T>\nT Stack<T>::top () const {\nif (elems.empty()) {\nthrow out_of_range("Stack<>::top(): empty stack");\n}\nreturn elems.back();\n}\nint main() {\ntry {\nStack<int>         intStack;  // stack of ints\nStack<string> stringStack;    // stack of strings\nintStack.push(7);\ncout << intStack.top() <<endl;\nstringStack.push("hello");\ncout << stringStack.top() << std::endl;\nstringStack.pop();\nstringStack.pop();\n}\ncatch (exception const& ex) {\ncerr << "Exception: " << ex.what() <<endl;\nreturn -1;\n}\n}\n</c>\n\n- The general form of a template function definition is as following\n\ntemplate <class type> ret-type func-name(parameter list)\n<c>\n{\n// body of function\n}\ntemplate <typename T>\ninline T const& Max (T const& a, T const& b)\n{\nreturn a < b ? b:a;\n}\n</c>\n\n- Function templates parameters can be type parameter and non type parameter\n- Type name string can be typename or class, it can be used interchangeably\n\n<c>\ntemplate<class A, class U>\nA func(A* array, U value) {\nA::size_type *p; // misleading, if typename then p is declaration otherwise multiplication\n}\n\ntemplate<class A, class U>\nA func(A *array, U value) {\ntypename A::size_type *p;\n}\n\n#include <iostream>\n#include <string>\nusing namespace std;\ntemplate <typename T>\ninline T const& Max (T const& a, T const& b)\n{\nreturn a < b ? b:a;\n}\nint main ()\n{\nint i = 39;\nint j = 20;\ncout << "Max(i, j): " << Max(i, j) << endl;\ndouble f1 = 13.5;\ndouble f2 = 20.7;\ncout << "Max(f1, f2): " << Max(f1, f2) << endl;\nstring s1 = "Hello";\nstring s2 = "World";\ncout << "Max(s1, s2): " << Max(s1, s2) << endl;\nreturn 0;\n}\n</c>\n\n<h>\n*Template argument deduction\n</h>\n\n-The process of determining the types and values of the template arguments from the type of the function argument is called template argument deduction.\n-If a template type is used as the type of more than one function parameter template type deduction must generate the same template argument type for each corresponding function argument.\n\n<c>\ntemplate <typenaem T>\nint compare (const T& v1, const T& v2){\nif(v1 < v2) return -1;\nif(v2<v1) retrun 1;\nreturn 0;\n}\nshort si;\ncompare(si,1024);//error\n</c>\n\n- Limited conversions on type parameter arguments\nArguments are not converted to match an existing instantiations, instead a new instance is generated.\n\n- In two cases new instance would not be generated\n> const conversion: A function that takes a reference or pointer to a const can be called with reference or pointer to non const object respectively with generating a new instantiation.\n> array or function to pointer conversions: if the template parameter is not a reference type then normal pointer conversion will be applied to argument of array or function type.\n\n-Template argument deduction and function pointer\n\n<c>\ntemplate<typename T>int compare(const T&, const T&);\nint (*pf1)(const int&, const int&) = compare;\n</c>\n\n<h>\n*Function template explicit arguments\n</h>\n\n- When template function returns a type that differs from any used in the parameter it is required to override the template argument deduction mechanism and explicitly specify the types or values to be used for the template parameters.\n<c>\ntemplate<class T1, class T2, class T3> T1 sum(T2,T3);\nlong val3=sum<long(i,lng);\nlong val3=sum<long,int,long>(i,lng);\n</c>\n\n<h>\n* Function template friend function and class\n</h>\n\n- There are three scenarios when friends appear to a template class or template function.\n> A friend declaration for an ordinary non template class of function, which grants friendship to the specific named class of function.\n\n<c>\ntemplate <class type> class Bar{\n friend class A;\n friend void fcn();\n};\n</c>\n\n> A friend declaration for a class template or function template, which grants access to all instances of the friend.\n\n<c>\ntemplate<class type> class Bar{\ntemplate <class T> friend class Fool;\ntemplate <class T> friend void templ_frnl(const T&);\n};\n</c>\n\n> A friend declaration that grants access only to a specific instance of a class or function template.\n\n<c>\ntemplate <class T> class Foo2;\ntemplate <class T> void templ_func2(const T&);\ntemplate <class Type> class Bar{\nfriend class Foo2<char*>;\nfrind void templ_fnc2<char*>(char* const &);\n};\n</c>\n\n<h>\n*Specialization\n</h>\n\nRedefinition of a class template or a member of a class template in which the template parameters are specified.\n\n<c>\ntemplate<> int compare(const char*>(const char* const&, const char* const&);\n</c>\n\n- Difference in template specialization and normal function overloading is template type does not do type conversion (short to int to float etc..), if different types are there then new template instantiation happens.\n\n- A program can not have both the explicit specialization and an instantiation for the same template with the same set of template arguments.\n\n<c>\nclass template specialization\ntemplate<> class A<const char*> {\npublic:\n void push(const char*);\n ...\n};\n\nvoid A<const char*>::push(const char* val){\n...\n}\nSpecializing members but not the class\ntemplate<> void A(const char*>::push(const char *const& val){\n...\n}\n</c>\n\n<h>\n* Template bloating\n</h>\n\n- Template bloat occurs when compilers generate code for all templated function in each translation unit that use them. It should be resolved at link time though. New compilers does that.\n\n\n<h>\n*Sequential standard template libraries\n</h>\n\n- A type that holds an ordered collection of objects of a single type.  Elements in a sequential container are accessed by position. i.e <c>std::list std::vector std::deque</c>\n\n\n<h>\n*Associative standard template libraries\n</h>\n\n- A type that holds a collection of objects that supports efficient lookup by key. i.e. <c>std::set, set::map,, std::multiset, std::multimap</c>'
'13!ABS SBA!Exception handling!ABS SBA!*Use object slicing to get base class\nexception object from derived object!ABS SBA!<h>\n*Resumption and termination\n</h>\n\n- An exception is a problem that arises during the execution of a program.  A C++ exception is a response to an exceptional circumstance that arises while a program is running, such as an attempt to divide by zero.\n- Exceptions provide a way to transfer control from one part of a program to another. C++ exception handling is built upon three keywords: try, catch, and throw.\n - throw: A program throws an exception when a problem shows up. This is done using a throw keyword.\n - catch: A program catches an exception with an exception handler at the place in a program where you want to handle the problem. The catch keyword indicates the catching of an exception.\n - try: A try block identifies a block of code for which particular exceptions will be activated. It\'s followed by one or more catch blocks.\n\n - Assuming a block will raise an exception, a method catches an exception using a combination of the try and catch keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code.\n\n<c>\ntry\n{\n   // protected code\n}\ncatch( ExceptionName e1 ) {\n   // catch block\n}\ncatch( ExceptionName e2 ) {\n   // catch block\n}\ncatch( ExceptionName eN ) {\n   // catch block\n}\n</c>\n\n\nIf an exception is not caught by any catch statement because there is no\ncatch statement with a matching type, the special function terminate will\nbe called.\n\n<h>\n*Stack unwinding\n</h>\n\n- The process known as stack unwinding continues up the chain of nested function calls until a catch clause for the exception is found.\n- During stack unwinding the function containing the throw and possibly other functions  in the call chain are exited prematurely.\n- During stack unwinding destructors are called against local objects.\n- Do not throw exception in destructor as there would be multiple throws to catch and would miss the genuine exception raised and may end in calling terminate function.\n\n<h>\n*Throwing and catching exception\n</h>\n\nThrowing Exceptions:\nExceptions can be thrown anywhere within a code block using throw statements. The operand of the throw statements determines a type for the exception and can be any expression and the type of the result of the expression determines the type of exception thrown.\n\n<c>\ndouble division(int a, int b) {\nif( b == 0 ) {\nthrow "Division by zero condition!";\n}\nreturn (a/b);\n}\n</c>\n\nCatching Exceptions\nThe catch block following the try block catches any exception.\n<c>\ntry  {\n  // protected code\n}\ncatch( ExceptionName e )  {\n// code to handle ExceptionName exception\n}\n</c>\n\n- Above code will catch an exception of ExceptionName type.\n- catch block should handle any type of exception that is thrown in a try block,\nan ellipsis, ..., between the parentheses enclosing the exception declaration.\n\n<c>\ntry\n{\n   // protected code\n}catch(...)\n{\n  // code to handle any exception\n}\n\n#include <iostream>\nusing namespace std;\n\ndouble division(int a, int b)\n{\nif( b == 0 )\n{\nthrow "Division by zero condition!";\n}\nreturn (a/b);\n}\n\nint main ()\n{\nint x = 50;\nint y = 0;\ndouble z = 0;\ntry {\nz = division(x, y);\ncout << z << endl;\n}catch (const char* msg) {\ncerr << msg << endl;\n}\n\nreturn 0;\n}\n</c>\n\n<h>\n*Polymorphism\n</h>\n\nException thrown can be caught through parent class reference.\n\n<h>\n*set_terminate function\n</h>\n\nIf an exception is not caught by any catch statement because there is no catch statement with a matching type, the special function terminate will be called.\n\n<h>\n*Function try block and exception.\n</h>\n\nTo handle an exception from the constructor initializer, we must write the constructor as a function try block.\n\n<c>\ntemplate <class T> Handle<T>::Handle(T *p)\ntry : ptr(p),use(new size_t(1))\n{\n}catch(const std::bad_alloc &e)\n{ handle_out_of_memor(e);}\n</c>\n\n- function try precedes the member initialization\n- the catch clause can handle exceptions thrown either from within the member initialization list or from within the constructor body.\n\n\n<h>\n*Exception specification\n</h>\n\nException specification follows the function parameter list.\n\n<c>\nvoid recoup(int) throw(runtime_error); // throws only runtime_error\nvoid recoup(int) throw(); // does not throw any exception\n</c>\n\n- Derive class functions should be more restrictive in specification\n\n<c>\nstruct base {\nvirtual std::string f3() throw(std::logic_error,std::runtime_error);\n};\nstruct derived:base{\nstd::string f3() throw();//more restrictive\n};\nvoid compute(base* pb) throw(){\ntry{\npb->f3();\n}catch(const logic_error &le){}\n  catch(const runtime_error &re){}\n}\n</c>\n\n<h>\n*Function pointer exception specifications\n</h>\n\n<c>\nvoid (*pf)(int)throw(runtime_error);\nvoid recoup(int)throw(runtime_error);\nvoid (*pf1)(int)throw()=recoup; // more restrictive\n</c>'
'14!ABS SBA!Memory Management!ABS SBA!*overload new and delete operator!ABS SBA!<h>\n*New and delete operator\n</h>\n\nallocator class allocates and deallocates type aware memory.\n<cc>\nallocator<T> a // allocator object named a that can allocate or\n                  construct objects of type T.\na.allocate(n)  // Allocates row, un constructed memory to hold n objects\n                  of type T.\na.deallocate(p,n) // Deallocates memory that held n objects of type\n                     T starting at address contained in the T* pointer\n                     named p. User should run destroy() prior to calling\n                     deallocate in order to have destructor called.\na.construct(p, t) // constructs a new element in the memory pointed\n                     to by the T* pointer p. The copy constructor of type\n                     T is run to initialize the object from t.\na.destroy(p)      // runs destructor on the object pointed to by the T*\n                     pointer p.\n</cc>\n<c>\nuninitialized_copy(b,e,b2); // copy source iterator b, e to dest. b2\nuninitialized_fill(b,e,t); // copy source iterator t to dest b, e\nuninitialized_fill_n(b,e,t,n); // copy source iterator t of size n to dest b,e\n\nstring *sp=new string("initialized");\n</c>\n\nnew operator calls operator new to allocate the raw byte memory as against to typed memory in allocator allocate function.\n\nCalls constructors to initialize the memory.\n3) Return the pointer\n<c>\ndelete sp;\n</c>\n\n1) calls the destructor.\n2) calls operator delete to free the memory.\n<c>\nvoid *operator new(size_t);\nvoid *operator new[](size_t);\nvoid *operator delete(void*);\nvoid *operator delete[](void*);\n</c>\n\n<h>\n*Exception bad_alloc from new\n</h>\n\nnew when unsuccessful throws bad_alloc exception.\n<c>\n\n                 \t   ----------------\n                           |  exception   |\n                           ----------------\n                         /     /     \\   \\\n                       /      /       \\    \\\n        --------------      /           \\     -------------\n        |  bad_cast  |    /               \\   | bad_alloc |\n        --------------  /                   \\ -------------\n                      /                       \\\n                    /                           \\\n           -----------------                ----------------\n           | runtime_error |                |  logic_error |\n           -----------------                ----------------\n                        |                     |\n                        |                     |\n   -----------------    |                     |    -----------------\n   | overflow_error|----+                     +----|  domain_error |\n   -----------------    |                     |     -----------------\n                        |                     |\n                        |                     |\n   -----------------    |                     |    --------------------\n   |underflow_error|----+                     +----|  invalid_argument|\n   -----------------    |                     |    --------------------\n                        |                     |\n                        |                     |\n   --------------       |                     |    -----------------\n   | range_error|-------+                     +----|  out_of_range |\n   --------------                             |    -----------------\n                                              |\n                                              |\n                                              |    -----------------\n                                              +----|  length_error |\n                                                   -----------------\n</c>\n\n- new when unsuccessful throws bad_alloc exception.\n- Value initialized then built in types are initialized where as class types as per the argument. When no argument is passed then default constructor is called.\n\n<c>\nstring *ps = new string() ; // default constructor\nint *pi = new int(); // pi points to an int value-initialized to 0\nint *pi = new int(210); // pi points to an int value-initialized to 210\nclass classA{\npublic:\nclassA(const char* name):_name(name){}\nconst char* name(){return _name.c_str();}\nprivate:\nstring _name;\n};\nint main(int argc, char *argv[]) {\nclassA *pc=new classA("heapallocation");\ncout<<pc->name()<<endl;\nreturn 0;\n}\n</c>\n\n- delete can not be used on a pointer that is not allocated through new\n- delete can happen on NULL pointers.\n- After deletion pointer can still be used but its illegal and undefined.\n- Dynamic allocation to const objects uses new const statement\n - const int *pci = new const int(1024);\n - delete pci;\n\n<h>\n*Allocator allocate\n</h>\n\nAllocate function of allocator<T> class allocate memory of type T.\n\n<c>\ntemplate<class T>\nstruct vector{\nvector():front(0),free(0),end(0){}\nvoid push_back(const T&);\nstatic std::allocator<T> alloc;\nT* front;\nT* free; // free node\nT* end; // one past the end\n};\ntemplate<T>\nvoid push_back(const T& t){\nif(free == end) remanage();\nalloc.construct(free,t);//construct free from t\n++free;\n}\n</c>\n\n<h>\n*Allocator construct\n</h>\n\n<c>\nvoid vector<T>::remanage(){\nstd::ptrdifff_t size=free-front;\nT* newfront=alloc.allocate(2*max(size,1)); //allocate memory,\n                      don\'t construct through calling copy constructor\nuninitialize_copy(front,end,newfront);\nfor(T *p=front;p!=end;p++)\nalloc.destry(p);\nif(front) alloc.deallocate(front,end-front);\nfront=newfront;\nfree=front+size;\nend=front+2*max(size,1);\n</c>\n\n<h>\n*Operator new, operator delete\n</h>\n\nOperator new is an operator which allocates memory in bytes rather than in object type size. It comes in two variations <c>void *operator new(size_t)</c> and void <c>*operator new[](size_t)</c>\n\n<c>\nvoid *operator new(size_t) // allocates memory of size_t bytes analogous to malloc\nvoid *operator new[] (size_t) //allocate an array\n\nT* newelements=alloc.allocate(newcapacity);\nor\nT* newelements=static_cast<T*>(operator new [] (capacity * sizeof(T)));\n\nOperator delete deallocates memory.\nvoid operator delete(void*); // free an object\nvoid operator delete[](void*); // free an array allocated through operator new[]\n\nalloc.deallocate(front,end-front); // argument is size/count\noperator delete[](front); // argument is array pointer\n</c>\n\nOperator new and Operator delete are analogous to allocate and does not involve in constructing the free memory.\n\n<h>\n*Placement new\n</h>\n\nPlacement new is analogous to allocator construct function. Placement new initializes the raw memory.\nIt can be used to initialize memory with default to any kind of constructor, where as construct from allocator can do only through copy constructor.\n\n<c>\nnew (place_address) type\nnew (place_address) type (nitializer-list)\nallocator<string> alloc;\nstring *sp=alloc.allocate(2);\n\nb and e are pair of iterators\nnew(sp) string(,b,e); // construct directly with constructing a temporary object\nalloc.construct(sp+1, sting(*b,e)); // first create temporary object of\n   // string(b,e) and then call copy constructor to create destred object at sp+1\n</c>\n\n<h>\n*Array operator new[] and operator delete[]\n</h>\n\n<c>\nVoid *operator new[](size_t);\nVoid operator delelte[](void0\n</c>\n\noperator new[] and operator delete used to allocate memoryf or an array where as operator delete[] used to deallocate array.\n\n<c>\nint *pi=new int[20];\ndelete[] pi;\n</c>\n\n<h>\n*Allocator construct vs placement new\n</h>\n\nIt can be used to initialize memory with default to any kind of constructor, where as construct from allocator can do only through copy constructor.\n<c>\nallocator<string> alloc;\nstring *sp=alloc.allocate(2);\nb and e are pair of iterators\nnew(sp) string(,b,e); // construct directly with constructing a temporary object\nalloc.construct(sp+1, sting(*b,e)); // first create temporary object of\n         string(b,e) and then call copy constructor to create destred object at sp+1\n</c>\n\n<h>\n*Class specific new and delete\n*Member new and delete\n</h>\n\nA class can overload operator new and operator delete. In this fashion calling expression new and delete simply calls operator new and operator delete. operator new has to memory allocation and initialization and overloaded operator delete has to call destructor explicitly and then freeing the memory.\n\nOverloading one of operator new or operator delete is an error.  Must overload both or none.\n\nThis scenario is used to have own memory manager where pool of memory is allocated once and then free is just returning to the pool and allocating is taking from the pool.\n\nIn case of overloading operator new, default new expression can be called through scope resolution operator.\n\n<c>\nType *p=::new Type;\n::delete p;\n</c>\n\n<h>\n*Singleton pattern\n</h>\n\n<h>\n*Identifying object on heap or stack\n</h>'
'15!ABS SBA!RTTI!ABS SBA!*Print RTTI of base and drive class\n object!ABS SBA!<h>\n*typeid operator\n</h>\n\n- RTTI allows programs that uses pointer or references to base classes to retrieve the actual derived types of the objects to which these pointers or references refer.\n- It is provided through two operators\n1. The typeid operator, which returns the actual type of the object referred to by a pointer or a reference.\n2. The dynamic_cast operator, which safely converts from a pointer or reference to a base type to a pointer or reference to a derived type.\n\n- RTTI is computes at run time for classes which has virtual functions otherwise it compute at compile time.\n\n- typeid operator\n - Scenario\n  - If two objects needs to be compared for equality then what can be solution.\n  - provide overloaded function like following\n\n<c>\nbool operator==(const Base&, const Base&);\nbool operator==(const Derived&, const Derived&);\nbool operator==(const Derived&, const Base&);\nbool operator==(const Base&, const Derived&);\n</c>\n\nThis list can grow exponentially if derived classes are more\n - Other solution can be to have equal virtual function and let derived class override it have have custom implementation. Problem with virtual equal function is that all derived class must have Base pointer or reference in the function parameter. This let to compare only Base class attributes.\n\n - The other solution is to have a class provided by the compiler which actually fetches the information regarding the object\'s class. This is type_info class. typeid operator would return object of type_Info class.\n\n<h>\n*dynamic_cast operator\n</h>\n\n- dynamic_cast\n<c>\nstruct A{};\nstruct B{};\nstruct C:A,B{}\n\n                                          vtble\nA*,C*  ---->   +-----------+          +-----------+\n               |   vptr    | -------->|           |\n               +-----------+\n               |A attribute|\n               +-----------+\n               |C attribute|\nB* ------>     +-----------+--------->+-----------+\n               |   vptr    |          |  thunk    |\n               +-----------+          +-----------+\n               |B attribute|\n               +-----------+\n\nB* b=new C;\nC* c=dynamic_cast<C*>(b); // ok\nC* c=static_cast<C*>(b);// error\n</c>\n\n- Dynamic casts are needed when we have a reference or pointer to a base class but need to perform operations from the derived class that are not part of the base class.\n- To get derived behaviour of a pointer to base is to provide a virtual function and get it implemented in derived class.\n\n<c>\nif (Derived *derivedPtr = dynamic_cast<Derived*>(baseptr) ) {\n} else {\n}\n</c>\nor\n<c>\nvoid f(const Base &b) {\ntry {\nconst Derived &d=dynamic_cast<const Derived&>(b);\n} catch (bad_cast) { // throws bad_cast\n}\n}\n</c>\n\n<h>\n*type_info class\n</h>\n\n- type_info class provides following operation\nt1 == t2 Returns true if the two type_info objects t1 and t2 refer to the same type; false otherwise.\n\nt1 != t2 Returns true fi the two type_info objects t1 and t2 refer to different types; false otherwise\n\nt.name() Returns a c-style character string that is printable version of the type name. Type names are generated in a system-dependent way.\n\nt1.before(t2) Returns a bool that indicates whether t1 comes before t2.\n\nThe ordering imposed by before is compiler-dependent.\n\n<c>\nBase *bp;\nDerived *dp;\nif(typeid(*bp) == typeid(*dp)) {\n}\nif(typeid(*bp) == typeid(Derived)) {\n}\n\nif pointer type is used then RTTI resolves at compile time\nif (typeid(bp) == typeid(Derived)) { // never equal\n}\n</c>\n\n- If value of pointer p is 0, then typeid(*p) throws a bad_type exception provided p has virtual functions.\n- Combining typeid and dynamic_cast\n\n<c>\nclass Base {\nfriend bool operator==(const Base&, const Base&);\npublic:\nprotected:\nvirtual bool equal(const Base&, const Base&);\n};\nclass Derived:public Base {\nfriend bool operator ==(const Base&, const Base&);\npublic:\nprivate:\nbool equal(const Base&) const;\n};\nbool operator==(const Base &lhs, const Base &rhs) {\nreturn typeid(lhs) == typeid(rhs) && lhs.equal(rhs);\n}\n\nbool Derived::equal(const Base &rhs) const {\nif(const Derived *dp=dynamic_cast<const Derived*>(&rhs) {\n//do more stuff\n} else\nreturn false;\n}\nbool Base::equal(const Base &rhs) const {\n//do some base comparision of attributes\n}\n</c>\n\n<h>\n*dynamic_cast vs static_cast\n</h>\n\nstatic_cast just change the structure/variable type not changing the address. It is used mainly for reinterpreting a type to different type. ex.\n<c>\nstruct A{}\nstruct B{}\nvoid func(void *pv,int nump){\nif (nump==1)\nA* a=static_cast<A*>(pv);\nelse if(nump==2)\nB* b=static_cast<B*>(pv);\n}\n</c>\n\nSo it is mainly used where source type is know in advance.\n\ndynamic_cast is used only in polymorphism where secondary base class\npointer need to be converted primary base class or derive base class pointer.\n\n<h>\n*reinterpret_cast\n</h>\nreinterpret_cast is used in low level conversions. Little or Big endian can be known through reinterpret_cast\n\n<c>\nunsigned int i=1;\n--------                         --------\n| 0x00 |                         | 0x10 |\n--------                         --------\n| 0x00 |                         | 0x00 |\n--------                         --------\n| 0x00 |                         | 0x00 |\n--------                         --------\n| 0x01 | < -- little endian      | 0x00 |   < -- big endian\n--------                         --------\n\n#include <iostream>\n#include <string>\nusing namespace std;\nint main(){\nunsigned int i=1;\nchar *b=reinterpret_cast<char*>(&i); // most of the machine\n                         // char* represented in little endian\nif(b[0])\ncout<<"little endian";\nelse\ncout<<"big endian";\nreturn 0;\n}\n</c>'
'16!ABS SBA!Modern C++ Ox,11x,14x,17x,20x versions!ABS SBA!!ABS SBA!<h>\n*C++11 Intro\n</h>\n\nC++11 is the ISO C++ standard ratified in 2011. The previous standard is often referred to as C++98 or C++03; the differences between C++98 and C++03 are so few and so technical that they ought not concern users.\n\n<h>\n*Explicit Virtual Overrides\n</h>\n\nNo special keyword or annotation is needed for a function in a derived class to override a function in a base class. For example:\n<c>\nstruct B {\nvirtual void f();\nvirtual void g() const;\nvirtual void h(char);\nvoid k();       // not virtual\n};\n\nstruct D : B {\nvoid f();       // overrides B::f()\nvoid g();       // doesn\'t override B::g() (wrong type)\nvirtual void h(char);   // overrides B::h()\nvoid k();       // doesn\'t override B::k() (B::k() is not\nvirtual)\n};\n</c>\n\nThis can cause confusion (what did the programmer mean?), and problems\nif a compiler doesn\'t warn against suspicious code. For example,\n* Did the programmer mean to override B::g()? (almost certainly yes)\n* Did the programming mean to override B::h(char)? (probably not because of the redundant explicit virtual).\n* Did the programmer mean to override B::k()? (probably, but that\'s not possible).\n\nTo allow the programmer to be more explicit about overriding, we now have the "contextual keyword" override:\n\n<c>\nstruct D : B {\nvoid f() override;      // OK: overrides B::f()\nvoid g() override;      // error: wrong type\nvirtual void h(char);   // overrides B::h(); likely warning\nvoid k() override;      // error: B::k() is not virtual\n};\n</c>\n\nA declaration marked override is only valid if there is a function to override.\nOverride is only a contextual keyword, so you can still use it as an identifier:\n<c>\nint override = 7;       // not recommended\n</c>\n\nOverride controls: final\nSometimes, a programmer wants to prevent a virtual function from being overridden. This can be achieved by adding the specifier final. For example:\n\n<c>\nstruct B {\nvirtual void f() const final;   // do not override\nvirtual void g();\n};\nstruct D : B {\nvoid f() const;         // error: D::f attempts to override final B::f\nvoid g();               // OK\n};\n</c>\n\nFinal can be added for internal purpose and external user should not override it.\n\nfinal is only a contextual keyword, so you can still use it as an identifier:\n<c>\nint final = 7;  // not recommended\n</c>\n\n<h>\n*Uniform Initialization\n</h>\n\nC++ offers several ways of initializing an object depending on its type and the initialization context.\n\n<c>\nstring a[] = { "foo", " bar" }; // ok: initialize array variable\nvector<string> v = { "foo", " bar" }; // error: initializer list for non-aggregate vector\nvoid f(string a[]);\nf( { "foo", " bar" } ); // syntax error: block as argument\n</c>\n\nand\n<c>\nint a = 2;              // \'\'assignment style\'\'\nint aa[] = { 2, 3 };    // assignment style with list\ncomplex z(1,2);         // \'\'functional style\'\' initialization\nx = Ptr(y);             // \'\'functional style\'\' for conversion/cast/construction\n</c>\n\nand\n<c>\nint a(1);       // variable definition\nint b();        // function declaration\nint b(foo);     // variable definition or function declaration\n</c>\n\nIt can be hard to remember the rules for initialization and to choose the best way.\n\nThe C++11 solution is to allow {}-initializer lists for all initialization:\n<c>\nX x1 = X{1,2};\nX x2 = {1,2};   // the = is optional\nX x3{1,2};\nX* p = new X{1,2};\n\nstruct D : X {\nD(int x, int y) :X{x,y} { /* ... */ };\n};\n\nstruct S {\nint a[3];\nS(int x, int y, int z) :a{x,y,z} { /* ... */ }; // solution to old problem\n};\n</c>\n\nImportantly, X{a} constructs the same value in every context, so that {}-initialization gives the same result in all places where it is legal.\nFor example:\n<c>\nX x{a};\nX* p = new X{a};\nz = X{a};         // use as cast\nf({a});           // function argument (of type X)\nreturn {a};       // function return value (function returning X)\n</c>\n\n<h>\n*Constructors\n</h>\n\nInherited constructors\n<c>\nstruct B {\nvoid f(double);\n};\nstruct D : B {\nvoid f(int);\n};\nB b;   b.f(4.5);        // fine\nD d;   d.f(4.5);        // surprise: calls f(int) with argument 4\n</c>\n\nIn C++98, we can "lift" a set of overloaded functions from a base class into a derived class:\n<c>\nstruct B {\nvoid f(double);\n};\nstruct D : B {\nusing B::f;     // bring all f()s from B into scope\nvoid f(int);    // add a new f()\n};\n\nB b;   b.f(4.5);        // fine\nD d;   d.f(4.5);        // fine: calls D::f(double) which is B::f(double)\n\nclass Derived : public Base {\npublic:\nusing Base::f;    // lift Base\'s f into Derived\'s scope -- works in C++98\nvoid f(char);     // provide a new f\nvoid f(int);      // prefer this f to Base::f(int)\n\nusing Base::Base; // lift Base constructors Derived\'s scope -- C++11 only\nDerived(char);    // provide a new constructor\nDerived(int);     // prefer this constructor to Base::Base(int)\n// ...\n};\n</c>\n\nIf you so choose, you can still shoot yourself in the foot by inheriting constructors in a derived class in which you define new member variables needing initialization:\n\n<c>\nstruct B1 {\nB1(int) { }\n};\nstruct D1 : B1 {\nusing B1::B1; // implicitly declares D1(int)\nint x;\n};\nvoid test()\n{\nD1 d(6);        // Oops: d.x is not initialized\nD1 e;           // error: D1 has no default constructor\n}\n</c>\n\nYou might remove the bullet from your foot by using a member-initializer:\n<c>\nstruct D1 : B1 {\nusing B1::B1;   // implicitly declares D1(int)\nint x{0};       // note: x is initialized\n};\nvoid test()\n{\nD1 d(6);        // d.x is zero\n}\n</c>\n\n<h>\n*Type Interface\n</h>\n\nConsider:\n<c>\ntemplate<class T, class U>\n  ??? mul(T x, U y)\n{\nreturn x*y;\n}\n</c>\n\nWhat can we write as the return type? It\'s "the type of x*y", of course, but how can we say that? First idea, use decltype:\n<c>\ntemplate<class T, class U>\ndecltype(x*y) mul(T x, U y) // scope problem!\n{\nreturn x*y;\n}\n</c>\n\nThe solution is put the return type where it belongs, after the arguments:\n<c>\ntemplate<class T, class U>\nauto mul(T x, U y) -> decltype(x*y)\n{\nreturn x*y;\n}\n</c>\n\nWe use the notation auto to mean "return type to be deduced or specified later."\n\nThe suffix syntax is not primarily about templates and type deduction,\nit is really about scope.\n<c>\nstruct List {\nstruct Link { /* ... */ };\nLink* erase(Link* p);   // remove p and return the link before p\n// ...\n};\nList::Link* List::erase(Link* p) { /* ... */ }\n</c>\n\nThe first List:: is necessary only because the scope of List isn\'t entered until the second List::. Better:\n\n<c>\nauto List::erase(Link* p) -> Link* { /* ... */ }\n</c>\n\nNow neither Link needs explicit qualification.\n\n<h>\n* Range based for loop\n</h>\n\nA range for statement allows you to iterate through a "range", which is anything you can iterate through like an STL-sequence defined by a begin() and end(). All standard containers can be used as a range, as can a std::string, an initializer list, an array, and anything for which you define begin() and end(), e.g. an istream. For   example:\n\n<c>\nvoid f(vector<double>& v)\n{\nfor (auto x : v) cout << x << \'\\n\';\nfor (auto& x : v) ++x;  // using a reference to allow us to change the value\n}\n</c>\n\n\nYou can read that as "for all x in v" going through starting with v.begin() and iterating to v.end(). Another example:\n\n<c>\nfor (const auto x : { 1,2,3,5,8,13,21,34 }) cout << x << \'\\n\';\n</c>\n\nThe begin() (and end()) can be a member to be called x.begin() or a free-standing function to be called begin(x). The member version takes precedence.\n\n<h>\n*Lambdas\n</h>\n\nA lambda expression is a mechanism for specifying a function object. The primary use for a lambda is to specify a simple action to be performed by some function. For example:\n\n<c>\nvector<int> v = {50, -10, 20, -30};\nstd::sort(v.begin(), v.end());  // the default sort\n// now v should be { -30, -10, 20, 50 }\n// sort by absolute value:\nstd::sort(v.begin(), v.end(), [](int a, int b) { return abs(a)<abs(b); });\n// now v should be { -10, 20, -30, 50 }\n\nA lambda expression can access local variables in the scope in which it is used. For example:\nvoid f(vector<Record>& v)\n{\nvector<int> indices(v.size());\nint count = 0;\ngenerate(indices.begin(),indices.end(),[&count](){\nreturn count++;\n});\n\n// sort indices in the order determined by the name field of the records:\nstd::sort(indices.begin(), indices.end(), [&](int a, int b) {\nreturn v[a].name<v[b].name; });\n// ...\n}\n</c>\n\n\nWe could have said that we wanted to "capture" only v, we could have said so: [&v]. Had we wanted to pass v by value, we could have said so: [=v]. Capture nothing is [], capture all by references is[&], and capture\nall by value is [=].\n\nIf an action is neither common nor simple, use a named function object or function\n<c>\nvoid f(vector<Record>& v)\n{\nvector<int> indices(v.size());\nint count = 0;\ngenerate(indices.begin(),indices.end(),[&](){ return ++count; });\n\nstruct Cmp_names {\nconst vector<Record>& vr;\nCmp_names(const vector<Record>& r) :vr(r) { }\nbool operator()(int a, int b) const { return vr[a].name<vr[b].name; }\n};\n\n// sort indices in the order determined by the name field of the records:\nstd::sort(indices.begin(), indices.end(), Cmp_names(v));\n// ...\n}\n</c>\n\n<h>\n*Functional programming\n</h>'
'17!ABS SBA!Pointer to class member!ABS SBA!!ABS SBA!<h>\n*Declaring pointer to class member\n</h>\n\nPointer to class member (method or attributes) are important in the sense it can be used as generic type at many places including function argument types.\n\nPointer to member is applicable only to non-static members.\n\nAttribute has grammar like\n<c>\n<attribute type> <classname>::*\n</c>\n\nMethods has grammar like\n<c>\n<return type> (<classname>::*)(argments)\n\nclass filebuffer{\npublic:\ntypedef std::string::size_type index;\nchar get() const;\nchar get(index offset) const;\nprivate:\nstd::string content;\nindex offsetpos;\nindex length;\n};\n\nstring filebuffer::*pfb_conent=&filebuffer::content;\nfilebuffer::index filebuffer::*pfb_offset=&filebuffer::offsetpos;\nChar (filebuffer::*pfb_get)(filebuffer::index) const=&filebuffer::get;\n\n\nTypedef\ntypedef char (filebuf::*action)(filebuff::index) const;\nfilebuf& func(const filebuf&,action=&filebuf::get);\n\nfunc(filebuf());\nfunc(filebuf(),&filebuf::get);\naction get=&filebuf::get;\nfunc(filebuf(),get);\n</c>\n\n<h>\n* Using pointer to class member\n</h>\n\nThe pointer-to-member dereference operator (.*) fetches the member from an object or reference.\n\nThe pointer-to-member arrow operator (->*) fetches the member through a pointer to an object.\n\nCalling methods\n\n<c>\nchar (filebuffer::*pfbget)() const = &filebuffer::get;\nfilebuffer filebuf;\nchar c1=filebuf.get(); // normal call\nchar c2=(filebur::.*pfbget)(); // through pointer class member\n\nfilebuffer *pfilebuf=&filebuf;\nchar c3=(filebuf::->*pfbget)();\n</c>\n\nCalling data member\n\n<c>\nfilebuf::index filebuf::*pindex=&filebuff::offsetpos;\nfilebuf::index pos1=filebuf.offsetpos;\nfilebuf::index pos2=filebuf.*pindex;\nfilebuf::index pos3=pfilebuf->*pindex;\n</c>\n\n<h>\n*Command design pattern\n</h>\n\n<c>\n$cat main.cpp\n#include <iostream>\nstruct robot{\nvoid left(int dp){std::cout<<"robot::moved left, distance "<<dp<<std::endl;}\nvoid right(int dp){std::cout<<"robot::moved right, distance "<<dp<<std::endl;}\nvoid front(int dp){std::cout<<"robot::move front distance "<<dp<<std::endl;}\nvoid back(int dp){std::cout<<"robot::moved back distance "<<dp<<std::endl;}\n};\n\nstruct command{\ntypedef void (robot::*actiontype)(int);\ncommand(robot *rp,actiontype actp,int dp);\nvoid move();\nrobot *rbt;\nint dist;\nactiontype act;\n};\ncommand::command(robot *rp,actiontype actp,int dp){\nrbt=rp;\nact=actp;\ndist=dp;\n}\n\nvoid command::move(){\n(rbt->*act)(dist);\n}\nint main(int argc, char *argv[]){\nrobot *rbt=new robot;\nint i=0;\ncommand cmd[2]={command(rbt,&robot::left,4),command(rbt,&robot::right,6)};\nfor(i=0;i<2;i++)\ncmd[i].move();\nreturn 0;\n}\n</c>\n\n$ g++ -o command main.cpp\n$ ./command\n<c>\nrobot::moved left, distance 4\nrobot::moved right, distance 6\n</c>'
"18!ABS SBA!Nested class and volatile operator!ABS SBA!!ABS SBA!<h>\n*Defining nested class members\n</h>\n\nNested Classes\nA class defined within another class is a nested class/type.\nA nested class is visible only in enclosing class scope and not in scope where enclosing close is defined.\n\nEnclosing class and nested class need to access each others member as independent classes. So nested class just scopes a class other wise there is other different when it is two different classes.\n\n<c>\ntemplate<class type>class queue{\nprivate:\nstruct queueitem{\nqueueitem(const type &);\ntype item;\naueueitem *next;\n};\naueueitem *head;\naueueitem *tail;\n};\n\ntemplate<class type>\nqueue<type>::queueitem::queueitem(const type &t):\n                                item(t),next(0){}\n</c>\n\n<h>\n*Defining nested class outside the enclosing class\n</h>\n\nIn case user of enclosing class need see the implementation of the nested class.\nForward declare the nested class.\n\n<c>\ntemplate <class type> class queue{\nprivate:\nstruct queueitem;\nqueueitem *head;\nqueueitem *tail;\n};\n\ntemplate <class type>\nstruct queue<type>::queueitem{\nqueueitem(const type &t):item(t)<next(0){}\ntype item;\nqueueitem *next;\n};\n</c>\n\n<h>\n*Volatile qualifier\n</h>\n\nSome variables value depends on hardware and can change externally. This makes value not to be optimized by the compiler. Volatile operator puts tag on variable so that compiler would not optimize the variable.\n\nFor example, for a machine with memory-mapped input/output, a pointer to a device register might be declared as a pointer to volatile, in order to prevent the compiler from removing apparently redundant references through the pointer.  Except that it should diagnose explicit attempts to change const objects, a compiler may ignore these qualifiers.\n\n\nPort\n<c>\n---------------------------------------------\n| control register |     |  data register   |\n---------------------------------------------\n\ntypedef short int control;\ntypedef short int data;\n#define ENABLE 0x40\n#define READY 0x80\ntypedef struct port port;\nstruct port\n{\ncontrol c;\ndata d;\n};\ntypedef struct ioport ioport;\nstruct ioport\n{\nport in, out;\n};\n\n//Using the declarations above, assign one memory mapped address to it\nioport *const pio = (ioport *)0xFF70;\n// check if control register ready bit is ready for data to be written\nwhile (pio->out.c & READY == 0)\n;\n//write carriage return\npio->out.d = '\\r';\nwhile (pio->out.c & READY == 0)\n;\npio->out.d = '\\n';\n//.Compiler start doing the optimization in following ways.\n//Optimization\n\nif (pio->out.c & READY == 0)\nfor (;;)\n;\npio->out.d = '\\r';\nif (pio->out.c & READY == 0)\nfor (;;)\n;\npio->out.d = '\\n';\nOptimization\nif (pio->out.c & READY == 0)\nfor (;;)\n;\npio->out.d = '\\r';\npio->out.d = '\\n';\n\n//Further Optimization where '\\r' is removed as redundant\nif (pio->out.c & READY == 0)\nfor (;;)\n;\npio->out.d = '\\n';\n</c>\n\nSolution\n<c>\nioport volatile *const pio = (ioport *)0xFFA0;\n</c>\n\nIn C+= volatile operator is similar to const where const and non-const variable can be assigned to a const variable. Volatile <--- const <--- normal , a non volatile variable can not be assigned to volatile\n\n<c>\nvolatile int v;\nint *ip=&v; // error\nvolatile int *ip=&v; //ok\n</c>\n\nOnly volatile member functions may be called on volatile objects.\n\nSynthesized copy constructor and assignment operator does not include volatile in the argument type. This makes volatile object not be copied. In case of volatile objects copy constructor and synthesized operator need to be declared explicitly.\n\n<c>\nClass A{\nPublic:\nA(const volatile A&); // similar to const, copy from volatile object\nA& operator=(volatile const A&); // copy from volatile object\nA& operator=(volatile const A&) volatile; //copy from volatile to volatile object\n};\n</c>"
'19!ABS SBA!Standard Template Library(STL)!ABS SBA!None!ABS SBA!<h>\n*Introduction to STL\n*Overview of Containers in STL\n</h>\n<h>\n*Sequential containers\n - vector, list\n - deque, arrays, forward list\n*container adpators\n - queue, priorty queue\n - stack\n*Associative containers\n - set, multiset\n - map, multimap\n - hash\n*Unordered associative containers\n - unordered set\n - unordered map\n</h>\n<h>\n*Introduction to iterators\n*Operations on iterators\n</h>'
'31!ABS SBA!title!ABS SBA!None!ABS SBA!C++ Essentials Training'
'32!ABS SBA!subtitle!ABS SBA!None!ABS SBA!5-day session'
'33!ABS SBA!h_Overview!ABS SBA!None!ABS SBA!Understanding principles of Object Oriented Programming Overview\nUnderstanding the structure of a c++ program\nUnderstanding Polymorphism\nUnderstanding UML modeling\nPractical labs with GNU g++ compiler'
'34!ABS SBA!h_Duration!ABS SBA!None!ABS SBA!Five days - 40 hours (8 hours a day)\n50% of lecture, 50% of practical labs.'
'35!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'36!ABS SBA!h_Trainer!ABS SBA!None!ABS SBA!<a href="https://www.linkedin.com/in/pravinkumarsinha">http://www.linkedin.com/in/pravinkumarsinha</a>'
'37!ABS SBA!h_Audience!ABS SBA!None!ABS SBA!Professional Software developers\nPeople supporting large scale products.'
'38!ABS SBA!h_Prerequisite!ABS SBA!None!ABS SBA!<b>Knowledge of C programming</b>\nIn particular, participants must be familiar with creating and dealing with\ncomplex data types and structures, with pointers to such symbols, as well as\nwith function pointers.\nAdvance C training agenda is available at\n<a href="http://minhinc.42web.io/training/c/advance-c-slide.php">http://minhinc.42web.io/training/c/advance-c-slide.php</a>\nand can be downloaded from\n<a href="http://minhinc.42web.io/training/advance-c-slide.pdf">http://minhinc.42web.io/training/advance-c-slide.pdf</a>\n\n<b>Knowledge of Object Oriented Concepts</b>\nOops concept like Abstraction, Inheritance, Polymorphism would help.'
'39!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'40!ABS SBA!h_Setup!ABS SBA!None!ABS SBA!Linux machine with GNU g++ compiler installed.'
'41!ABS SBA!h2_Lecture!ABS SBA!None!ABS SBA!Lecture session will be course content presentation through the trainer.\nAny source code example related to the topic will be demonstrated, it would\ninclude executing the binaries.\nComplete lecture material can be downloaded from\n<a href="http://minhinc.42web.io/training/advance-cpp-slides.pdf">http://minhinc.42web.io/training/advance-cpp-slides.pdf</a>'
'42!ABS SBA!h2_Labs!ABS SBA!None!ABS SBA!Labs session would be completely hands on session where each example\n(with example data and execution instruction) would be provided to the\nstudents. Students can verify their results with the results provided in\nthe material.'
      dp      
'1!ABS SBA!C++ Object Model!ABS SBA!!ABS SBA!<h>\n*C++ Object Model\n</h>\n\nRefer\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap8_0</m>\n\n<h>\n*Single Inheritance\n</h>\n\nRefer\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap8_2</m>\n\n<h>\n*Multiple Inheritance\n</h>\n\nRefer\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap8_3</m>'
'2!ABS SBA!Vtable structure!ABS SBA!!ABS SBA!<h>\n*Vtable Structure\n</h>\n\nRefer\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap8_4</m>\n\n<h>\n*Virtual methods and SI, MI\n</h>\n\nRefer\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap8_5</m>\n\n<h>\n*Virtual base class\n</h>\n\nRefer\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap8_6</m>\n\n<h>\n*Thunk based and Offset based object model\n</h>\n\nRefer\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap8_7</m>'
"3!ABS SBA!Design Pattern Overview!ABS SBA!!ABS SBA!<h>\n*GOF Design Pattern Overview\n - Creational Design Patterns\n - Structural Design Patterns\n - Behavioural Design Patterns\n</h>\n\nDesign patterns are pre defined patterns used for\n - implementing different creation scenarios\n - implementing different structural scenarios\n - implementing different behavioural scenarios\n\nDesign Pattern is very similar to pattern used in metal casting\n\nInsert the pattern to make cavity. Take out the pattern to put molten metal.\n<m>http://minhinc.42web.io/image/dp_training_cast1.jpg</m>\n\nModel is ready as per the pattern.\n<m>http://minhinc.42web.io/image/dp_training_cast2.jpg</m>\n\nA pattern is a basic unit of designing. When analysis phase is done the closest pattern is considered for the solution or even some hybrid patterns are also checked for solution. Since patterns are well defined and tested way of solving the problem, once identified they can prove stable design and non modifiable code. The more available patterns are in different aspects of designing area supported in a language, the more powerful the language is. In the document 23 GOF design patterns are discussed and implemented through C++ code. 23 design patterns are distributed among 3 categories. Creational, structural and behavioral. This document is written in sequel and contains description for creational structural and behavioral patterns.\n\n<d> <b>Creational pattern</b>\n A class/item can be instantiated in many different scenarios. Out of which 5 scenarios are common.\n  <d2> Factory method\n Items/classes need to be created for a single platform through a static method in the Item class iteself by passing some hint (i.e. name). This way creation of the item is hidden from the calling code. Calling code recieves base/item class pointer through which it can operate through its methods, independent of which drive class object is instantiated.\n  <d2> Abstract factory\n Items/classes in needs to be created for different categories. Item in same category (i.e. platform) can be created through a platform specific factory. Whereas platform specific factories are extended from a generic abstract factory. Once factory is instantiated depending upon the platform, items specific to the platform can be created through the factory.\n  <d2> Singleton\n Only one instance of a class is permittable. More instance of a class should return the same unique instance.\n  <d2> Builder\n As the name suggest a builder pattern is used when an entity (builder) creates a complex object in parts (predefined). A builder pattern exposes various methods of creating complex structures and it is the director who calls for these methods and once the structure is ready the builder returns to the director.\n  <d2> Prototype\n When cloning an object the prototype pattern is used.\n\n<d> <b>Structural pattern</b>\n Structural patterns deal with the layout of how the attributes of the class/design is distributed, added and related. The class deals with static structure of the design.\n  <d2> Adaptor\n When adaptee's interface varies from client interface, a client expects this Pattern to be used. It changes client supported interface to adaptee's interface so that client can use adaptee through its own interface.\n  <d2> Bridge Pattern\n when two classes comes into picture where one uses other and both class grows in heirarchy at run time, bridge pattern is used.\n  <d2> Facade\n When an extra interface is required for handling complex underlying Components, facade pattern is used. This makes various underlying classes easy to use through facade interface. \n  <d2> Flyweight\n When a class requires multiple instantiation and all have common properties and only a few of them differs then it's wise to instantiate only one object. Common attributes would go as intrinsic attributes where as uncommon would be passed as extrinsic parameter.\n  <d2> Proxy\n A Class that acts as an interface to other class or classes is called proxy. Proxy holds same interface and passes the call to actual implementaion.\n  <d2> Composite\n When a complex structure contains other structures where the other structures provide the same interface behaviour as the complex structure, this situation makes composite structural pattern.\n  <d2> Decorator\n When extending attributes are required at run time, a similar pattern to composite is used. Extra decorator class comes which decorates the decoratee and decorator does not subclass decoratee.\n\n<d> <b>Beharioural Pattern</b>\n Behavioral design pattern include patterns that focus on operations (activity) of a class. it includes modifying or adding operations at run time.\n  <d2> Chain of responsibility\n Responsibility to handle a request is passed to objects in a chain until the request finds an object that can handle it.\n  <d2> Interpreter\n A grammar interpreter pattern is used in a language where representation of grammar is required along with an interpreter in-order to decode sentences in a language.\n  <d2> Command\n This pattern is used when different methods need to be called in a generic fashion. Here function gets class status.\n  <d2> State \n when class behavior changes and separate logic class is required to handle the new behaviour state pattern is used. All logic comes in state class.\n  <d2> Observer\n When a subject is observed by many observers, it leads to data view/controller model and forms an observer pattern. \n  <d2> Visitor\n when behaviour needs to be added to a class at run time visitor pattern is used.\n  <d2> Iterator\n In a collection class when each element in the collection (i.e. array, list, tree etc) needs to be accessed sequentially and in a collection type independent manner, an iterator pattern is used. \n  <d2> Mediator\n When a group of entities exist and change in ones state effect other it easy to insert a mediator making entities communicate each other only through mediator.\n  <d2> Memento\n There are scenarios when a class (originator) changes its state and there has to be an option to bring the class to certain state that the class had been to in the past.\n  <d2> Strategy\n The behavior of a class may contain both static and changeable behavior. Instead of hard-coding the changeable behavior it keeps abstract data type followed by getting the implementation of abstract at runtime.\n  <d2> Template method\n A template draws an architecture of something and lets the implementor to implement the architecture from his perspective.\n\n<h>\n*Design Patterns and Programming language\n</h>\n\n<m>http://minhinc.42web.io/image/dp_training_dp_oops.png</m>\n\nAll object oriented languages, i.e. c++, Java, Python, Qml, uses Design Patterns for large scale stable product design. While achieving creational, structural or behavioural complex scenarios design patterns are used to create relationship among the classes. Hybrid design patterns can also be created to achieve the gloal. So Design pattern is the entity that glow in object oriented language based products."
'4!ABS SBA!GOF Creational Design Pattern!ABS SBA!!ABS SBA!<h>\n*New Object Creation\n - Factory Method Pattern\n - Abstract Factory Pattern\n - Builder Pattern\n - Singleton Pattern\n</h>\n\n<b><l>Creational design patterns</l></b>\nCreational design pattern deals with both creating the object and the component. A component is created or generated in two ways. Generating from scratch (first of its kind) and generating from cloning. In first method the component can be generated at ago or part by part in generic fashion. A factory class makes new component creations at ago, whereas builder makes part by part (for intricate), while prototype does cloning.\n\n<cb>\n                       object creation\n                               |\n                               v\n                     +-----------------------+\n                     |                       |\n                     v                       v\n                new object      cloning(prototype)\n                     |\n                     |\n                     +-----------------------+\n                     |                       |\n                     v                       v\n one go creation(factory,singleton)   part wise creation(builder)\n</cb>\n\n\n <b>- Factory Method Pattern</b>\n\nItems/classes need to be created for a single platform through a static method in the Item class iteself by passing some hint (i.e. name). This way creation of the item is hidden from the calling code. Calling code recieves base/item class pointer through which it can operate through its methods, independent of which drive class object is instantiated.\n\n<cb>\n             o------------------------------------> Item Class\n                    ^\n                    |\n                    +\n                     \\\n                      \\\n                       +---- Item class itself behave as factory return itself\n</cb>\n\n<cb>\n                          +----------------+\n   static . . .           |     <g>shape</g>      |\n   factory     \\         +----------------+\n   method        .. .. .> |createshape(name|\n                          |  :string):shape|\n                          |draw():void     |\n                          |enable():void   |\n                          +----------------+\n                                 / \\\n                                  -\n                                  |<l><<extends>></l>\n              ----------------------------------------\n              |                   |                  |\n      +-------------+     +-------------+     +-------------+\n      |   <g>button</g>    |     |    <g>menu</g>     |     |  <g>combobox</g>   |\n      +-------------+     +-------------+     +-------------+\n      |draw():void  |     |draw():void  |     |draw():void  |\n      |enable():void|     |enable():void|     |enable():void|\n      +-------------+     +-------------+     +-------------+\n</cb>\n\nCode\n<cb>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nclass <g>widget</g> {\npublic:\n static widget* createwidget(string&);\n virtual void draw() = 0;\n virtual void enable(bool) = 0;\n};\n\nclass <g>button</g> : public widget {\npublic:\n void draw() { cout << <r>"Button::draw"</r><<endl; }\n void enable(bool e_d) { cout << <r>"Button::enable "</r><< e_d<<endl; }\n};\nclass <g>menu</g> : public widget {\npublic:\n void draw() { cout << <r>"Menu::draw"</r><<endl; }\n void enable(bool e_d) { cout << <r>"Menu::enable "</r><< e_d<<endl; }\n};\nclass <g>combobox</g> : public widget {\npublic:\n void draw() { cout << <r>"Combobox::draw"</r><<endl; }\n void enable(bool e_d) { cout << <r>"Combobox::enable "</r><< e_d<<endl; }\n};\n\nwidget* widget::createwidget( string& name) {\nif (name == "button")\n return new button;\nelse if (name == "menu")\n return new menu;\nelse\n return new combobox;\n}\n\nint main( void ) {\n vector<widget*> shape;\n string choice;\n int i=0;\n while (true) {\n  cout << <r>"enter you choice, button, menu, combobox, e(exit)"</r><<endl;\n  cin >> choice;\n  if (choice == <r>"e"</r>)\n   break;\n   shape.push_back( widget::createwidget( choice ) );\n  }\n  for (int i=0; i < shape.size(); i++){\n   shape[i]->enable(true);\n   shape[i]->draw();\n  }\n  for (int i=0; i < shape.size(); i++)\n   delete shape[i];\n return 0;\n}\n</cb>\n\nResult\n<c>\npi@raspberrypi:~/tmp/MISC/gc $ ./a.out\nenter you choice, button, menu, combobox, e(exit)\nmenu\nenter you choice, button, menu, combobox, e(exit)\nbutton\nenter you choice, button, menu, combobox, e(exit)\ncombobox\nenter you choice, button, menu, combobox, e(exit)\nbutton\nenter you choice, button, menu, combobox, e(exit)\ne\nMenu::enable 1\nMenu::draw\nButton::enable 1\nButton::draw\nCombobox::enable 1\nCombobox::draw\nButton::enable 1\nButton::draw\n</c>\n\n <b> - Abstract Factory</b>\n Items/classes in needs to be created for two different categories. Item in same category (i.e. platform) can be created through a platform specific factory. Whereas platform specific factories are extended from a generic abstract factory. Once factory is instantiated depending upon the platform, items specific to the platform can be created through the factory. So platform and actual product makes a orthogonal coordinates.\n\n<cb>\nf p |\na r |      x        x        x\nc.o |\n  d |\nm u |\ne c |      x        x        x < . . . every product is supported on\nt t |                                  each platform\nh ^ |\n^ . |\n. . |      x        x        x\n. . |\n    o---------------------------------\n        .........> platform         ^\n        `````````> platform factory |\n                                    +\n                                    \\\n                                     \\\n                                      + Platform behaves as factory\n</cb>\n\n<cb>\n                                                        --------\n                            ----------------------------|client|\n      +---------------+     |                           --------\n      |<g>abstractfactory</g>|<-----                              |\n      +---------------+                   |---------------------|\n      |createButton():|                   v                     v\n      |       :button |              +-----------+       +-----------+\n      |createmenu():  |              |  <g>button</g>   |       |   <g>menu</g>    |\n      |           menu|              +-----------+       +-----------+\n      +---------------+              |draw():void|       |draw():void|\n             / \\                    +-----------+       +-----------+\n              -                           / \\                / \\\n   <l><<extends>></l>|                            -                   -\n ---------------------------               |                   |\n |                         |               |                   |\n +--------------+  +--------------+        |                   |\n |<g>windowsfactory</g>|  | <g>unixfactory</g>  |        |                   |\n +--------------+  +--------------+        |                   |\n |createbutton()|  |createbutton()|     <l><<extends>></l>        <l><<extends>></l>\n |       :button|  |       :button|        |                   |\n |createmenu(): |  |createmenu(): |        |                   |\n |          menu|  |          menu|        |                   |\n +--------------+  +--------------+        |                   |\n |                              |          |                   |\n |            ------------------)-----------   ---------------------------\n <l><<uses>></l>     |                 + -- - - - |- -|- - -<l><<uses>></l> - - -+     |\n |            |                    v       |   |                   v     |\n |     +-------------+         -------------   +-----------+ +-----------+\n |     |<g>windowsbutton</g>|         |<g>unixbutton</g> |   |<g>windowsmenu</g>| | <g>unixmenu</g>  |\n |     +-------------+         +-----------+   +-----------+ +-----------+\n |     |draw():void  |         |draw():void|   |draw():void| |draw():void|\n |     +-------------+         +-----------+   +-----------+ +-----------+\n |          ^                                        ^\n |          |                                        |\n -----------------------------------------------------\n</cb>\n\n<cb>\n#include <iostream>\nusing namespace std;\n#define WINDOWS\n\nclass <g>widget</g> {\npublic:\n   virtual void draw() = 0;\n};\n\nclass <g>linuxbutton</g> : public <g>widget</g> {\npublic:\n   void draw() { cout << <r>"linuxbutton "</r>; }\n};\nclass <g>linuxmenu</g> : public <g>widget</g> {\npublic:\n   void draw() { cout << <r>"linuxmenu "</r>; }\n};\n\nclass <g>windowsbutton</g> : public <g>widget</g> {\npublic:\n   void draw() { cout << <r>"WindowsButton "</r>; }\n};\nclass <g>windowsmenu</g> : public <g>widget</g> {\npublic:\n   void draw() { cout << <r>"WindowsMenu "</r>; }\n};\n\nclass <g>factory</g> {\npublic:\n   virtual widget* create_button() = 0;\n   virtual widget* create_menu() = 0;\n};\n\nclass <g>linuxfactory</g> : public <g>factory</g> {\npublic:\n   widget* create_button() {\n      return new linuxbutton; }\n   widget* create_menu()   {\n      return new linuxmenu; }\n};\n\nclass <g>windowsfactory</g> : public <g>factory</g> {\npublic:\n   widget* create_button() {\n      return new windowsbutton; }\n   widget* create_menu()   {\n      return new windowsmenu; }\n};\n\nint main( void ) {\n factory* factory;\n#ifdef MOTIF\n factory = new linuxfactory;\n#else // WINDOWS\n factory = new windowsfactory;\n#endif\n\n widget* w1 = factory->create_button();\n widget* w2 = factory->create_menu();\n w1->draw();\n w2->draw();\n}\n</cb>\n\nResult\n<c>\nWindowsButton\nWindowsMenu\n</c>\n\n <b> - Builder Pattern</b>\n As the name suggest a builder pattern is used when an entity (builder) creates a complex object in parts (predefined). A builder pattern exposes various methods of creating complex structures and it is the director who calls for these methods and once the structure is ready the builder returns to the director. In Indian restaurants there are built food items including Masala Dosa, Samosa, and Aaloo Paratha. These items are built through three different Builders The builders follow same steps, which are (a) Making dough (b) Putting potato (c) Baking it. The waiter who receives the order undertakes the three steps of builder without knowing the details. Once the food item is ready the waiter returns the item to the customer.\n\n<cb>\n                                       . . . . . . . . . . . . . . ..\n                                       .                            .\n        +-----------------+            .  +----------------+        .\n        |<g>waiter(director)</g> | . . . . . ..  |<g>builder</g>         |        .\n        +-----------------+               +----------------+     <l><<uses>></l>\n        |                 | ------------> |<g>prodct:product</g>  |        .\n        |                 |    <l><<uses>></l>   +----------------+        .\n        |construct(builder|               |makedough():void|        .\n        |   :builder):void|               |putpotato():void|<>---   .\n        |getproduct():    |               |bakeit():void   |    |   .\n        |          product|               |getproduct():   |    |   .\n        +-----------------+               |         product|    |   .\n                                          +----------------+    |   .\n                                                  / \\           |   .\n                                                   -            |   .\n                                        <l><<extends>></l>|  <l><<aggregates>></l>.\n         -------------------------------------------            |   .\n         |                |                        |            v   V\n  +-------------+  +-------------+   +-----------------+ +---------------+\n  |<g>dosabuilder</g>  |  |<g>samosabuilder</g>|   |<g>aalooprathabuiler</g>| |   <g>product</g>     |\n  +-------------+  +-------------+   +-----------------+ +---------------+\n  |makedough(): |  |makedough(): |   |makedough():void | |setdough(type: |\n  |         void|  |         void|   |putpotato():void | |   string):void|\n  |putpotato(): |  |putpotato(): |   |bakeit():void    | |setpotator(type|\n  |         void|  |         void|   +-----------------+ |   :string)void|\n  |bakeit():void|  |bakeit():void|                       |setbaketype(typ|\n  +-------------+  +-------------+                       | e:string):void|\n                                                         +---------------+\n</cb>\n\nCode\n<cb>\n#include <iostream>\nusing namespace std;\n\nclass <g>product</g>{\npublic:\nvoid dough(const string& type) {\ncout<<<r>"dough : "</r><<type<<endl;\n}\nvoid aloo(const string& type) {\ncout<<<r>"aloo : "</r><<type<<endl;\n}\nvoid fry(const string& type) {\ncout<<<r>"fry : "</r><<type<<endl;\n}\n};\n\nclass <g>builder</g>{\npublic:\n virtual void makedough()=0;\n virtual void putaloo()=0;\n virtual void fry()=0;\n virtual product* getresult()=0;\n};\n\n\nclass <g>dosabuilder</g>:public <g>builder</g>{\n product* _product;\npublic:\n dosabuilder(){\n  _product=new product;\n }\n void makedough(){\n  _product->dough("wet");\n }\n void putaloo(){\n  _product->aloo("fried");\n }\n void fry(){\n  _product->fry("oil fried");\n }\n product* getresult(){\n  return _product;\n }\n};\n\nclass <g>samosabuilder</g>:public <g>builder</g>{\n product* _product;\npublic:\n samosabuilder(){\n  _product=new product;\n }\n void makedough(){\n  _product->dough("dry");\n }\n void putaloo(){\n  _product->aloo("fried");\n }\n void fry(){\n  _product->fry("deep fried");\n }\n product* getresult(){\n  return _product;\n }\n};\n\nclass <g>director</g>{\npublic:\nvoid construct(builder *bp){\nbp->makedough();\nbp->putaloo();\nbp->fry();\n}\n};\n\nint main(void){\ndirector *directori=new director;\ndirectori->construct(new dosabuilder);\ndirectori->construct(new samosabuilder);\nreturn 0;\n}\n</cb>\n\nOutput\n<c>\npi@raspberrypi:~/tmp/MISC/gc $ ./a.out\ndough : wet\naloo : fried\nfry : oil fried\ndough : dry\naloo : fried\nfry : deep fried\n</c>\n\n <b> - Singleton pattern </b>\n As name suggests when only single object of a class is created, the pattern we use to achieve this is singleton pattern. If object creation function is used more than once the already created object is returned.  i.e. Someone needs to draw many coffee mugs and all look equal but different in position on screen. So one object is enough as far as look is concern. Position can be adjusted externally. Here factory would create a singleton object. In a province where king can be one. All calls to get the king would return the same king.\n\n<cb>\n#include <iostream>\nusing namespace std;\n\nclass <g>singletonclass</g> {\n singletonclass(){}\n static singletonclass* instance;\npublic:\n static singletonclass* getinstance() {\n  if (! instance )\n   instance = new singletonclass;\n  return instance;\n }\n};\nsingletonclass* singletonclass::instance = 0;\n\n\nint main( void ) {\n singletonclass *inst1=singletonclass::getinstance();\n singletonclass *inst2=singletonclass::getinstance();\n cout<<<r>"instances address"</r><<endl<<inst1<<endl<<inst2<<endl;\nreturn 0;\n}\n</cb>\n\nResult\n<c>\ninstances address\n0x678f10\n0x678f10\n</c>\n\n\n<h>\n*Cloning\n - Prototype Pattern\n</h>\n\nWhen cloning of an object is required this pattern is used When an object is created it modifies its state and other data structure. When a new object carry requirement of having a copy of current state of an object, object has to clone itself. Every implementation class overrides abstract class clone function. a guru makes shishya(students) those are clone of him.They carry same knowledge and guru does not lose anything.\n\n<cb>\n --------                     +---------+\n |<g>client</g>| ------------------> |<g>widget</g>   |<l>//prototype</l>\n --------                     +---------+\n                              |clone():p|\n                              | rototype|\n                              +---------+\n                                  / \\\n                                   -\n                                   |<l><<extends>></l>\n                 --------------------------------------\n                 |                 |                  |\n            +---------+        +----------+      +----------+\n            | <g>button</g>  |        |  <g>menu</g>    |      | <g>combobox</g> |\n            +---------+        +----------+      +----------+\n            |clone():p|        |clone():  |      |clone():  |\n            | rototype|        | prototype|      | prototype|\n            +---------+        +----------+      +----------+\n</cb>\n\nCode\n<cb>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass <g>widget</g> {\npublic:\n static widget* shapetypes[4];\n virtual widget* clone() = 0;\n virtual void draw() = 0;\n virtual void enable(bool) =0;\n};\n\nclass <g>button</g> : public <g>widget</g> {\npublic:\n widget* clone(){return new button;}\n void draw() { cout << <r>"Button::draw"</r><<endl; }\n void enable(bool e_d) { cout << <r>"Button::enable "</r><< e_d<<endl; }\n};\nclass <g>menu</g> : public <g>widget</g> {\npublic:\n widget* clone(){return new menu;}\n void draw() { cout << <r>"Menu::draw"</r><<endl; }\n void enable(bool e_d) { cout << <r>"Menu::enable "</r><< e_d<<endl; }\n};\nclass <g>combobox</g> : public <g>widget</g> {\npublic:\n widget* clone(){return new combobox;}\n void draw() { cout << <r>"Combobox::draw"</r><<endl; }\n void enable(bool e_d) { cout << <r>"Combobox::enable "</r><< e_d<<endl; }\n};\n\nwidget* widget::shapetypes[4]={0,new button, new menu, new combobox};\n\n\nint main(void) {\n vector<widget*> shape;\n int choice;\n while (true) {\n  cout << <r>"enter you choice, (1)button, (2)menu, (3)combobox, 9(exit)"</r><<endl;\n  cin >> choice;\n  if (choice == 9)\n   break;\n  shape.push_back( widget::shapetypes[choice]->clone() );\n }\n  for (int i=0; i < shape.size(); i++){\n   shape[i]->enable(true);\n   shape[i]->draw();\n  }\n  for (int i=0; i < shape.size(); i++)\n   delete shape[i];\n return 0;\n}\n</cb>\n\nOutput\n<c>\npi@raspberrypi:~/tmp/MISC/gc $ ./a.out\nenter you choice, (1)button, (2)menu, (3)combobox, 9(exit)\n1\nenter you choice, (1)button, (2)menu, (3)combobox, 9(exit)\n2\nenter you choice, (1)button, (2)menu, (3)combobox, 9(exit)\n3\nenter you choice, (1)button, (2)menu, (3)combobox, 9(exit)\n9\nButton::enable 1\nButton::draw\nMenu::enable 1\nMenu::draw\nCombobox::enable 1\nCombobox::draw\n</c>'
'5!ABS SBA!GOF Structural Design Pattern!ABS SBA!!ABS SBA!<h>\n*Composition patterns\n - Adapter pattern\n - Bridge pattern\n - Facade pattern\n - Flyweight pattern\n - Proxy pattern\n</h>\n\nStructural patterns deal with the layout of how the attributes of the class/design is distributed and related. The class deals with static structure of the design and not how object interacts with each other. There are various categories it can be distributed in.\n\na) When a structure composes another different structure.\nb) When a structure is derived from others, inherits and extends parent property.\nc) When a structure composes others and inherit the same.\n\nAdapter (object), bridge, facade, flyweight are examples of a structure that compose a different structure. Proxy and Adapter (class) are examples of structures derived from other structures. Composite and decorator derive and compose the same, apart from these other structural patterns have a base in one of the creational patterns. A structural pattern is based on a specific creational pattern. Similarly behavioral pattern has a base on structural patterns.\n\n<c>\n +---------------------+\n |structural pattern   |\n +---------------------------+\n |creational pattern         |\n +---------------------------+\n\n\n                             |----->Adapter(object)\n                composition  |      (factory)\n              |------------->+\n              |              |\n              |              |----->Bridge\n              |              |      (factory)\n              |              |\n              |              |----->Facade\n              |              |      (factory)\n              |              |\n              |              |----->Flyweight\n              |                     (factory/singleton)\n              |\n              |\n              |              |----->Proxy\n              |              |      (factory/builder)\n              | Inheritance  |\n structural-->+------------->+\n pattern      |              |\n              |              |----->Adapter(class)\n              |                     (factory)\n              |\n              |\n              |                        |-->Composite\n              |                        |   (factory)\n              | composition+inheritance|\n              |----------------------->+\n                                       |\n                                       |-->Decorator\n                                           (factory/singleton)\n</c>\n\n<b>- Compostion Pattern</b>\nStructural patterns work through compositing other structures. The first, structure that composes other structures, somewhere delegates the client calls in order to maximize its usage. Composed structure is generally passed to the first one through the client. This kind of pattern have primary structure and composed structure where primary structure delegates the client call to composed one, both client and primary structure keeps interfaces of the next one and mix their code with interface methods. This makes client and primary structure code close for changes.\n\n<c>\n -------- <<uses>> +---------------------+\n |client| -------> |primarystrucInterface|<>--\n --------          +---------------------+   |<<delegate calls to>>\n                         / \\                 |   +----------------------+\n                          -                  --->|composedstrucinterface|\n                          |                      +----------------------+\n                   +--------------+                       / \\\n                   |Implementation|                        -\n                   +--------------+                        |\n                                                   +--------------+\n                                                   |implementation|\n                                                   +--------------+\n</c>\n\n <b>- Adpater</b>\nWhen adaptee\'s interface varies from client interface, a client expects this Pattern to be used. It changes client supported interface to adaptee\'s interface and hence enable the client to use adaptee. An adapter can be of two types. First type one, \'object type\' where adaptee interface is contained in adapter and any subclass of adaptee can be contained in adapter at run time; whereas the second one is \'class type\' where adaptee is also a base class for adapter. When two individuals communicate with one another with different languages, both have to use a multilingual two way adapter to let them communicate even though they do not understand each other\'s language.\n\nobject type:\n\n<c>\n                  <<target interface>>\n --------           +---------------+\n |client| --------> |    memory     |\n --------           +---------------+\n                    |adaptee:cameram|<>--\n                    |       emory   |   |\n                    +---------------+   |\n                    |fetchvideo(name|   |\n                    |  :string):void|   |\n                    +---------------+   |\n                           / \\         |\n                            -           |\n                            |           |     <<adaptee interface>>\n                    +---------------+   |       +------------------+\n         <<adapter>>| memoryadapter |   +-----> |   cameramemory   |\n                    +---------------+           +------------------+\n                    |fetchvideo(name|           |setmode(mode:int):|\n                    |  :string):void|           |              void|\n                    +---------------+           |getfile(file:strin|\n                                                |            g:void|\n                                                +------------------+\n                                                         / \\\n                                                          -\n                                                          |\n                                       --------------------------\n                                       |\n                             +------------------+\n                             |  nickoncameramem |\n                             +------------------+\n                             |setmode(mode:int):|    . . .\n                             |              void|\n                             |getfile(file:strin|\n                             |           g):void|\n                             +------------------+\n</c>\n\nCode\n<c>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass cameramemory {\npublic:\nint mode;\nstring videofile;\nvirtual void setmode(int)=0;\nvirtual const string& getfile(const string&)=0;\n};\n\nclass nikoncameramemory:public cameramemory {\npublic:\nvoid setmode(int modep) {\nmode=modep;\nif (modep==1)\n cout<<"nikoncameramemory::CHANGED TO READ MODE ";\nelse\n cout<<"nikoncameramemory::CHANGED TO WRITE MODE ";\n}\nconst string& getfile(const string& name) {\nif (!mode)\n videofile="ERROR in MODE, can not read in write mode, change the mode ";\nelse{\ncout<<"nikoncameramem::serving file : MEMFILE1"<<endl;\nvideofile="MEMFILE1";\n}\nreturn videofile;\n}\n};\n\nclass memory{\npublic:\nmemory(){\nadaptee = new nikoncameramemory;\n}\ncameramemory *adaptee;\nvirtual const string& fetchvideo(const string&)=0;\nvirtual ~memory(){\ndelete adaptee;\n}\n};\n\nclass memoryadapter:public memory{\npublic:\nconst string& fetchvideo(const string& name){\nadaptee->setmode(1);\nreturn adaptee->getfile(name);\n}\n};\n\nint main(){\nmemory *madapter=new memoryadapter;\ncout<<madapter->fetchvideo("earth song")<<endl;\ndelete madapter;\nreturn 0;\n}\n</c>\n\nOutput\n<c>\nnikoncameramemory::CHANGED TO READ MODE\nnikoncameramem::serving file : MEMFILE1\nMEMFILE1\n</c>\n\n\n <b>- Bridge Pattern</b>\nWhen an abstract has several implementations and each implementation (say abstract implementation) grows to a number of sub implementations then classes at sub implementation level exists in many numbers.  Same set of sub implementations are available for each abstract implementation. It is important to separate abstract implementation tree with the sub implementation tree. This way abstract implementation and its sub implementation grows independently. In sub implementation tree each sub implementation creates bridge to an abstract implementation. sub implementation is interface to client where the abstract implementation is the real implementation which is delegated for clients call to interfaces. For example there are drawings, APIs used across application types. All application types inherit all drawing APIs. If there are three application types supported and one new drawing API is available then three more inheritance are required.  Better way to avoid that is to separate application hierarchy from drawing API hierarchy. Each application implementation creates a bridge to API implementation interface. In a country\'s political system there can be multiple parties and each party has a president, vice president, secretary etc. Now the number of parties and posts increases adjacently. An individual wants to be a secretary in party A and another person wants to be a president in the same party A. If we have an abstract class Post and then for each Post implementation, all parties are subclasses, then the total number of party classes would be too many. Here we can have Posts and Parties separate hierarchy and for a person to become a Post holder in a Party, will instantiate the party implementation by passing the Post implementation.\nLike new party A (new secretary).This way he becomes secretary in party A.\n\n<c>\n +-------------+                               +--------------------+\n |<<interface>>|                               | <<interface impl>> |\n | application |<>---------------------------> |    drawingapi      |\n +-------------+                               +--------------------+\n |dapi:drawinga|                               |drawcircle():void   |\n |   pi        |                               |drawrectangle():void|\n +-------------+                               +--------------------+\n |drawcircle():|                                        / \\\n |void         |                                         -\n |drawrectangle|                                         |\n |():void      |                                         |\n +-------------+                                         |\n      / \\                                  ---------------------------\n       -                                   |                         |\n       |                                +-------------+   +-------------+\n       ------------------               | drawingapi1 |   |drawingapi2  |\n       |                |               +-------------+   +-------------+\n +---------------+ +-----------------+  |drawcircle():|   |drawcircle():|\n |winapplication | |unixapplication  |  |         void|   |         void|\n +---------------+ +-----------------+  |drawrectangle|   |drawrectangle|\n |drawcircle():  | |drawcirlcle():   |  |      ():void|   |      ():void|\n |void           | |void             |  +-------------+   +-------------+\n |drawrectangle()| |drawrectangle(): |\n |:void          | |void             |\n +---------------+ +-----------------+\n</c>\n\n<c>\n#include <iostream>\nusing namespace std;\n\nclass drawingapi {\npublic:\nvirtual void drawcircle(int,int,int)=0;\nvirtual void drawrectangle(int,int,int,int)=0;\n};\n\nclass drawingapi1:public drawingapi{\npublic:\nvoid drawcircle(int x1, int x2, int radius) {\ncout<<"drawingapi1::drawcircle x1:"<<x1<<" x2:"<<x2<<" radius:"<<radius<<endl;\n}\nvoid drawrectangle(int x1, int x2, int width, int height){\ncout<<"drawingapi1::drawrectangle x1:"<<x1<<" x2:"<<x2<<" width:"<<width<<" height:"<<height<<endl;\n}\n};\n\nclass drawingapi2:public drawingapi{\npublic:\nvoid drawcircle(int x1, int x2, int radius) {\ncout<<"drawingapi2::drawcircle x1:"<<x1<<" x2:"<<x2<<" radius:"<<radius<<endl;\n}\nvoid drawrectangle(int x1, int x2, int width, int height){\ncout<<"drawingapi2::drawrectangle x1:"<<x1<<" x2:"<<x2<<" width:"<<width<<" height:"<<height<<endl;\n}\n};\n\nclass application {\npublic:\ndrawingapi* dapi;\napplication(drawingapi *drawingapip):dapi(drawingapip){}\nvirtual void drawcircle(int x,int y,int radius)=0;\nvirtual void drawrectangle(int x,int y,int w,int h)=0;\nvirtual ~application(){delete dapi;}\n};\n\nclass windowsapplication:public application {\npublic:\nusing application::application;\nvoid drawcircle(int xp,int yp,int radiusp){\ndapi->drawcircle(xp,yp,radiusp);\n}\nvoid drawrectangle(int xp,int yp,int wp,int hp){\ndapi->drawrectangle(xp,yp,wp,hp);\n}\n};\n\nclass unixapplication:public application {\npublic:\nusing application::application;\nvoid drawcircle(int xp,int yp,int radiusp){\ndapi->drawcircle(xp,yp,radiusp);\n}\nvoid drawrectangle(int xp,int yp,int wp,int hp){\ndapi->drawrectangle(xp,yp,wp,hp);\n}\n};\n\nint main(void){\napplication *winapp=new windowsapplication(new drawingapi1);\nwinapp->drawcircle(50,50,100);\nwinapp->drawrectangle(20,40,100,200);\napplication *unixapp=new unixapplication(new drawingapi2);\nunixapp->drawcircle(25,25,100);\nunixapp->drawrectangle(60,80,100,200);\ndelete winapp;\ndelete unixapp;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\ndrawingapi1::drawcircle x1:50 x2:50 radius:100\ndrawingapi1::drawrectangle x1:20 x2:40 width:100 height:200\ndrawingapi2::drawcircle x1:25 x2:25 radius:100\ndrawingapi2::drawrectangle x1:60 x2:80 width:100 height:200\n</cc>\n\n<pre style="color:#004000;font-weight:bold;display:inline-block">Article</pre>\n<m>https://www.codeguru.com/IoT/coding-sensors-on-the-rpi3.html</m>\n<m>http://minhinc.42web.io/image/dp_training_bridge2.jpeg</m>\n\n\n<m>https://www.codeguru.com/IoT/coding-analog-sensors-on-the-raspberry-pi3.html</m>\n<m>http://minhinc.42web.io/image/dp_training_bridge.jpeg</m>\n\n <b>- Facade</b>\nWhen an extra interface is required for handling complex underlying Components, facade pattern is used. This makes various underlying classes easy to use through facade interface. Facade interface delegates calls to underlying implementations. For example there are separate components that undertakes specific tasks. An adder; adds two numbers, multiplier; multiplies two numbers and a divider divides two numbers. There is a facade abstract data type calculator which provides interface for evaluating an expression and delegating the expression parts to separate components. There are many departments in a province and ministers taking care of each department. It\'s the prime minister\'s mandate though to interact with people for their complex issues though he may not handle every department.\n\n<c>\n                       ---------         ---------\n                       |client1|         |client2|\n                       ---------         ---------\n                            \\               /\n +----------------+          \\             /\n |     adder      |<--        \\           /\n +----------------+  |         \\ <<uses>>/\n |compute(expressi|  |          \\       /\n | on:string):void|  |           v     v\n +----------------+  |     +---------------------+\n                     +---<>|   calculator        |<>-  +----------------+\n +----------------+  |     +---------------------+  |  |    Divider     |\n |   subtracter   |<--     |DIVIDER:divider      |  |  +----------------+\n +----------------+        |MULTIPLIER:multiplier|  |  |compute(expressi|\n |compute(expressi|        |ADDER:adder          |  |  | on:string):void|\n | on:string):void|        |SUBTRACTER:subtracter|  |  +----------------+\n +----------------+        +---------------------+  |          ^\n                           |compute(expression:st|  |          |\n                           |           ring):void|  ----+-------\n                           +---------------------+      |\n                                                        |\n                                                    <<aggregates>>\n                                                        |\n                           +------------------+         |\n                           |   multiplier     |         |\n                           +------------------+<---------\n                           |compute(expression|\n                           |     :string):void|\n                           +------------------+\n</c>\n\n<c>\n#include <iostream>\n#include <regex>\nusing namespace std;\n\nclass adder{\npublic:\nfloat compute(float leftp, float rightp){\n cout<<"adder:: left:"<<leftp<<" right:"<<rightp<<endl;\n return leftp+rightp;\n}\n};\n\nclass subtracter{\npublic:\nfloat compute(float leftp, float rightp){\n cout<<"subtracter:: left:"<<leftp<<" right:"<<rightp<<endl;\n return leftp-rightp;\n}\n};\n\nclass multiplier{\npublic:\nfloat compute(float leftp, float rightp){\n cout<<"multiplier:: left:"<<leftp<<" right:"<<rightp<<endl;\n return leftp*rightp;\n}\n};\n\nclass divider{\npublic:\nfloat compute(float leftp, float rightp){\n cout<<"divider:: left:"<<leftp<<" right:"<<rightp<<endl;\n return leftp/rightp;\n}\n};\n\nclass calculator {\nadder *adderi;\nsubtracter *subtracteri;\nmultiplier *multiplieri;\ndivider *divideri;\npublic:\nfloat compute(const string& expression){\nsmatch sm;\nif(regex_search(expression,sm,regex("(.+?)\\\\+(.*)")) == true)\n adderi->compute(this->compute(sm.str(1)),this->compute(sm.str(2)));\nelse if(regex_search(expression,sm,regex("(.+?)\\\\-(.*)")) == true)\n subtracteri->compute(this->compute(sm.str(1)),this->compute(sm.str(2)));\nelse if(regex_search(expression,sm,regex("(.+?)\\\\*(.*)")) == true)\n multiplieri->compute(this->compute(sm.str(1)),this->compute(sm.str(2)));\nelse if(regex_search(expression,sm,regex("(.+?)\\\\/(.*)")) == true)\n divideri->compute(this->compute(sm.str(1)),this->compute(sm.str(2)));\nelse\n return stof(expression);\n}\n};\n\nint main(void){\ncalculator calc;\ncout<<"expression:  1-2+4*3-6/2+8*3-2*70/10"<<endl;\ncout<<calc.compute("1-2+4*3-6/2+8*3-2*70/10");\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nexpression:  1-2+4*3-6/2+8*3-2*70/10\nsubtracter:: left:1 right:2\nmultiplier:: left:4 right:3\ndivider:: left:6 right:2\nsubtracter:: left:12 right:3\nmultiplier:: left:8 right:3\ndivider:: left:70 right:10\nmultiplier:: left:2 right:7\nsubtracter:: left:24 right:14\nadder:: left:9 right:10\nadder:: left:-1 right:19\n</cc>\n\n <b>- Flyweight</b>\nWhen a class requires multiple instantiation and all have common properties only a few of them differs then it\'s wise to instantiate only one object. Meanwhile if most of the properties are not common, among them would be provided externally; in this kind of situation flyweight pattern is used. Objects common property is maintained only once in memory whereas, properties different for each instantiation are passed from outside. The common intrinsic property save a memory, while extrinsic property is passed only when required. For example, in a housing colony map there are many houses in the map spread across various sectors and plots, but houses would be in certain types only.  Type A, type B, type C, and type D(say). Each type has similar look and feel so graphic data structure needs to be created only once for each type where same graphic is shown at different places in the map and only vary in space coordinates. House types are intrinsic characteristics while house location is extrinsic characteristics. An army officer does not know each solder individually but he knows about different types of soldier groups (battalions) with different attires. An Army officer thinks about deploying soldier groups to various places in war.\n\n<c>\n --------          +---------------+\n |client| -------> | housefactory  | <<aggregates>>  +----------------+\n --------          +---------------+<>-------------> |  housetype     |\n                   |gethouse(type:s|                 +----------------+\n                   |   tring):house|   intrinsic...> |type:string     |\n                   -----------------                 +----------------+\n                                                     |gethousetype():s|\n         +---------------+        -------------------|           tring|\n         |locationcontext|        |   <<uses>>       +----------------+\n         +---------------+        | <<extrinsic>>           / \\\n         |sector:int     | <------                           -\n         |plot:int       |                                   |\n         +---------------+                          +--------------+\n         |getlocation():i|                          |   house      |\n         |             nt|                          +--------------+\n         +---------------+                          |gethousetype()|\n                                                    |       :string|\n                                                    |build():void  |\n                                                    +--------------+\n</c>\n\nCode\n<c>\n#include <iostream>\n#include <map>\nusing namespace std;\n\n\nclass housetype {\nstring type;\npublic:\nhousetype(){}\nhousetype(const string& typep):type(typep){}\nconst string& gethousetype(){\nreturn type;\n}\n};\n\nclass locationcontext {\nint _sector,_plot;\npublic:\nlocationcontext(int sectorp,int plotp):_sector(sectorp),_plot(plotp){}\nint sector() const {return _sector;}\nint plot() const {return _plot;}\n};\n\nclass house:public housetype {\npublic:\nhouse(){};\nhouse(const string& type):housetype(type){}\nvoid build(const locationcontext& lcp){\ncout<<"house with type : "<<gethousetype()<<" constructed at sector number : "<<lcp.sector()<<", plot number : "<<lcp.plot()<<endl;\n}\n};\n\nclass housefactory{\nmap<string,house> typemap;\npublic:\nhouse& gethouse(const string& housetype){\nif (!typemap.count(housetype))\ntypemap[housetype]=house(housetype);\nreturn  typemap[housetype];\n}\n};\n\nint main(void){\nhousefactory housefactoryi;\nhousefactoryi.gethouse("A").build(locationcontext(10, 1));\nhousefactoryi.gethouse("B").build(locationcontext(10, 2));\nhousefactoryi.gethouse("A").build(locationcontext(10, 3));\nhousefactoryi.gethouse("A").build(locationcontext(10, 4));\nhousefactoryi.gethouse("B").build(locationcontext(10, 5));\nhousefactoryi.gethouse("B").build(locationcontext(10, 7));\nhousefactoryi.gethouse("C").build(locationcontext(11, 1));\nhousefactoryi.gethouse("C").build(locationcontext(11, 2));\nhousefactoryi.gethouse("C").build(locationcontext(11, 4));\nhousefactoryi.gethouse("D").build(locationcontext(11, 5));\nhousefactoryi.gethouse("D").build(locationcontext(11, 7));\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nhouse with type : A constructed at sector number : 10, plot number : 1\nhouse with type : B constructed at sector number : 10, plot number : 2\nhouse with type : A constructed at sector number : 10, plot number : 3\nhouse with type : A constructed at sector number : 10, plot number : 4\nhouse with type : B constructed at sector number : 10, plot number : 5\nhouse with type : B constructed at sector number : 10, plot number : 7\nhouse with type : C constructed at sector number : 11, plot number : 1\nhouse with type : C constructed at sector number : 11, plot number : 2\nhouse with type : C constructed at sector number : 11, plot number : 4\nhouse with type : D constructed at sector number : 11, plot number : 5\nhouse with type : D constructed at sector number : 11, plot number : 7\n</cc>\n\n<h>\n*Inheritance pattern\n - Proxy pattern\n - Adapter pattern\n</h>\n<b>Inheritance</b>\nIn this structural pattern, classes grow their attributes through inheritance rather than composition. This makes attributes static at run time. This pattern is used when either primary interface and delegatee both have same interface methods or primary interface implementation is derived from delegatee implementation, in this case delegatee methods would not extend.\n\n<c>\n --------                             +---------+\n |client| --------------------------> |interface|\n --------                             +---------+\n                                          / \\\n                                           -\n                                           |\n                          ---------------------------------\n                          |                               |\n                 +-----------------+              +--------------+\n                 |primary interface|<>----------->|implementation|\n                 +-----------------+              +--------------+\n</c>\n\n <b>- Proxy</b>\nA Class that acts as an interface to other class or classes is called proxy. There can be a scenario when target class is expensive to duplicate and a virtual class needs to be instantiated to many places but in return passes the call to target class for service. For example, a database program server requests based on query. It captures database in memory in order to provide the service. Loading database is a costly operation and may not be possible at low end machines And so instantiating the database class would load the database. Since memory consumption is high, this class can typically be instantiated at high end servers only. Programs in other machines that need database service cannot instantiate database class. Virtual database class is crucial as it provides exactly same interface as real database class but internally keeps cached information and serves the client internally and when required it gives real database program instance for the service. For the client programs they only instantiate real database programs (classes) and use same methods. Every country has an immigration department and some of them provide permission to stay in their country when you visit the country and they do not place their proxies in other countries.\n\n<c>\n -----------                    +-----------------+\n |client   |  ----------------> |  <<interface>>  |\n -----------                    |     database    |\n                                +-----------------+\n                                |addtable(id:int,t|\n                                | able:TABLE):void|\n                                |gettable(id:int):|\n                                |            TABLE|\n                                +-----------------+\n                                        / \\\n                                         -\n                                         |\n    ----------------------------------------------------\n    |                                |                 |\n +------------------+    +----------------------+     +-----------------+\n |writedatabaseproxy|<>- |readonlydatabaseproxy |<>-- |  targetdatabase |\n +------------------+  | +----------------------+   | +-----------------+\n |target:database   |  | |target:database       |   | |addtable(id:int,t|\n |cache:tablecache  |  | |cache:tablecache      |   | | able:TABLE):void|\n +------------------+  | +----------------------+   | |gettable(id:int):|\n |addtable(id:int,ta|  | |gettable(id:int):TABLE|   | +-----------------+\n |   ble:TABLE):void|  | |getTablesize(tableid: |   |          ^\n |gettable(id:int):T|  | |              int):int|   |          |\n |              ABLE|  | +----------------------+   |          |\n |gettablesize(id:in|  |                            |          |\n |            t):int|  +----------------------------+----------+\n +------------------+  |            <<aggregates>>\n                       |\n                       v\n           +--------------+\n           |tablecache    |\n           +--------------+\n           |addtable(id:in|\n           |      t):TABLE|\n           |gettablesize(i|\n           |    d:int):int|\n           +--------------+\n</c>\n\n<c>\n#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nclass targetdatabase;\nclass tablecache;\n\nclass database {\npublic:\nstatic targetdatabase* _tdb;\nstatic tablecache* _tch;\ntargetdatabase* gettargetdatabase();\ntablecache* gettablecache();\nvirtual void addtable(const string&, const vector<int>&)=0;\nvirtual vector<vector<int>>& gettable(const string&)=0;\nvirtual int gettablesize(const string&)=0;\n};\n\n\ntargetdatabase* database::_tdb=NULL;\ntablecache* database::_tch=NULL;\n\nclass targetdatabase:public database {\nmap<string,vector<vector<int>>> tablemap;\npublic:\nvoid addtable(const string& tablename, const vector<int>& datap){\nif (!tablemap.count(tablename))\n tablemap[tablename]=vector<vector<int>>();\ntablemap[tablename].push_back(datap);\n}\nvector<vector<int>>& gettable(const string& tablename){\nreturn tablemap[tablename];\n}\nint gettablesize(const string& tablename){\nreturn tablemap[tablename].size();\n}\n};\n\n\nclass tablecache {\nmap<string,int> tablemap;\nint size;\npublic:\nvoid addtable(const string& namep, int sizep){\nif (!tablemap.count(namep))\ntablemap[namep]=sizep;\nelse\ntablemap[namep]+=sizep;\n}\nint getsize(const string& tablenamep){\nreturn tablemap[tablenamep];\n}\n};\n\ntargetdatabase* database::gettargetdatabase(){\nif (!_tdb)\n_tdb=new targetdatabase;\nreturn _tdb;\n}\ntablecache* database::gettablecache(){\nif (!_tch)\n_tch=new tablecache;\nreturn _tch;\n}\n\nclass writedatabaseproxy:public database{\npublic:\nvoid addtable(const string& name, const vector<int>& datap){\ngettargetdatabase()->addtable(name,datap);\ngettablecache()->addtable(name,1);\n}\nvector<vector<int>>& gettable(const string& namep){\nreturn gettargetdatabase()->gettable(namep);\n}\nint gettablesize(const string& tablename){\ngettablecache()->getsize(tablename);\n}\n};\n\nclass readdatabaseproxy:public database{\npublic:\nvoid addtable(const string& name, const vector<int>& datap){\n}\nvector<vector<int>>& gettable(const string& namep){\nreturn gettargetdatabase()->gettable(namep);\n}\n\nint gettablesize(const string& tablename){\ngettablecache()->getsize(tablename);\n}\n};\n\nint main(void){\nwritedatabaseproxy wdp;\nreaddatabaseproxy rdp;\nwdp.addtable("one",vector<int>{1, 2, 3});\nwdp.addtable("one",vector<int>{4, 5, 6});\nwdp.addtable("one",vector<int>{7, 8, 9});\nwdp.addtable("two",vector<int>{11, 12, 13});\nwdp.addtable("two",vector<int>{14, 15, 16});\nwdp.addtable("two",vector<int>{17, 18, 19});\nwdp.addtable("two",vector<int>{20, 21, 22});\ncout<<"table size for tableid: one :"<<rdp.gettablesize("one")<<endl;\ncout<<"table size for tableid: two :"<<rdp.gettablesize("two")<<endl;\ncout<<"table data for tableid: two :"<<endl;\nfor(int i=0;i<rdp.gettable("two").size();i++){//<<rdp.gettable("two")<<endl;\n for(int j=0;j<rdp.gettable("two")[i].size();j++)\n  cout<<rdp.gettable("two")[i][j]<<" ";\n cout<<endl;\n}\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\ntable size for tableid: one :3\ntable size for tableid: two :4\ntable data for tableid: two :\n11 12 13\n14 15 16\n17 18 19\n20 21 22\n</cc>\n\n <b>- Adapter class</b>\nAdapter class type serves the same function as the adapter object type. adapter (and its subclasses) in addition to target it\'s also derived from the adaptee. This makes delegation easy whereas sub classing adaptee is not possible.\n\n<c>\n                        <<target interface>>\n --------                  +--------------+\n |client|----------------->|   memory     |\n --------                  +--------------+   <<adaptee class impl>>\n                           |getvideo(name:|      +---------------+\n                           |  string):void|      | cameramemory  |\n                           +--------------+      +---------------+\n                                 / \\             |getfile(name:st|\n                                  -              |     ring):void|\n                                  |              |setmode(mode:in|\n                                  |              |        t):void|\n                                  |              +---------------+\n                                  <<extends>>            / \\\n                                  |                       -\n                                  |                       |\n                                  +-----------------------+\n                                  |\n                           +---------------+\n                           | memoryadapter |\n                           +---------------+\n                           |getvideo():void|\n                           |getfile():void |\n                           |setmode():void |\n                           +---------------+\n                                  / \\\n                                   -\n                                   |\n                         +-------------------+\n                         |cameramemoryadapter|\n                         +-------------------+\n                         |getvideo():void    |\n                         |getfile():void     |\n                         |setmode():void     |\n                         +-------------------+\n</c>\n\nCode\n<c>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass memory{\npublic:\nvirtual const string& fetchvideo(const string&)=0;\n};\n\nclass cameramemory {\npublic:\nint mode;\nstring videofile;\nvirtual void setmode(int)=0;\nvirtual const string& getfile(const string&)=0;\n};\n\nclass nikoncameramemory:public cameramemory {\npublic:\nvoid setmode(int modep) {\nmode=modep;\nif (modep==1)\n cout<<"nikoncameramemory::CHANGED TO READ MODE"<<endl;\nelse\n cout<<"nikoncameramemory::CHANGED TO WRITE MODE"<<endl;\n}\nconst string& getfile(const string& name) {\nif (!mode)\n videofile="ERROR in MODE, can not read in write mode, change the mode";\nelse{\n cout<<"nikoncameramem::serving file : MEMFILE1"<<endl;\n videofile="MEMFILE1";\n}\nreturn videofile;\n}\n};\n\nclass memoryadapter:public memory,public nikoncameramemory {\npublic:\nconst string& fetchvideo(const string& name){\nsetmode(1);\nreturn getfile(name);\n}\n};\n\nint main(){\nmemory *madapter=new memoryadapter;\ncout<<madapter->fetchvideo("earth song")<<endl;\ndelete madapter;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nnikoncameramemory::CHANGED TO READ MODE\nnikoncameramem::serving file : MEMFILE1\nMEMFILE1\n</cc>\n\n<h>\n*Compostion + Inheritance patterns\n - Composite pattern\n - Decorator pattern\n</h>\n<b>Composition + Inheritance</b>\nThis kind of structural pattern consist of both inheritance and composition. sub class that extends the base class also compose the base class. In this sub class provide same interface methods as base class and in addition it composes other leaf subclasses that extend its attributes.\n\n<c>\n --------                      +---------------+\n |client|--------------------> |<<interface>>  |<---\n --------                      |class          |   |\n                               +---------------+   |\n                                     / \\           |\n                                      -            |\n                                      |            |\n                           <<extends>>|            |<<aggregates>>\n                               +---------------+   |\n                               |sub class      |<>--\n                               +---------------+\n</c>\n\n <b>- Composite pattern</b>\nWhen a complex structure contains other structures where the other structures provide the same interface behaviour as the complex structure, this situation makes composite structural pattern; this is where a structure extends its attribute through similar interface (sub-classed from the same parent) leaf classes.  When complex structure subclasses, it becomes recursive in nature; for example a graphic component (i.e frame) can compose other several graphics (button, checkbox, frame) and out of the composed, some composite graphic can contain similar objects (button, checkbox, frame). The frame is a composite graphic which also contains leaf (button, checkbox) graphic and composite graphic(frame). In an arithmetic expression operators are leaf elements whereas expression itself is composite element. Code example is provided in the below graphic example.\n\n<c>\n ------------                +---------------+\n |client    |--------------->|shape          |<------------+\n ------------                +---------------+             |\n                             |draw():void    |             |\n                             |add(shpe:shape)|             |\n                             |          :void|             |\n                             |remove(shpe:sha|             |\n                             |        pe:void|             |\n                             +---------------+             |\n                                   / \\                     |\n                                    -            <<aggregates>>\n                        <<extends>> |                      |\n        +-------------------------------------+            |\n        |                |                    |            |\n +-----------+     +-----------+     +----------------+    |\n |button     |     |comobobox  |     |frame           |<>---\n +-----------+     +-----------+     +----------------+\n |draw():void|     |draw():void|     |draw():void     |\n +-----------+     +-----------+     |add(shpe:shape):|\n                                     |            void|\n                                     |remove(shpe:shap|\n                                     |          e:void|\n                                     +----------------+\n</c>\nCode\n<c>\n#include <iostream>\n#include <list>\n\nusing namespace std;\n\nclass shape{\npublic:\nstring id;\nshape(const string& idp):id(idp){}\nvirtual void draw()=0;\nvirtual void add(shape*){};\nvirtual void remove(shape*){};\nvirtual ~shape(){};\n};\n\nclass frame:public shape {\nlist<shape*> child;\npublic:\nframe(const string& idp):shape(idp){}\nvoid draw() {\nlist<shape*>::iterator it;\ncout<<id<<"::draw()"<<endl;\nfor(it=child.begin();it!=child.end();it++)\n (*it)->draw();\n}\nvoid add(shape* framep){\nchild.push_front(framep);\n}\nvoid remove(shape* framep){\nchild.remove(framep);\n}\nvirtual ~frame(){\ncout<<"~"<<id<<endl;\nlist<shape*>::iterator it;\nfor(it=child.begin();it!=child.end();it++)\n delete (*it);\n}\n};\n\nclass button:public shape {\nstring text;\npublic:\nbutton(const string& idp,const string& textp):shape(idp),text(textp){}\nvoid draw(){\ncout<<" "<<id<<"::draw() text: "<<text<<endl;\n}\n~button(){cout<<" ~"<<id<<endl;}\n};\n\nclass combobox:public shape{\nlist<string> valuelist;\npublic:\ncombobox(const string& idp, const list<string>& valuelistp):shape(idp),valuelist(valuelistp){}\nvoid draw(){\nlist<string>::iterator it;\ncout<<" "<<id<<"::draw() elements: ";\nfor(it=valuelist.begin();it!=valuelist.end();it++)\ncout<<(*it)<<" ";\ncout<<endl;\n}\n~combobox(){cout<<" ~"<<id<<endl;}\n};\n\nint main(void){\nframe* frametop=new frame("frametop");\nframe* frameleft=new frame("frameleft");\nframe* frameright=new frame("frameright");\nframeleft->add(new combobox("comboboxleft",list<string>{"one","two","three"}));\nframeleft->add(new button("buttonleft","OK"));\nframeright->add(new combobox("comboright",list<string>{"animal","bird","reptile"}));\nframeright->add(new button("buttonright","OK"));\nframetop->add(frameleft);\nframetop->add(frameright);\nframetop->draw();\ndelete frametop;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nframetop::draw()\nframeright::draw()\n buttonright::draw() text: OK\n comboright::draw() elements: animal bird reptile\nframeleft::draw()\n buttonleft::draw() text: OK\n comboboxleft::draw() elements: one two three\n~frametop\n~frameright\n ~buttonright\n ~comboright\n~frameleft\n ~buttonleft\n ~comboboxleft\n</cc>\n\n\n\n Example 2 (arithmetic expression):\n\n<c>\n --------                   +--------------+\n |client|-----------------> |<<interface>> |<---------------------+\n --------                   |expression    |                      |\n                            +--------------+                      |\n                            |compute():void|                      |\n                            +--------------+                      |\n                                  / \\                             |\n                                   -                              |\n                        <<extends>>|                              |\n    -----------------------------------------------------+        |\n    |           |             |               |          |        |\n +---------+   +----------+   +----------+   +---------+ |        |\n |adder    |   |subtracter|   |multiplier|   |divider  | |        |\n +---------+   +----------+   +----------+   +---------+ |        |\n |compute()|   |compute():|   |compute():|   |compute()| |        |\n |    :void|   |      void|   |      void|   |    :void| |        |\n +---------+   +----------+   +----------+   +---------+ |        |\n                                                         |        |\n                                                         |        |\n                                              +--------------+    |\n                                              |subexpression |<>--+\n                                              +--------------+\n                                              |compute():void|\n                                              +--------------+\n\n</c>\n\nCode\n<c>\n#include <iostream>\n#include <list>\n#include <regex>\nusing namespace std;\n\nclass expression {\npublic:\nexpression(){}\nvirtual ~expression(){}\nvirtual string compute(string)=0;\n};\n\nclass subexpression :public expression{\nlist<expression*> expressionlist;\npublic:\nsubexpression(const list<expression*>& expressionlistp):expressionlist(expressionlistp){}\nstring compute(string mep){\ncout<<"subexpression : "<<mep<<endl;\nlist<expression*>::iterator it;\nfor (it=expressionlist.begin();it!=expressionlist.end();it++) mep=(*it)->compute(mep);\nreturn mep;\n}\n~subexpression(){\nlist<expression*>::iterator it;\nfor (it=expressionlist.begin();it!=expressionlist.end();it++) delete (*it);\n}\n};\n\nclass adder:public expression {\npublic:\nvirtual string compute(string mep) {\nsmatch sm;\ncout<<"adder : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\+(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))+stoi(sm.str(3)))+sm.str(4);\nreturn mep;\n}\n};\n\nclass substracter:public expression {\npublic:\nvirtual string compute(string mep) {\nsmatch sm;\ncout<<"substracter : "<<mep<<endl;\nwhile(regex_search(mep,sm,regex(R"((.*?)(\\d+)\\-(\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))-stoi(sm.str(3)))+sm.str(4);\nreturn mep;\n}\n};\n\nclass multiplier:public expression {\npublic:\nvirtual string compute(string mep) {\nsmatch sm;\ncout<<"multiplier : "<<mep<<endl;\nwhile(regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\*(\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))*stoi(sm.str(3)))+sm.str(4);\nreturn mep;\n}\n};\n\nclass divider:public expression {\npublic:\nvirtual string compute(string mep) {\nsmatch sm;\ncout<<"divider : "<<mep<<endl;\nwhile(regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\/(\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))/stoi(sm.str(3)))+sm.str(4);\nreturn mep;\n}\n};\n\nint main(void){\nstring result;\nexpression *exp=new subexpression(list<expression*>{new divider,new subexpression(list<expression*>{new multiplier, new subexpression(list<expression*>{new substracter, new adder})})});\nresult=exp->compute("1+3/3*2-2+6/2/3-2");\ncout<<"result : "<<result<<endl;\nresult=exp->compute("1-2+4*3-6/2+8*3-2*70/10");\ncout<<"result : "<<result<<endl;\ndelete exp;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nsubexpression : 1+3/3*2-2+6/2/3-2\ndivider : 1+3/3*2-2+6/2/3-2\nsubexpression : 1+1*2-2+1-2\nmultiplier : 1+1*2-2+1-2\nsubexpression : 1+2-2+1-2\nsubstracter : 1+2-2+1-2\nadder : 1+0+-1\nresult : 0\nsubexpression : 1-2+4*3-6/2+8*3-2*70/10\ndivider : 1-2+4*3-6/2+8*3-2*70/10\nsubexpression : 1-2+4*3-3+8*3-2*7\nmultiplier : 1-2+4*3-3+8*3-2*7\nsubexpression : 1-2+12-3+24-14\nsubstracter : 1-2+12-3+24-14\nadder : -1+9+10\nresult : 18\n</cc>\n\n<pre style="color:#004000;font-weight:bold;display:inline-block">Article</pre>\n<m>https://www.codeproject.com/Articles/1271791/GUI-Modeling-in-Perl-Tk-Using-Composite-Design-Pat</m>\n<m>http://minhinc.42web.io/image/dp_training_composite.jpeg</m>\n\n <b>- Decorator</b>\nWhen extending attributes are required at run time, a similar pattern to composite can work. It\'s class in which attributes have to be extended and instead of composite, the decorator classes extends the attributes of the class. A decorator is further sub-classed in order to have more attributes in it. For example for a leaf class window, a decorator class can be a frame window drawing around it which is then sub-classed to vertical scrollbar that provides vertical scrollbar for the frame. A house knows how to show itself but when it gets lawns and swimming pool around it as decorators, it gets elegant.\n\n<c>\n                         +-----------+\n                         |  window   |<--------------------------\n                         +-----------+                          |\n                         |draw():void|                          |\n                         +-----------+                          |\n                              / \\                               |\n                               -                                |\n                               |                                |\n        -------------------------------------------             |\n        |                                         |             |\n +------------+                           +-------------+       |\n |simplewindow|                           |  decorator  |<>-----+\n +------------+                           +-------------+\n |draw():void |                           | draw():void |\n +------------+                           +-------------+\n                                                / \\\n                                                 -\n                                                 |\n                            -------------------------------+----------+\n                            |                              |          |\n   +----------------------------+  +-----------------------+          |\n   |horizontalscrollbardecorator|  |verticalscrolldecorator|          |\n   +----------------------------+  +-----------------------+          |\n   |draw():void                 |  |draw():void            |          |\n   +----------------------------+  +-----------------------+          |\n                                                                      |\n                                                                      |\n                                                       +--------------+\n                                                       |framedecorator|\n                                                       +--------------+\n                                                       |draw():void   |\n                                                       +--------------+\n\n</c>\n\nCode\n<c>\n#include <iostream>\nusing namespace std;\n\nclass window {\npublic:\nvirtual void draw()=0;\nvirtual ~window(){};\n};\n\nclass simplewindow:public window {\npublic:\nvoid draw(){\ncout<<"simplewindow";\n}\n~simplewindow(){cout<<"~simplewindow ";}\n};\n\nclass decorator:public window {\nwindow *decoratee;\npublic:\ndecorator(window* decorateep):decoratee(decorateep){}\nvoid draw(){\ndecoratee->draw();\n}\n~decorator(){delete decoratee;}\n};\n\nclass framedecorator:public decorator {\npublic:\nframedecorator(window* decorateep):decorator(decorateep){}\nvoid draw(){\ndecorator::draw();\ncout<<" with frame";\n}\n~framedecorator(){cout<<"~framedecorator ";}\n};\n\nclass horizontalscrollbardecorator:public decorator {\npublic:\nhorizontalscrollbardecorator(window* decorateep):decorator(decorateep){}\nvoid draw(){\ndecorator::draw();\ncout<<" with horizontalscrollbar";\n}\n~horizontalscrollbardecorator(){cout<<"~horizontalscrollbardecorator ";}\n};\n\nclass verticalscrollbardecorator:public decorator {\npublic:\nverticalscrollbardecorator(window* decorateep):decorator(decorateep){}\nvoid draw(){\ndecorator::draw();\ncout<<" with verticalscrollbar";\n}\n~verticalscrollbardecorator(){cout<<"~verticalscrollbardecorator ";}\n};\n\nint main(void){\nwindow *win=new horizontalscrollbardecorator(new verticalscrollbardecorator(new framedecorator(new simplewindow)));\nwin->draw();\ncout<<endl;\ndelete win;\ncout<<endl;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nsimplewindow with frame with verticalscrollbar with horizontalscrollbar\n~horizontalscrollbardecorator ~verticalscrollbardecorator ~framedecorator ~simplewindow\n</cc>'
'6!ABS SBA!GOF Behavioural Design Pattern - 1!ABS SBA!!ABS SBA!<h>\n*Behavioral design patterns\n</h>\n\nBehavioral design pattern include patterns that focus on operations (activity) of a class. Every class/ component is known for the operations it performs and the behavior it attributes but not how it is structured or created. Unlike structural pattern which has base on creational pattern, behavioral pattern has base on structural pattern.\n\n<c>\n +-------------------+\n |Behavioural pattern|\n +------------------------+\n |Structural pattern      |\n +-----------------------------+\n |Creational pattern           |\n +-----------------------------+\n</c>\n\nAs this pattern focuses on operations carried out by the pattern, it mostly deals with how a class method is called or how a set of class methods call each other in order to show a different behavior.\n\nFor example if we register a class method in a class and when a method of the class make callback to the function that\'s called command pattern.\n\nAnother type can be when a class method(function) calls recursively the same function of its own type of class object, the recursive way of calling the function and chain of responsibility is a pattern which matches to this. Behavioral patterns can be distributed in two main categories.\n\na) Recursive method calls.\nb) Non recursive method call.\n\nNon-recursive calls can be further distributed to:\n o Direct method calls.\n o Call back methods calls.\n\n<c>\n                     Behavioral pattern\n                             |\n       ------------------------------------\n       |                                  |\n Recursive calls                Nonrecursive calls\n                                          |\n                         ----------------------\n                         |                    |\n               Direct method calls     Call back calls\n\n\n\n                           |----->Chain Of Responsibility\n                Recursive  |\n              |----------->+\n              | calls      |\n              |            |----->Interpreter\n              |\n              |\n behavioral-->+\n pattern      |                          |---->Command(Subclassed)\n              |                          |\n              |             Direct method|---->Iterator\n              |            |------------>+\n              |            |calls        |---->Mediator\n              |Nonrecursive|             |\n              |----------->+             |---->Memento\n               calls       |             |\n                           |             |---->Strategy\n                           |             |\n                           |             |---->Template method\n                           |\n                           |\n                           |\n                           |          |---->Command\n                           |          |\n                           |Callback  |---->State\n                           |--------->+\n                            calls     |---->Observer\n                                      |\n                                      |---->Visitor\n</c>\n\n<h>\n*Recursive method calls\n - Chain of responsibility pattern\n - Interpreter pattern\n</h>\n\n<b>Recursive patterns</b>\nAs per this pattern type, a method calls itself or calls the same method in other Sub-classes.\n\n<b>- Chain of responsibility</b>\nResponsibility to handle a request is passed to objects in a chain until the request finds an object that can handle it. In addition the Object has to stop the message flow or pass it to the next object in the chain. This kind of pattern is called chain of responsibility. It avoids attaching the sender of a request to a particular receiver and gives a generic way to get the request handled. The sender needs only to worry about the first element of the chain in which the request will pass through.. For example in fault handling section, when a fault occurs, it can either be displayed as a standard message, an error message, produce sound alarm, send a message to higher officials for immediate actions or it can be any combination of the above actions.\n\nRather than taking actions from every separate individual separate entities, there can be separate entity for each of the actions and in the event of fault occurrence it\'s passed in a chain to the first entity to take actions. Every entity in the chain checks the severity of the fault and decides on the handling of the fault.  Another example, an arithmetic expression can be solved through this pattern, below is a code example for this explanation. In another scenario a number can be shuffled.\n\nA Code example follows the arithmetic expression example. In a football match a goalkeeper passes the ball to the next player without actually knowing who will pass the ball in the other side of the goalpost.\n\n<c>\n                            +--------------+\n      --------              |   handler    | <----+\n      |client| -----------> +--------------+      |\n      --------              |handlerequest(| -----+\n                            | request:reque|\n                            | st):void     |\n                            +--------------+\n                                  / \\\n                                   -\n                                   |\n       +-------------------------------------------------------+\n       |                  |                      |             |\n +----------------+ +----------------+ +---------------+ +-------------+\n |stdoutcontroller| |strerrcontroller| |soundcontroller| |smscontroller|\n +----------------+ +----------------+ +---------------+ +-------------+\n | handlerequest(r| | handlerequest(r| | handlerequest(| | handlereques|\n |  equest:int):vo| |  equest:int):vo| |  request:int):| |  t(request:i|\n |  id            | |  id            | |  void         | |  in):void   |\n +----------------+ +----------------+ +---------------+ +-------------+\n\n</c>\n\n<c>\n#include <iostream>\nusing namespace std;\n\nclass handler {\nhandler *next;\npublic:\nhandler(handler *nextp):next(nextp){}\nvirtual void handle(int valuep){if(next)next->handle(valuep);}\nvirtual ~handler(){if(next)delete next;};\n};\n\nclass stdoutcontroller:public handler{\npublic:\nstdoutcontroller(handler *nextp):handler(nextp){}\nvirtual void handle(int valuep) {\ncout<<"stdoutcontroller::handlerequest"<<endl;\nhandler::handle(valuep);\n}\n~stdoutcontroller(){cout<<"~stdoutcontroller"<<endl;}\n};\n\nclass stderrorcontroller:public handler{\npublic:\nstderrorcontroller(handler *nextp):handler(nextp){}\nvirtual void handle(int valuep) {\ncout<<"stderrorcontroller::handlerequest"<<endl;\nhandler::handle(valuep);\n}\n~stderrorcontroller(){cout<<"~stderrorcontroller"<<endl;}\n};\n\nclass soundcontroller:public handler{\npublic:\nsoundcontroller(handler *nextp):handler(nextp){}\nvirtual void handle(int valuep) {\ncout<<"soundcontroller::handlerequest"<<endl;\nhandler::handle(valuep);\n}\n~soundcontroller(){cout<<"~soundcontroller"<<endl;}\n};\n\nclass smscontroller:public handler{\npublic:\nsmscontroller(handler *nextp):handler(nextp){}\nvirtual void handle(int valuep) {\ncout<<"smscontroller::handlerequest"<<endl;\nhandler::handle(valuep);\n}\n~smscontroller(){cout<<"~smscontroller"<<endl;}\n};\n\n\nint main(void){\nhandler* chain=new stdoutcontroller(new stderrorcontroller(new soundcontroller (new smscontroller(NULL))));\nchain->handle(10);\ndelete chain;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nstdoutcontroller::handlerequest\nstderrorcontroller::handlerequest\nsoundcontroller::handlerequest\nsmscontroller::handlerequest\n~stdoutcontroller\n~stderrorcontroller\n~soundcontroller\n~smscontroller\n</cc>\n\n<pre style="color:#004000;font-weight:bold;display:inline-block">Article</pre>\n<m>http://www.codeguru.com/tools/commsoftfreecondit/qt-basics-the-chain-of-responsibility-pattern.html</m>\n<m>http://minhinc.42web.io/image/dp_training_cor.jpeg</m>\n\n Second example(Arithmetic calculation):\n\n<c>\n --------                 +--------------+\n |client| --------------> |   handler    | <---+\n --------                 +--------------+     |\n                          |compute(expres| ----+\n                          | sion):string |\n                          +--------------+\n                                / \\\n                                 -\n                                 |\n        +----------------------------------------------+\n        |               |              |               |\n +-------------+   +-------------+   +-------------+   +-------------+\n |  divider    |   | multiplier  |   | subtracter  |   |    adder    |\n +-------------+   +-------------+   +-------------+   +-------------+\n |compute(expre|   |compute(expre|   |compute(expre|   |compute(expre|\n | ssion:string|   | ssion:string|   | ssion:string|   | ssion:string|\n | :void       |   | ):void      |   | ):void      |   | ):void      |\n +-------------+   +-------------+   +-------------+   +-------------+\n</c>\n\nCode\n<c>\n#include <iostream>\n#include <regex>\n\nusing namespace std;\nclass handler{\nhandler *next;\npublic:\nhandler(handler *nextp):next(nextp){}\nvirtual string handle(string mep){if (next) return next->handle(mep); else return mep;}\n~handler(){if (next) delete next;}\n};\n\nclass adder:public handler {\npublic:\nusing handler::handler;\nstring handle(string mep) {\nsmatch sm;\ncout<<"adder : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\+(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))+stoi(sm.str(3)))+sm.str(4);\nreturn handler::handle(mep);\n}\n};\n\nclass substracter:public handler {\npublic:\nusing handler::handler;\nstring handle(string mep) {\nsmatch sm;\ncout<<"adder : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\-(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))-stoi(sm.str(3)))+sm.str(4);\nreturn handler::handle(mep);\n}\n};\n\nclass multiplier:public handler {\npublic:\nusing handler::handler;\nstring handle(string mep) {\nsmatch sm;\ncout<<"adder : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\*(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))*stoi(sm.str(3)))+sm.str(4);\nreturn handler::handle(mep);\n}\n};\n\nclass divider:public handler {\npublic:\nusing handler::handler;\nstring handle(string mep) {\nsmatch sm;\ncout<<"adder : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\/(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))/stoi(sm.str(3)))+sm.str(4);\nreturn handler::handle(mep);\n}\n};\n\n\nint main(void){\nstring result;\nhandler *hndlr=new divider(new multiplier(new substracter(new adder(NULL))));\nresult=hndlr->handle("1+3/3*2-2+6/2/3-2");\ncout<<"result : "<<result<<endl;\nresult=hndlr->handle("1-2+4*3-6/2+8*3-2*70/10");\ncout<<"result : "<<result<<endl;\ndelete hndlr;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nadder : 1+3/3*2-2+6/2/3-2\nadder : 1+1*2-2+1-2\nadder : 1+2-2+1-2\nadder : 1+0+-1\nresult : 0\nadder : 1-2+4*3-6/2+8*3-2*70/10\nadder : 1-2+4*3-3+8*3-2*7\nadder : 1-2+12-3+24-14\nadder : -1+9+10\nresult : 18\n</cc>\n\n Third example(Reshuffling number):\n\n<c>\n --------                    +------------+\n |client| -----------------> |   handler  | <---+\n --------                    +------------+     |\n                             |handle(numbe|     |\n                             | rref:int*):| ----+\n                             | void       |\n                             +------------+\n                                   / \\\n                                    -\n                                    |\n                  +-------------------------------+\n                  |                               |\n          +--------------+                +--------------+\n          |   printer    |                |  forwarder   |\n          +--------------+                +--------------+\n          |handle(numberr|                |handle(numberr|\n          | ef:int*):void|                | ef:int*):void|\n          +--------------+                +--------------+\n</c>\n\nCode\n<c>\n#include <iostream>\n#include <regex>\n\nusing namespace std;\nclass handler {\npublic:\nhandler *next;\nvirtual void handle(const string)=0;\n~handler(){if(next) delete next;}\n};\n\nclass printer:public handler {\npublic:\nvoid handle(const string exp){\ncout<<exp<<endl;\n};\n};\n\nclass fowarder:public handler {\nint _pos;\npublic:\nfowarder(int posp,int sizep):_pos(posp){\nif(_pos>1)\nnext=new fowarder(_pos-1,sizep);\nelse\nnext=new printer;\n}\nvoid handle(const string exp) {\nint count=0;\nnext->handle(exp);\nfor(count=0;count<_pos;count++) next->handle(regex_replace(exp,regex(string("(.{")+to_string(exp.size()-_pos-1)+string("})(.)(.{")+to_string(count)+string("})(.)(.*)")),"$1$4$3$2$5"));\n}\n};\n\n\nint main(void){\nstring str="1234ab";\nhandler *sh=new fowarder(str.size()-1,str.size());\nsh->handle(str);\ndelete sh;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\n1234ab\n1234ba\n123a4b\n123ab4\n123ba4\n123b4a\n1243ab\n1243ba\n124a3b\n124ab3\n124ba3\n124b3a\n12a43b\n12a4b3\n12a34b\n12a3b4\n12ab34\n12ab43\n12b4a3\n.\n.\n132b4a\n.\n.\n.\nb1432a\nb14a32\nb14a23\nb142a3\nb1423a\nb1a432\nb1a423\nb1a342\nb1a324\nb1a234\nb1a243\nb124a3\nb1243a\nb12a43\nb12a34\nb123a4\nb1234a\n</cc>\n\n<b> -Interpreter</b>\nA grammar interpreter pattern is used in a language where representation of grammar is required along with\nan interpreter in-order to decode sentences in a language. For example in a language there are grammar/rules\nfor rahul AND (abdul OR (ravi OR john) AND sally.\nThe grammar/rule says rahul and sally and any of abdul or ravi or john. In the case of a context this grammar\nwill be used by the interpreter in order to evaluate the context. when we hear a new word, we interpret it\nthrough a dictionary.\n\n<c>\n ---------                     -------------       ---------\n |context| ----------------->  |interpreter| ----> |grammar|\n ---------                     -------------       ---------\n</c>\n\nAn interpreter makes reference to grammar in order to evaluate context.\nEvery religion has a grammar book.\n\n<c>\n\n              ---------                       ------------\n              |client | --------------------> | context  |\n              ---------                       ------------\n                 |\n                 |                           +------------+\n                 +-------------------------> | expression | <----------+\n                                             +------------+            |\n                                             | interpret(c|            |\n                                             |  ontext:str|            |\n                                             |  ing):void |            |\n                                             +------------+            |\n                                                   / \\                 |\n                                                    -                  |\n                                                    |                  |\n            +-------------------------------------------+              |\n            |                    |                      |              |\n            +------------------+ +----------------+ +----------------+ |\n            |terminalexpression| |  ORexpression  | | ANDexpression  | |\n            +------------------+ +----------------+ +----------------+ |\n            | literal:string   | | context:string | | context:string | |\n            +------------------+ +----------------+ +----------------+ |\n            | interpret():void | |interpret():void| |interpret():void| |\n            +------------------+ +--------.-------+ +---------.------+ |\n                                         / \\                 / \\       |\n                                         \\ /                 \\ /       |\n                                          -                   -        |\n                                          |                   |        |\n                                          +-------------------+--------+\n\n</c>\n\nCode\n<c>\n#include <iostream>\n#include <regex>\n\nusing namespace std;\nclass expression{\npublic:\nexpression *exp1,*exp2;\nexpression():exp1(NULL),exp2(NULL){}\nexpression(expression* exp1p,expression* exp2p):exp1(exp1p),exp2(exp2p){}\nvirtual bool interpret(const string&)=0;\nvirtual ~expression(){\nif (exp1 && exp2){\ndelete exp1;\ndelete exp2;\n}\n}\n};\n\nclass terminalexpression:public expression{\nstring literal;\npublic:\nterminalexpression(const string& literalp):literal(literalp){}\nbool interpret(const string& contextp){\nregex b(string(".*\\\\b")+literal+string("\\\\b.*"));\nif (regex_match(contextp,b))\n return true;\nelse\n return false;\n}\n};\n\nclass ORexpression:public expression {\npublic:\nORexpression(expression* exp1p,expression* exp2p):expression(exp1p,exp2p){}\nvirtual bool interpret(const string& contextp){\nreturn exp1->interpret(contextp) || exp2->interpret(contextp);\n}\n};\n\nclass ANDexpression:public expression {\npublic:\nANDexpression(expression* exp1p,expression* exp2p):expression(exp1p,exp2p){}\nbool interpret(const string& contextp){\nreturn exp1->interpret(contextp) && exp2->interpret(contextp);\n}\n};\n\nint main(void){\ncout<<"Grammar expression : \\"RAHUL AND (ABDUL OR ((RAVI OR JOHN) AND UDONG)\\""<<endl;\nexpression *expressioni=new ANDexpression(new terminalexpression("RAHUL"),new ORexpression(new terminalexpression("ABDUL"),new ANDexpression(new ORexpression(new terminalexpression("RAVI"),new terminalexpression("JOHN")),new terminalexpression("UDONG"))));\ncout<<"interpreting \\"JOHN AND UDONG AND RAHUL\\" : "<<expressioni->interpret("JOHN AND UDONG AND RAHUL")<<endl;\ncout<<"interpreting \\"RAHUL AND RAVI\\" : "<<expressioni->interpret("RAHUL AND RAVI")<<endl;\ndelete expressioni;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nGrammar expression : "RAHUL AND (ABDUL OR ((RAVI OR JOHN) AND UDONG)"\ninterpreting "JOHN AND UDONG AND RAHUL" : 1\ninterpreting "RAHUL AND RAVI" : 0\n</cc>\n\nArithmetic expression computation:\n\n<c>\n --------                          ---------\n |client|------------------------> |context|\n --------                          ---------\n    |\n    |                              +--------------+\n    +----------------------------> |  expression  | <-----------+\n                                   +--------------+             |\n                                   | interpret(con|             |\n                                   |  text:string)|             |\n                                   |  :string     |             |\n                                   +--------------+             |\n                                         / \\                    |\n                                          -                     |\n                                          |                     |\n                    +--------------------------------------+    |\n                    |                                      |    |\n                    +-----------------+ +------------------+    |\n                    |terminalexprssion| |  andexpression   |    |\n                    +-----------------+ +------------------+    |\n                    | literral:string | | expression:string| <>-+\n                    +-----------------+ +------------------+\n                    | interpret(contex| | interpret(context|\n                    | t:string):string| |  :string):string |\n                    +-----------------+ +------------------+\n</c>\n\nCode\n<c>\n#include <iostream>\n#include <regex>\n#include <functional>\n\nusing namespace std;\nclass expression {\npublic:\nvirtual string interpret(string)=0;\n};\n\nclass terminalexpression : public expression {\nstd::function<int(int,int)> op;\nchar oprtr;\npublic:\nterminalexpression(const std::function<int(int,int)>& opp,char oprtrp):op(opp),oprtr(oprtrp){}\nstring interpret(string mep){\nsmatch sm;\ncout<<oprtr<<" : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(string("(.*?)(-?\\\\d+)\\\\")+oprtr+string("(-?\\\\d+)(.*)")))) mep=sm.str(1)+to_string(op(stoi(sm.str(2)),stoi(sm.str(3))))+sm.str(4);\nreturn mep;\n}\n};\n\nclass andexpression:public expression {\nexpression *exp1,*exp2;\npublic:\nandexpression(expression* exp1p,expression* exp2p):exp1(exp1p),exp2(exp2p){}\nstring interpret(string mep){\nreturn exp2->interpret(exp1->interpret(mep));\n}\n};\n\nint main(void){\nexpression *exp = new andexpression(new andexpression(new terminalexpression(std::divides<int>(),\'/\'),new terminalexpression(std::multiplies<int>(),\'*\')),new andexpression(new terminalexpression(std::minus<int>(),\'-\'),new terminalexpression(std::plus<int>(),\'+\')));\nstring result;\nresult=exp->interpret("1+3/3*2-2+6/2/3-2");\ncout<<"result : "<<result<<endl;\nresult=exp->interpret("1-2+4*3-6/2+8*3-2*70/10");\ncout<<"result : "<<result<<endl;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\n/ : 1+3/3*2-2+6/2/3-2\n* : 1+1*2-2+1-2\n- : 1+2-2+1-2\n+ : 1+0+-1\nresult : 0\n/ : 1-2+4*3-6/2+8*3-2*70/10\n* : 1-2+4*3-3+8*3-2*7\n- : 1-2+12-3+24-14\n+ : -1+9+10\nresult : 18\n</cc>\n\n<h>\n*Non recursive calls\n - Callback method calls\n  - Command pattern\n  - State pattern\n  - Observer pattern\n  - Visitor pattern\n</h>\n\n<b>Non recursive patterns</b>\nIn this kind of patterns, a method calls the other in linear (direct call) fashion or because they are already registered(call back).\n\n<b>Callback patterns</b>\nThis is when the name of the callee is already registered with the caller and some event triggers the callers to callback the callee.\n\n<b>- Command</b>\n\nCommand pattern is used when different methods need to be called in a generic fashion. In command, methods get class status and executing class generic method actually calls different class methods for which the command object represents. There can be two types of pattern:\n\n1. Separate command class, registers the methods of a subject class and executes its (subject class) methods once execute method of command is clicked,\n\n2. Command class is sub-classed to serve different behaviors and the program needs to mix code with abstract command class. Execute method and the actual execute are called in the context of sub-classed behaviors. Lower level staffs in every department are command executers for commands received from various higher officials.\n\nFirst approach: Class methods register their methods with the command class and when execute method of command class is executed a callback to already registered method is send. For example a robot makes many movements; front, back, left, and right. A function executing these movements need these operations stored in a list so as to execute the list one by one as the movement takes on. The function does not know about the robot and its particular movements. This can happen when robot actions get registered in a new class called command class and when client executes its execute method, through callback robot action.\n\n\n<c>\n                       +-------------+              +----------+\n       --------        |   Invoker   |              | command  |\n       |client| -----> +-------------+              +--------------+\n       --------        |actions:Queue| -----------> |execute():void|\n                       +-------------+              +-----.--------+\n                                                         / \\\n                                                         \\ /\n                                                          |\n                       +-------------+                    |\n                       |    robot    | <------------------+\n                       +-------------+\n                       | front():void|\n                       | back():void |\n                       | right():void|\n                       | left():void |\n                       +-------------+\n</c>\n\n<c>\n#include <iostream>\n#include <list>\n\nusing namespace std;\nclass robot;\nclass command {\nrobot* rbt;\nvoid (robot::*method)();\npublic:\ncommand(robot* rbtp, void (robot::*methodp)()){\nrbt=rbtp;\nmethod=methodp;\n}\nvirtual void execute(){\n(rbt->*method)();\n}\n};\n\nclass robot {\npublic:\nvoid left(){\ncout<<"robot move left"<<endl;\n}\nvoid right(){\ncout<<"robot move right"<<endl;\n}\nvoid front(){\ncout<<"robot move front"<<endl;\n}\nvoid back() {\ncout<<"robot move back"<<endl;\n}\n};\n\nclass invoker{\npublic:\nvoid action(const list<command*>& commandlistp) {\nlist<command*>::const_iterator it;\nfor (it=commandlistp.begin();it!=commandlistp.end();it++)\n(*it)->execute();\n}\n};\n\nint main(void){\ninvoker invokeri;\nrobot roboti;\ninvokeri.action(list<command*>{new command(&roboti,&robot::left),new command(&roboti,&robot::front),new command(&roboti,&robot::right),new command(&roboti,&robot::back)});\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nrobot move left\nrobot move front\nrobot move right\nrobot move back\n</cc>\n\n<b>- State</b>\nA class behavior may change when the state of data type changes, so class function does different operation depending on the state of the data type. Behavior code is bound to change when performing an operation based on state code, where state is separated from the main behavior and when required behavior passes logic to a separate state abstraction. This type of state abstraction is called state pattern. This makes behavior and logic separated, and logic is in state classes making behavior bound to changes and open for logic to be extended in shape of more state sub-classes possible to be added at run time. For example a lift can sustain 5 people. A person can only use the lift when there are less than 5 people in the lift. A Lift operates through opening and closing of lift door, and getting lift move up and down. Lift states include lift at rest, lift serving people up, lift serving people down, and lift full. In electrical switch board there is a plug point and a switch. When a user inputs pin in an electrical equipment in the plug, the board passes the information to the switch. The switch internally maintains various states (i.e. on and off), one state at a time would be effective and the active state receives the information. It is the state which decides the action of the plug and typically \'on\' allows the connection; when \'off\' it\'s in still state and cannot allow any action.\n\n<c>\n  -----    +--------------+                 +--------------------------+\n  | u | -> |    machine   | <>------------> |          state           |\n  | s |    +--------------+                 +--------------------------+\n  | e |    | _state:state*| <-------------  | on(machine*):void        |\n  | r |    +--------------+                 | off(machine*):void       |\n  -----    |on():void     |                 +--------------------------+\n           |off():void    |                            / \\\n           |setstate(state*):void|                      -\n           +---------------------+                      |\n                                                        |\n                                                        |\n                                       +----------------+\n                                       |                |\n                      +------------------+      +------------------+\n                      |      onstate     |      |     offstate     |\n                      +------------------+      +------------------+\n                      |on(machine*):void |      |on(machine*):void |\n                      |off(machine*):void|      |off(machine*):void|\n                      +------------------+      +------------------+\n</c>\n\nCode\n<c>\n#include <iostream>\nusing namespace std;\n\nclass machine;\nclass state{\npublic:\nvirtual void on(machine *m)=0;\nvirtual void off(machine *m)=0;\n};\n\nclass machine{\nstate* _state;\npublic:\n~machine(){delete _state;}\nvoid setstate(state* statep){_state=statep;}\nvoid on();\nvoid off();\n};\n\nclass onstate:public state{\npublic:\nvoid on(machine *m){\ncout<<"Already in ON state"<<endl;\n}\nvoid off(machine*);\n};\n\nclass offstate:public state{\npublic:\nvoid on(machine *m){\ncout<<"OFF -> ON"<<endl;\nm->setstate(new onstate);\ndelete this;\n}\nvoid off(machine *m){\ncout<<"Already in OFF state"<<endl;\n}\n};\n\nvoid onstate::off(machine *m){\ncout<<"ON -> OFF"<<endl;\nm->setstate(new offstate);\ndelete this;\n}\nvoid machine::on(){_state->on(this);}\nvoid machine::off(){_state->off(this);}\n\nint main(void){\nmachine machinei;\nmachinei.setstate(new offstate);\nmachinei.on();\nmachinei.on();\nmachinei.off();\nmachinei.on();\nreturn 0;\n};\n</c>\n\nOutput\n<cc>\nOFF -> ON\nAlready in ON state\nON -> OFF\nOFF -> ON\n</cc>\n\nState pattern way of solving arithmetic equation:\n\n<c>\n               +----------------+        +-------------------+\n               |   calculator   | <>---> |      state        |\n               +----------------+        +-------------------+\n               | _state:state   | <----- | evaluate(express  |\n               +----------------+        |  ionn:string,calcu|\n               | evaluate(expre |        |  lator):void     |\n               | prtonscrn():void|       +-------------------+\n               | setstate(state:|                 / \\\n               |  state):void   |                  -\n               +----------------+                  |\n                                                   |\n                                                   |\n                                                   |\n               +--------------------------------------------------+\n               |                |                |                |\n +-------------+ +-----------------+ +------------------+ +------------+\n |additionstate| |substractionstate| |multiplicatinstate| |divisonstate|\n +-------------+ +-----------------+ +------------------+ +------------+\n | evaluate(exp| | evaluate(express| | evaluate(expressi| |evaluate(exp|\n |  ression,cal| |  ion,calculator)| |  ion,calculator):| | ression,cal|\n | culator):vo | |  :void          | |  void            | |  culator):v|\n | id          | +-----------------+ +------------------+ |  oid       |\n +-------------+                                          +------------+\n</c>\n\nCode\n<c>\n#include <iostream>\n#include <regex>\n\nusing namespace std;\nclass calculator;\nclass state{\npublic:\nvirtual void evaluate(string&,calculator*)=0;\n};\nclass calculator{\nstate *_state;\npublic:\nvoid setstate(state *statep){_state=statep;}\nstring evaluate(string mep){ while(_state!=NULL) _state->evaluate(mep,this); return mep; }\n};\n\nclass addstate:public state{\npublic:\nvoid evaluate(string& mep,calculator *calcp){\nsmatch sm;\ncout<<"addstate : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\+(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))+stoi(sm.str(3)))+sm.str(4);\ncalcp->setstate(NULL);\ndelete this;\n}\n};\n\nclass substractstate:public state{\npublic:\nvoid evaluate(string& mep,calculator *calcp){\nsmatch sm;\ncout<<"substractstate : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\-(\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))-stoi(sm.str(3)))+sm.str(4);\ncalcp->setstate(new addstate);\ndelete this;\n}\n};\n\nclass multiplierstate:public state{\npublic:\nvoid evaluate(string& mep,calculator *calcp){\nsmatch sm;\ncout<<"multiplierstate : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\*(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))*stoi(sm.str(3)))+sm.str(4);\ncalcp->setstate(new substractstate);\ndelete this;\n}\n};\n\nclass dividestate:public state{\npublic:\nvoid evaluate(string& mep,calculator *calcp){\nsmatch sm;\ncout<<"dividetstate : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\/(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))/stoi(sm.str(3)))+sm.str(4);\ncalcp->setstate(new multiplierstate);\ndelete this;\n}\n};\n\nint main(void){\ncalculator calc;\nstring result;\ncalc.setstate(new dividestate);\nresult=calc.evaluate("1+3/3*2-2+6/2/3-2");\ncout<<"result : "<<result<<endl;\ncalc.setstate(new dividestate);\nresult=calc.evaluate("1-2+4*3-6/2+8*3-2*70/10");\ncout<<"result : "<<result<<endl;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\ndividetstate : 1+3/3*2-2+6/2/3-2\nmultiplierstate : 1+1*2-2+1-2\nsubstractstate : 1+2-2+1-2\naddstate : 1+0+-1\nresult : 0\ndividetstate : 1-2+4*3-6/2+8*3-2*70/10\nmultiplierstate : 1-2+4*3-3+8*3-2*7\nsubstractstate : 1-2+12-3+24-14\naddstate : -1+9+10\nresult : 18\n</cc>\n\n<b>- Observer</b>\nWhen a subject is observed by many observers, it leads to data view/controller model and forms an observer pattern. Subject which keeps the data keeps observers registered with it, data changes in the subject triggers the event sent to all the observers who can update their states. One of the observers may again make some tuning in the subject leading to data change in the subject, which makes other observers get informed. For example in an auction, an auctioneer is a subject whereas bidders are observers. Auctioneer starts with an initial value and lets the bidders (observers/view) know. An observer (controller) makes a bid and Subject (model/data) changes the auction rate and announces it again to all the observers(viewers). Typically any general election happens and many observers get placed at different stations from many different countries.\n\n<c>\n         +---------------+      --------     +-------------+\n         |  auctioneer   | <--- |client| --> |   bidder    |\n         +---------------+      --------     +-------------+\n         | state:state   |  ---------------> |update(state:|\n         +---------------+  <-------------<> | state):void |\n         | attach(bidder:|                   +-------------+\n         |  bidder):void |                         / \\\n         | detach(bidder:|                          -\n         |  bidder):void |                          |\n         | notify():void |                          |\n         | update(state:s|                          |\n         |  tate):void   |                          |\n         +---------------+                          |\n                                                    |\n             +----------------------------------------------------+\n             |            |                   |                   |\n             |    +-------------+    +--------------+   +--------------+\n             |    |indianbidder |    |americanbidder|   |japanesebidder|\n             |    +-------------+    +--------------+   +--------------+\n             |    | state:state |    | state:state  |   | state:state  |\n             |    +-------------+    +--------------+   +--------------+\n             |    | update(state|    | update(state:|   | update(state:|\n             |    |  :state):void|   |  state):void |   |  state):void |\n             |    +--------------+   +--------------+   +--------------+\n             |\n             +-------------------------------+\n             |              |                |\n +--------------+ +-----------------+ +-------------+\n |canadianbidder| |austrailianbidder| |chinesebidder|\n +--------------+ +-----------------+ +-------------+\n | state:state  | | state:state     | | state:state |\n +--------------+ +-----------------+ +-------------+\n | update(state:| | update(state:sta| | update(state|\n |  state):void | |  ate):void      | |  :state)void|\n +--------------+ +-----------------+ +-------------+\n\n</c>\n\nCode\n<c>\n#include <iostream>\n#include <list>\n\nusing namespace std;\n\n\nclass bidder;\nclass subject{\npublic:\nint state;\nlist<bidder*> observerlist;\nvoid attach(bidder *observerp){observerlist.push_back(observerp);cout<<"new observer attached"<<endl;}\nvoid detach(bidder *observerp){observerlist.remove(observerp);cout<<"an observer detached"<<endl;}\nvoid notify();\nvoid update(int statep){\nstate=statep;\ncout<<"subject::update current bid value is Rs "<<state<<endl;\nnotify();\n}\n};\n\nclass bidder{ /*observer*/\nsubject* _subject;\npublic:\nbidder(subject *subjectp):_subject(subjectp){_subject->attach(this);}\nvirtual void update(int value)=0;\n};\n\nvoid subject::notify(){\nlist<bidder*>::iterator it;\nfor (it=observerlist.begin();it!=observerlist.end();it++)\n(*it)->update(state);\n}\n\nclass indianbidder:public bidder{\nint bidvalue;\npublic:\nindianbidder(subject *subjectp,int statep):bidder(subjectp),bidvalue(statep){}\nvoid update(int statep){\ncout<<"indiabidder::update current bid value is Rs "<<statep<<" , my bid value is Rs "<<bidvalue<<endl;\n}\n};\n\nclass dollarbidder:public bidder{\nint bidvalue;\npublic:\ndollarbidder(subject *subjectp,int statep):bidder(subjectp),bidvalue(statep){}\nvoid update(int statep){\ncout<<"dollarbidder::update current bid value is Rs "<<statep<<" , my bid value is $ "<<bidvalue<<endl;\n}\n};\n\n\nint main(void){\nsubject subjecti;\nindianbidder ibidderi(&subjecti,100);\ndollarbidder dbidderi(&subjecti,10);\nsubjecti.update(10);\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nnew observer attached\nnew observer attached\nsubject::update current bid value is Rs 10\nindiabidder::update current bid value is Rs 10 , my bid value is Rs 100\ndollarbidder::update current bid value is Rs 10 , my bid value is $ 10\n</cc>\n\n<pre style="color:#004000;font-weight:bold;display:inline-block">Article</pre>\n<m>https://www.codeguru.com/cpp/g-m/drawing-3d-opengl-graphics-on-google-maps.html</m>\n<m>http://minhinc.42web.io/image/dp_training_observer_mvc.jpg</m>\n\n Arithmetic expression solution with observer:\n\n<c>\n  +----------------+           --------\n  |     subject    | <-------- |client| ------   -----------------\n  +----------------+ <-------| --------      |-> |  observer     |\n  | register(obsrvr| ------| |                   -----------------\n  | :observer):void|       | |---------------<>  | update(express|\n  | notify():void  |       |------------------>  |  ion:string):v|\n  | update(state:st|                             |  oid          |\n  |  ate):void     |                             +---------------+\n  +----------------+                                / \\\n                                                     -\n                                                     |\n           +---------------------------------------------------+\n           |              |                |                   |\n +---------------+  +---------------+  +--------------+ +-------------+\n |   division    |  |multiplication |  | subtraction  | |  addition   |\n +---------------+  +---------------+  +--------------+ +-------------+\n | update(express|  | update(express|  | update(expres| | update(expre|\n |  ion:string):v|  |  ion:string):v|  |  sion:string)| |  ssion:strin|\n |  oid          |  |  oid          |  |  void        | |  g):void    |\n +---------------+  +---------------+  +--------------+ +-------------+\n</c>\n\nCode\n<c>\n#include <iostream>\n#include <list>\n#include <regex>\n\nusing namespace std;\nclass subjectee;\nclass observer {\npublic:\nsubjectee *_subjectee;\nobserver(subjectee *subjecteep):_subjectee(subjecteep){}\nvirtual void update(string)=0;\n};\n\nclass subjectee{\nlist<observer*> observerlist;\nstring data;\npublic:\nchar lastobserveroperator;\nvoid attach(observer *observerp){observerlist.push_back(observerp);}\nvoid update(const string& mepp,char lastobserveroperatorp){data=mepp;lastobserveroperator=lastobserveroperatorp;notify();}\nvoid notify(){\nlist<observer*>::iterator it;\nfor(it=observerlist.begin();it!=observerlist.end();it++) (*it)->update(data);\n}\nstring value(){return data;}\n~subjectee(){\nlist<observer*>::iterator it;\nfor(it=observerlist.begin();it!=observerlist.end();it++) delete (*it);\n}\n};\n\nclass addobserver:public observer {\npublic:\nusing observer::observer;\nvoid update(string mep){\nif (_subjectee->lastobserveroperator==\'-\'){\nsmatch sm;\ncout<<"addobserver : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\+(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))+stoi(sm.str(3)))+sm.str(4);\n_subjectee->update(mep,\'+\');\n}\n}\n};\n\nclass substractobserver:public observer {\npublic:\nusing observer::observer;\nvoid update(string mep){\nif (_subjectee->lastobserveroperator==\'*\'){\nsmatch sm;\ncout<<"substractobserver : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\-(\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))-stoi(sm.str(3)))+sm.str(4);\n_subjectee->update(mep,\'-\');\n}\n}\n};\n\nclass multiplierobserver:public observer {\npublic:\nusing observer::observer;\nvoid update(string mep){\nif (_subjectee->lastobserveroperator==\'/\'){\nsmatch sm;\ncout<<"multiplierobserver : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\*(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))*stoi(sm.str(3)))+sm.str(4);\n_subjectee->update(mep,\'*\');\n}\n}\n};\n\nclass divideobserver:public observer {\npublic:\nusing observer::observer;\nvoid update(string mep){\nif (_subjectee->lastobserveroperator==\'\\0\'){\nsmatch sm;\ncout<<"divideobserver : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\/(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))/stoi(sm.str(3)))+sm.str(4);\n_subjectee->update(mep,\'/\');\n}\n}\n};\n\nint main(void){\nsubjectee subjecteei;\nsubjecteei.attach(new divideobserver(&subjecteei));\nsubjecteei.attach(new multiplierobserver(&subjecteei));\nsubjecteei.attach(new substractobserver(&subjecteei));\nsubjecteei.attach(new addobserver(&subjecteei));\nsubjecteei.update("1+3/3*2-2+6/2/3-2",\'\\0\');\ncout<<"result : "<<subjecteei.value()<<endl;\nsubjecteei.update("1-2+4*3-6/2+8*3-2*70/10",\'\\0\');\ncout<<"result : "<<subjecteei.value()<<endl;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\ndivideobserver : 1+3/3*2-2+6/2/3-2\nmultiplierobserver : 1+1*2-2+1-2\nsubstractobserver : 1+2-2+1-2\naddobserver : 1+0+-1\nresult : 0\ndivideobserver : 1-2+4*3-6/2+8*3-2*70/10\nmultiplierobserver : 1-2+4*3-3+8*3-2*7\nsubstractobserver : 1-2+12-3+24-14\naddobserver : -1+9+10\nresult : 18\n</cc>\n\n<b>- Visitor</b>\nA collection of data types generally supports similar kind of operations. If a new operation is to be supported in a collection it would violate design principle if collection class adds new operations and it would be required at each collection classes. Better solution is to let a separate dedicated interface perform the task. Every subclass of an interface adds a new operation; this involves adding operation to a class at run time. This new interface is known as visitor pattern because it visits collection class in order to provide a new operation. \nFor example, a data container abstract class provides data sorting operation but does not provide list size and complexity calculation operation. A visitor class can have sub class statistics which calculates size and complexities of the member data respectively. Collection class can have a method that accepts the visitor classes and the calling method passes the call to visitor for specific operation in visitor implementation to take place. \n<i>Within a course of time many visitors may visit a province and write about its socio, economic, and political status. They collect these information from the province resources only.</i>\n\n<c>\n               +-----------------+\n               |    element      |  -----|\n               +-----------------+       |           +-----------------+\n               |                 |       |-------->  |   visitor       |\n               | accept(visitor:v|                   +-----------------+\n               |  isitor):void   |                   | visit(elmnt:buis|\n               +-----------------+                   |  snessman):void |\n                       / \\                           | visit(elmnt:buis|\n                        -                            |  snesstype):void|---+\n                        |                            | visit(elmnt:city|--+|\n                        |                            |  ):void         |-+||\n                        |                            +-----------------+ |||\n                        |                                       / \\      |||\n       +----------------+-----------------------------+          -       |||\n       |                |                             |          |       |||\n +--------------+       +--------------+       +--------------+  |       |||\n | buisnessman  |<>-|   | buisnesstype |<>-|   |    city      |  |       |||\n +--------------+   |   +--------------+   |   +--------------+  |       |||\n |list<element*>|   |-> |list<element*>|   |-> |              |  |       |||\n |              |       |              |       | accept(vstr:v|  |       |||\n | accept(vstr:v|       | accept(vstr:v|       | isitor):void |  |       |||\n |  isitor)void |       |  isitor):void|       +--------------+  |       |||\n +--------------+       +--------------+             ^           |       |||\n        ^                      ^                     |           |       |||\n        |                      |                     +-----------O-------+||\n        |                      +---------------------------------O--------+|\n        +--------------------------------------------------------O---------+\n                                                                 |\n                                                    +------------------+\n                                                    |statisticsvisitor |\n                                                    +------------------+\n                                                    | visit(elmnt:buisn|\n                                                    |  essman):void    |\n                                                    | visit(elmnt:buisn|\n                                                    |  esstype):void   |\n                                                    | visit(elmnt:city)|\n                                                    |  :void           |\n                                                    +------------------+\n</c>\n\nCode\n<c>\n#include <iostream>\n#include <list>\n\nusing namespace std;\nclass businessman;\nclass businesstype;\nclass businesscity;\nclass visitor{\npublic:\nvirtual void visit(businessman*)=0;\nvirtual void visit(businesstype*)=0;\nvirtual void visit(businesscity*)=0;\n};\n\nclass element{\npublic:\nvirtual const string& name()=0;\nvirtual void accept(visitor*)=0;\n};\n\nclass businessman:public element{\nstring _name;\npublic:\nlist<element*> businesstypelist;\nbusinessman(const string& namep,const list<element*>& businesstypelistp):_name(namep),businesstypelist(businesstypelistp){};\nconst string& name(){return _name;}\nvoid accept(visitor* v){\nv->visit(this);\n}\n};\n\nclass businesstype:public element{\nstring _name;\npublic:\nlist<element*> businesscitylist;\nbusinesstype(const string& namep,const list<element*>& businesscitylistp):_name(namep),businesscitylist(businesscitylistp){};\nconst string& name(){return _name;}\nvoid accept(visitor* v){\nv->visit(this);\n}\n};\n\nclass businesscity:public element{\nstring _name;\npublic:\nbusinesscity(const string& namep):_name(namep){}\nconst string& name(){return _name;}\nvoid accept(visitor* v){\nv->visit(this);\n}\n};\n\n\nclass statisticalvisitor:public visitor{\nvoid visit(businessman *elementp){\nlist<element*>::const_iterator it;\ncout<<"businessman name: "<<elementp->name()<<endl;\nfor(it=elementp->businesstypelist.begin();it!=elementp->businesstypelist.end();it++)\n(*it)->accept(this);\n}\nvoid visit(businesstype *elementp){\nlist<element*>::const_iterator it;\ncout<<" businessman type: "<<elementp->name()<<endl;\nfor(it=elementp->businesscitylist.begin();it!=elementp->businesscitylist.end();it++)\n(*it)->accept(this);\n}\nvoid visit(businesscity *elementp){\ncout<<"  businesscity name: "<<elementp->name()<<endl;\n}\n};\n\n\nint main(void){\nelement *elementi=new businessman("one",list<element*>{new businesstype("hardware",list<element*>{new businesscity("mangalore"),new businesscity("bombay")}),new businesstype("software",list<element*>{new businesscity("chennai"),new businesscity("hamburg")})});\nelementi->accept(new statisticalvisitor);\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nbusinessman name: one\n businessman type: hardware\n  businesscity name: mangalore\n  businesscity name: bombay\n businessman type: software\n  businesscity name: chennai\n  businesscity name: hamburg\n</cc>\n\n\nArithmetic expression solution through this pattern:\n\n<c>\n       +-----------------+         --------\n       |    element      | <------ |client| ----\n       +-----------------+ ------  --------    |  +---------------+\n       | execute(expressi|      |              +> |    visitor    |------+\n       |  on:string):void|      |---------------> +---------------+-----+|\n       | accpet(vstr:visi|                        | visitor(elemt:|----+||\n       |  tor):void      |                        |  element):void|---+|||\n       +-----------------+                        +---------------+   ||||\n               / \\                                             / \\    ||||\n                -                                               -     ||||\n                |                                               |     ||||\n +-----------------------------------------------------------+  |---- ||||\n |                      |                    |               |      | ||||\n +--------+      +--------------+       +--------+       +--------+ | ||||\n |division|<>-|  |multiplication|<>-|   |subtract|<>-|   |addition| | ||||\n +--------+   |  +--------------+   |   +--------+   |   +--------+ | ||||\n | accept(|   |->| accept(vstr:v|   |-> | accept(|   |-> | accept(| | ||||\n |  vstr:v|      | visitor):void|       |  vstr:v|       | vstr:vi| | ||||\n |  isitor|      +--------------+       |  visito|       |  sitor)| | ||||\n |  ):void|             ^               |  ):void|       |  :void | | ||||\n +--------+             |               +--------+       +--------+ | ||||\n     ^                  |                    ^               ^      | ||||\n     |                  |                    |               |      | ||||\n     |                  |                    |               +------O-+|||\n     |                  |                    +----------------------O--+||\n     |                  +-------------------------------------------O---+|\n     +--------------------------------------------------------------O----+\n                                                                    |\n                                                                    |\n                                                +-------------------+\n                                                | statisticsvisitor |\n                                                +-------------------+\n                                                | visitor(elemnt:div|\n                                                |  ision):void      |\n                                                | visitor(elemnt:mul|\n                                                |  tiplication):void|\n                                                | visitor(elmnt:subt|\n                                                |  raction):void    |\n                                                | visitor(elmnt:addi|\n                                                |  tion):void       |\n                                                +-------------------+\n</c>\n\nCode\n<c>\n#include <iostream>\n#include <regex>\n\nusing namespace std;\nclass addoperation;\nclass substractoperation;\nclass multiplieroperation;\nclass divideoperation;\nclass visitor {\npublic:\nvirtual void visit(addoperation*,string&)=0;\nvirtual void visit(substractoperation*,string&)=0;\nvirtual void visit(multiplieroperation*,string&)=0;\nvirtual void visit(divideoperation*,string&)=0;\n};\nclass operation{\npublic:\nvirtual void accept(visitor *visitorp,string&)=0;\nvirtual ~operation(){};\n};\n\nclass addoperation:public operation {\npublic:\nvoid accept(visitor *visitorp,string& mep){\nvisitorp->visit(this,mep);\n}\n};\n\nclass substractoperation:public operation {\npublic:\noperation *nextoperation;\nsubstractoperation(operation *nextoperationp):nextoperation(nextoperationp){}\nvoid accept(visitor *visitorp,string& mep){\nvisitorp->visit(this,mep);\n}\n~substractoperation(){delete nextoperation;}\n};\n\nclass multiplieroperation:public operation {\npublic:\noperation *nextoperation;\nmultiplieroperation(operation *nextoperationp):nextoperation(nextoperationp){}\nvoid accept(visitor *visitorp,string& mep){\nvisitorp->visit(this,mep);\n}\n~multiplieroperation(){delete nextoperation;}\n};\n\nclass divideoperation:public operation {\npublic:\noperation *nextoperation;\ndivideoperation(operation *nextoperationp):nextoperation(nextoperationp){}\nvoid accept(visitor *visitorp,string& mep){\nvisitorp->visit(this,mep);\n}\n~divideoperation(){delete nextoperation;}\n};\n\nclass statisticalvisitor:public visitor{\npublic:\nvoid visit(addoperation* addoperationp,string& mep){\nsmatch sm;\ncout<<"addstate : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\+(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))+stoi(sm.str(3)))+sm.str(4);\n}\nvoid visit(substractoperation* substracteroperationp,string& mep){\nsmatch sm;\ncout<<"substracterstate : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\-(\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))-stoi(sm.str(3)))+sm.str(4);\nsubstracteroperationp->nextoperation->accept(this,mep);\n}\nvoid visit(multiplieroperation* multiplieroperationp,string& mep){\nsmatch sm;\ncout<<"multiplierstate : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\*(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))*stoi(sm.str(3)))+sm.str(4);\nmultiplieroperationp->nextoperation->accept(this,mep);\n}\nvoid visit(divideoperation* divideoperationp,string& mep){\nsmatch sm;\ncout<<"dividetstate : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\/(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))/stoi(sm.str(3)))+sm.str(4);\ndivideoperationp->nextoperation->accept(this,mep);\n}\n};\n\nint main(void){\nstring me("1+3/3*2-2+6/2/3-2");\nstatisticalvisitor statisticalvisitori;\noperation *operationi=new divideoperation(new multiplieroperation(new substractoperation(new addoperation)));\noperationi->accept(&statisticalvisitori,me);\ncout<<"result : "<<me<<endl;\nme="1-2+4*3-6/2+8*3-2*70/10";\noperationi->accept(&statisticalvisitori,me);\ncout<<"result : "<<me<<endl;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\ndividetstate : 1+3/3*2-2+6/2/3-2\nmultiplierstate : 1+1*2-2+1-2\nsubstracterstate : 1+2-2+1-2\naddstate : 1+0+-1\nresult : 0\ndividetstate : 1-2+4*3-6/2+8*3-2*70/10\nmultiplierstate : 1-2+4*3-3+8*3-2*7\nsubstracterstate : 1-2+12-3+24-14\naddstate : -1+9+10\nresult : 18\n</cc>\n\n<b>Priniting various images on various supported printers. Dual dispatching.</b>\n<c>\n +----------------+                  -------------------\n |     image      | <------|         |     printer     |\n -----------------+        |-------> -------------------\n | accept(printer*)|                 | visit(jpeg*):void|\n |   :void        |                  | visit(png*):void|\n +----------------+                  | visit(gif*):void|\n       / \\                           -------------------\n        -                                |||    / \\\n        |                                |||     -\n        |                                |||     |\n   +---------+------------+              |||     |\n   |         |            |              |||     |\n+----------+ +----------+ +----------+   |||     |\n|   jpeg   | |   png    | |    gif   |   |||     |\n------------ -----------+ -----------+   |||     |\n| accept(  | | accept(  | | accept(  |   |||     |\n| pritner*)| | printer*)| | printer*)|   |||     |\n|  :void   | |  :void   | |  :void   |   |||     |\n+----------+ +----------+ +----------+   |||     |\n     ^            ^            ^         |||     |\n     |            |            |         |||     |\n     |            |            +---------+||     |\n     |            +-----------------------+|     |\n     +-------------------------------------+     |\n                                                 |\n                              +---------------+--------------+\n                              |               |              |\n                       +------------+ +-------------+ +------------+\n                       |  inkjet    | |  laser      | |  inktank   |\n                       +------------+ +-------------+ +------------+\n                       | visit(png*)| | visit(jpeg*)| | visit(png*)|\n                       |  :void     | |  :void      | |  :void     |\n                       +------------+ +-------------+ +------------+\n</c>\n\n<c>\n#include <iostream>\n\nusing namespace std;\nclass jpeg; class png; class gif;\nclass printer{\npublic:\nvirtual void visit(jpeg*){}\nvirtual void visit(png*){}\nvirtual void visit(gif*){}\n};\nclass image{\npublic:\nvirtual void accept(printer*)=0;\n};\nclass jpeg:public image{\npublic:\nvoid accept(printer* visitorp){\nvisitorp->visit(this);\n}\n};\nclass png:public image{\npublic:\nvoid accept(printer* visitorp){\nvisitorp->visit(this);\n}\n};\nclass gif:public image{\npublic:\nvoid accept(printer* visitorp){\nvisitorp->visit(this);\n}\n};\nclass inkjet:public printer{\npublic:\nvoid visit(png *pngp){\ncout<<"inkjet printing png"<<endl;\n}\n};\nclass laser:public printer{\npublic:\nvoid visit(jpeg *jpeg){\ncout<<"laser printing jpeg"<<endl;\n}\n};\nclass inktank:public printer{\npublic:\nvoid visit(png *pngp){\ncout<<"pngtank printing png"<<endl;\n}\nvoid visit(gif *gifp){\ncout<<"inktank printing gif"<<endl;\n}\n};\n\nint main(void){\nint i,j;\nimage *imagearr[]={new jpeg,new png,new gif};\nprinter *printerarr[]={new inkjet,new laser,new inktank};\nfor (i=0;i<3;i++)\n for (j=0;j<3;j++)\n  imagearr[i]->accept(printerarr[j]);\nfor (i=0;i<3;i++){\n delete imagearr[i];\n delete printerarr[i];\n}\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nlaser printing jpeg\ninkjet printing png\npngtank printing png\ninktank printing gif\n</cc>\n\n<pre style="color:#004000;font-weight:bold;display:inline-block">Article</pre>\n<m>https://www.codeproject.com/Articles/869923/Class-Level-Generic-Logger</m>\n<m>http://minhinc.42web.io/image/dp_training_visitor.jpg</m>'
'7!ABS SBA!GOF Behavioural Design Pattern - 2!ABS SBA!!ABS SBA!<h>\n*Non recursive calls, cont..\n - Directy Method call\n  - Command (subclassed) pattern\n  - Itertor pattern\n  - Mediator pattern\n  - Memento pattern\n  - Strategy pattern\n  - Template method pattern\n</h>\n\n<b>Direct call patterns</b>\nAs per the name a direct method calls others directly in non-recursive way and in non callback way.\n\n<b>- Command (subclassed)</b>\nIn this approach action taken by subject class is given separate object identity. Each action (command) subclass actually calls subject\'s respective action. Program needs to mix their code with the command abstract class with an execute method called against it and depending on the subclass the object actual action would take place.\n\n<c>\n --------     +--------                 +--------------+\n |client| --->|invoker|  -------------> |   command    |\n --------     --------+                 +--------------+\n                                        |execute():void|\n                                        +--------------+\n                                              / \\\n                                               -\n         +-----------------+                   |\n         |      robot      |                   |\n         +-----------------+                   |\n  +----> | moveleft():void |                   |\n  |+---> | moveright():void|                   |\n  ||+--> | movefront():void|                   |\n  |||+-> | moveback():void |                   |\n  ||||   +-----------------+                   |\n  ||||                                         |\n  ||||                                         |\n  ||||                                         |\n  ||||         +-----------------------------------------------+\n  ||||         |            |               |                  |\n  ||||   +--------+       +---------+    +---------+       +--------+\n  ||||   |moveleft|       |moveright|    |movefront|       |moveback|\n  ||||   +--------+<>. .<>+---------+    +---------+<>. .<>+--------+\n  ||||   | execute|  | |  | execute |    | execute |  | |  | execute|\n  ||||   +--------+  | |  +---------+    +---------+  | |  +--------+\n  |||+---------------+ |                              | |\n  ||+------------------+                              | |\n  |+--------------------------------------------------+ |\n  +-----------------------------------------------------+\n</c>\n\nCode\n<c>\n#include <iostream>\n#include <list>\n\nusing namespace std;\nclass robot {\npublic:\nvoid left(){ cout<<"robot move left"<<endl; }\nvoid right(){ cout<<"robot move right"<<endl; }\nvoid front(){ cout<<"robot move front"<<endl; }\nvoid back() { cout<<"robot move back"<<endl; }\n};\n\nclass command {\npublic:\nrobot* rbt;\ncommand(robot* rbtp):rbt(rbtp){}\nvirtual void execute()=0;\n};\n\nclass moveleft:public command{\npublic:\nusing command::command;\nvoid execute(){rbt->left();}\n};\n\nclass moveright:public command{\npublic:\nusing command::command;\nvoid execute(){rbt->right();}\n};\n\nclass movefront:public command{\npublic:\nusing command::command;\nvoid execute(){rbt->front();}\n};\n\nclass moveback:public command{\npublic:\nusing command::command;\nvoid execute(){rbt->back();}\n};\n\nclass invoker{\npublic:\nvoid action(const list<command*>& commandlistp) {\nlist<command*>::const_iterator it;\nfor (it=commandlistp.begin();it!=commandlistp.end();it++)\n(*it)->execute();\n}\n};\n\nint main(void){\ninvoker invokeri;\nrobot roboti;\ninvokeri.action(list<command*>{new moveleft(&roboti),new movefront(&roboti),new moveright(&roboti),new moveback(&roboti)});\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nrobot move left\nrobot move front\nrobot move right\nrobot move back\n</cc>\n\n<b>- Iterator</b>\nIn a collection class when each element in the collection (i.e. array, list, tree etc) needs to be accessed sequentially and in a collection type independent manner, an iterator pattern is used. The interfaces provided through the pattern is the same for all collection classes, it can be array list tree or any other, and it is independent from the class internalrepresentation. For example a list user should be able to iterate the list in same manner as an array user. In CD player, user does not need to worry about what format songs are stored, he just presses next button in order to go to the next song.\n\n<c>\n     +----------------+            --------       +-----------------+\n     |Aggregate       | <--------- |client| ----> |    Iterator     |\n     +----------------+            --------       +-----------------+\n     |begin():Iterator|                           | operator*()     |\n     |end():Iterator  |                           | operator++()    |\n     |push():void     |                           | operator!=(const|\n     |pop():T         |                           | Iterator&)      |\n     +----------------+                           +-----------------+\n         / \\                                              / \\\n          -                                                -\n          |                                                |\n       -----------------                                   |\n       |               |                                   |\n    +------------+  +-------------+                        |\n    |  queue     |  |stack        |                        |\n    +------------+  +-------------+                        |\n    |friend stack|  |friend stack |                        |\n    | iterator   |  |iterator     |                        |\n    |begin():stack| |begin():stack|                        |\n    | iterator   |  | iterator    |                        |\n    |end():stack |  |end():stacki |                        |\n    |iterator    |  | terator     |                        |\n    |push():void |  |push:void    |                        |\n    |pop():T     |  |pop():T      |                        |\n    +------------+  +-------------+                        |\n         ^              ^             +------------------------+\n         |              |             |                        |\n         |              | +----------------+         +--------------+\n         |              | |stackiterator   |         |queueiterator |\n         |              | +----------------+         +--------------+\n         |              | |operator*()     |         |operator*()   |\n         |              | |operator++()    |<>.. ..<>|operartor++() |\n         |              | |operator!=(const|   | |   |operator!=(con|\n         |              | | Iterator&)     |   | |   | st Iterator&)|\n         |              | +----------------+   | |   +--------------+\n         |              +-------------------- -+ |\n         +---------------------------------------+\n</c>\n\nCode\n<c>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nclass iteratorb{\npublic:\nvirtual int& operator*() const=0;\nvirtual iteratorb& operator++()=0;\nvirtual bool operator!=(const iteratorb&) const=0;\n};\n\nclass stack;\nclass stackiterator:public iteratorb{\nstack *_cnt;\nint index;\npublic:\nstackiterator(stack *stackp,int indexp):_cnt(stackp),index(indexp){}\nint& operator*() const;\niteratorb& operator++();\nbool operator!=(const iteratorb&) const;\n};\n\n\nclass stack {\nint _vec[10];\nint sp;\npublic:\nfriend class stackiterator;\nstack(){sp=0;}\nvoid push(int vp){if(sp<10) _vec[sp++]=vp; }\nint pop(){if(sp) return _vec[--sp];return -1;}\nstackiterator begin(){return stackiterator(this,0);}\nstackiterator end(){return stackiterator(this,sp);}\n};\n\nint& stackiterator::operator*() const{\nreturn _cnt->_vec[index];\n}\n\niteratorb& stackiterator::operator++(){\nif (index<10) ++index;\nreturn *this;\n}\n\nbool stackiterator::operator!=(const iteratorb& iterp) const{\nreturn index!=(static_cast<const stackiterator&>(iterp)).index;\n}\n\nclass queue;\nclass queueiterator:public iteratorb{\nqueue *_cnt;\nint index;\npublic:\nqueueiterator(queue *queuep,int indexp):_cnt(queuep),index(indexp){}\nint& operator*() const;\niteratorb& operator++();\nbool operator!=(const iteratorb&) const;\n};\n\n\nclass queue {\nint _vec[10];\nint bindex,eindex;\npublic:\nfriend class queueiterator;\nqueue(){bindex=eindex=0;}\nvoid push(int vp){ if (eindex<10) _vec[eindex++]=vp; }\nint pop(){if(bindex!=eindex) return _vec[bindex++]; return -1;}\nqueueiterator begin(){return queueiterator(this,bindex);}\nqueueiterator end(){return queueiterator(this,eindex);}\n};\n\nint& queueiterator::operator*() const{\nreturn _cnt->_vec[index];\n}\n\niteratorb& queueiterator::operator++(){\nif (index<_cnt->eindex) ++index;\nreturn *this;\n}\n\nbool queueiterator::operator!=(const iteratorb& iterp) const{\nreturn index!=(static_cast<const queueiterator&>(iterp)).index;\n}\n\nvoid printdata(const iteratorb& itbp,const iteratorb& itep){\nwhile(itbp != itep) {\ncout<<*itbp<<" ";\n++const_cast<iteratorb&>(itbp);\n}\ncout<<endl;\n}\n\nint main(void){\nstack stacki;\nfor (int i=0;i<10;i++) {stacki.push(i);}\ncout<<"----- stack data ------"<<endl;\nprintdata(stacki.begin(),stacki.end());\nqueue queuei;\nfor (int i=0;i<10;i++) {queuei.push(i);}\ncout<<"----- queue data ------"<<endl;\nprintdata(queuei.begin(),queuei.end());\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\n----- stack data ------\n0 1 2 3 4 5 6 7 8 9\n----- queue data ------\n0 1 2 3 4 5 6 7 8 9\n</cc>\n\n\n<b>- Mediator</b>\nWhen a group of entities exist and change in ones state effect, other made entities are tightly coupled the same way. Adding or removing an entity will lead to change in the code of all other entities and when the group is big it\'s difficult to handle the situation. The Idea is to introduce a mediator and all the separate entity in the group would report to the mediator. This makes each entity in the group independent from each other and it\'s the mediator who decides updation among the entities. Telephone exchange(switch) connects N users, where connecting each other without a switch would be practically impossible. Head of a team is actually a mediator.\n\n<c>\n        +-----------+                              +---------------+\n        |dialogbox  |                              |     shape     |\n        +-----------+                              +---------------+\n        |shapechang |  <------------------------<> |click():void   |\n        |ed(shape*):|                              |query():void   |\n        |voidon     |                              |update():void  |\n        | _menu:menu|                              +---------------+\n        | _combobox:|                                   / \\\n        |  combobox |                                    -\n        | _button:bu|                                    |\n        |  tton     |            +----------------------------------+\n        +-----------+            |                                  |\n             / \\         +------------+  +------------+    +-----------+\n             \\ /         |   menu     |  |  combobox  |    |  button   |\n              |          +------------+  +------------+    +-----------+\n              |          | cick():void|  | click():void|   | click():v |\n              |          |query():void|  | query():void|   |  oid      |\n              |          | update():v |  | update():void|  | query():vo|\n              |          |  oid       |  +---------------+ |  id       |\n              |          +------------+         ^          | update(): |\n              |                ^                |          |  void     |\n              |                |                |          +-----------+\n              |                |                |              ^\n              |                |                |              |\n              +----------------+----------------+--------------+\n</c>\n\n<c>\n#include <iostream>\nusing namespace std;\n\nclass widget;\nclass mediator{\npublic:\nenum widgetenum {menue,buttone,comboboxe};\nwidget *_widget[3];\nmediator();\n~mediator();\nvoid widgetchanged(widget*);\nwidget* getwidget(widgetenum wep){\nreturn _widget[wep];\n}\n};\n\nclass widget{\npublic:\nmediator *_med;\nwidget(mediator *mediatorp):_med(mediatorp){}\nvirtual void signal()=0;\nvirtual void query()=0;\nvirtual void update()=0;\n};\nclass menu:public widget{\npublic:\nmenu(mediator *mediatorp):widget(mediatorp){}\nvoid signal(){\ncout<<"menu::signal"<<endl;\n_med->widgetchanged(this);\n}\nvoid query(){ cout<<" menu::query"<<endl; }\nvoid update(){ cout<<" menu::update"<<endl; }\n};\n\nclass button:public widget{\npublic:\nbutton(mediator *mediatorp):widget(mediatorp){}\nvoid signal(){\ncout<<"button::signal"<<endl;\n_med->widgetchanged(this);\n}\nvoid query(){ cout<<" button::query"<<endl; }\nvoid update(){ cout<<" button::update"<<endl; }\n};\n\nclass combobox:public widget{\npublic:\ncombobox(mediator *mediatorp):widget(mediatorp){}\nvoid signal(){\ncout<<"combobox::signal"<<endl;\n_med->widgetchanged(this);\n}\nvoid query(){ cout<<" combobox::query"<<endl; }\nvoid update(){ cout<<" combobox::update"<<endl; }\n};\n\nvoid mediator::widgetchanged(widget* w){\nif(((menu*)w)==_widget[menue]){\n _widget[menue]->query();\n _widget[buttone]->update();\n _widget[comboboxe]->update();\n}else if((menu*)w==_widget[buttone]){\n_widget[buttone]->query();\n_widget[comboboxe]->update();\n}else if((combobox*)w==_widget[comboboxe]){\n_widget[comboboxe]->query();\n_widget[buttone]->update();\n}\n}\n\nmediator::mediator(){\n_widget[menue]=new menu(this);\n_widget[buttone]=new button(this);\n_widget[comboboxe]=new combobox(this);\n}\n\nmediator::~mediator(){\ndelete _widget[menue];\ndelete _widget[buttone];\ndelete _widget[comboboxe];\n}\n\nint main(void){\nmediator mediatori;\nmediatori.getwidget(mediator::menue)->signal();\nmediatori.getwidget(mediator::buttone)->signal();\nmediatori.getwidget(mediator::comboboxe)->signal();\nreturn 0;\n}\n</c>\n\n<cc>\nmenu::signal\n menu::query\n button::update\n combobox::update\nbutton::signal\n button::query\n combobox::update\ncombobox::signal\n combobox::query\n button::update\n</cc>\n\n<pre style="color:#004000;font-weight:bold;display:inline-block">Article</pre>\n<m>https://www.codeguru.com/cpp/g-m/drawing-3d-opengl-graphics-on-google-maps.html</m>\n<m>http://minhinc.42web.io/image/dp_training_mediator.jpg</m>\n\n\n<m>https://www.codeguru.com/IoT/coding-sensors-on-the-rpi3.html</m>\n<m>http://minhinc.42web.io/image/dp_training_mediator2.jpg</m>\n\n Arithmetic expression calculation:\n\n<c>\n                            +--------------+\n                            | mexpression  |\n               +---------<> +--------------+\n               |            | evaluate(exp |\n               |            |  ression:stri|\n               |            |  ng          |\n               v            +--------------+\n                                 / \\\n     +-----------------+          -\n     |    mediator     |          |\n     +-----------------+          |\n     | _mul:multiplier |          |\n     | _div:division   |          |\n     | _add:addition   |          |\n     | _sub:subtraction|          |\n     +-----------------+          |\n     | evaluate(express|          |\n     |  ion):void      |          |\n     +---.-------------+          |\n        / \\                       |\n        \\ /     +----------------------------------------------+\n         |      |             |             |                  |\n         | +-----------+  +----------+ +-----------+ +-----------+\n         | |multiplier |  | divider  | | subtracter| |   adder   |\n         | +-----------+  +----------+ +-----------+ +-----------+\n         | | evaluate(e|  | evaluate(| | evaluate(e| | evaluate(e|\n         | | xpression)|  | expession| | xpression)| |  xpression|\n         | |  :string  |  |  ):string| |  :string  | |  :string  |\n         | +-----------+  +----------+ +-----------+ +-----------+\n         |        ^             ^             ^             ^\n         |        |             |             |             |\n         +--------+-------------+-------------+-------------+\n</c>\n\n<c>\n#include <iostream>\n#include <regex>\n\nusing namespace std;\nclass operation;\nclass mediator{\npublic:\nenum operationenum{add,substract,multiply,divide};\noperation *_operation[4];\nmediator();\n~mediator(){}\noperation* getoperation(operationenum operationenump){return _operation[operationenump];}\nvoid operationchanged(operation *opp);\nstring value();\n};\n\nclass operation{\npublic:\nstring value;\nmediator *_mediator;\noperation(mediator *mediatorp):_mediator(mediatorp){}\nvirtual void signal(string)=0;\nvirtual string query()=0;\n};\n\nclass addoperation:public operation{\npublic:\nusing operation::operation;\nvirtual void signal(string mep){\nsmatch sm;\ncout<<"addstate : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\+(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))+stoi(sm.str(3)))+sm.str(4);\nvalue=mep;\n_mediator->operationchanged(this);\n}\nstring query(){ return value; }\n};\n\nclass substractoperation:public operation{\npublic:\nusing operation::operation;\nvirtual void signal(string mep){\nsmatch sm;\ncout<<"substractstate : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\-(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))-stoi(sm.str(3)))+sm.str(4);\nvalue=mep;\n_mediator->operationchanged(this);\n}\nstring query(){ return value; }\n};\n\nclass multiplieroperation:public operation{\npublic:\nusing operation::operation;\nvirtual void signal(string mep){\nsmatch sm;\ncout<<"multiplierstate : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\*(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))*stoi(sm.str(3)))+sm.str(4);\nvalue=mep;\n_mediator->operationchanged(this);\n}\nstring query(){ return value; }\n};\n\nclass divideoperation:public operation{\npublic:\nusing operation::operation;\nvirtual void signal(string mep){\nsmatch sm;\ncout<<"dividestate : "<<mep<<endl;\nwhile (regex_search(mep,sm,regex(R"((.*?)(-?\\d+)\\/(-?\\d+)(.*))"))) mep=sm.str(1)+to_string(stoi(sm.str(2))/stoi(sm.str(3)))+sm.str(4);\nvalue=mep;\n_mediator->operationchanged(this);\n}\nstring query(){ return value; }\n};\n\nvoid mediator::operationchanged(operation *opp){\nif (((divideoperation*)opp)==_operation[divide])\n _operation[multiply]->signal(opp->query());\nelse if (((multiplieroperation*)opp)==_operation[multiply])\n _operation[substract]->signal(opp->query());\nelse if (((substractoperation*)opp)==_operation[substract])\n _operation[add]->signal(opp->query());\n}\n\nmediator::mediator(){\n_operation[0]=new addoperation(this);\n_operation[1]=new substractoperation(this);\n_operation[2]=new multiplieroperation(this);\n_operation[3]=new divideoperation(this);\n}\n\nstring mediator::value(){\nreturn _operation[add]->query();\n}\n\nint main(void){\nmediator mediatori;\nmediatori.getoperation(mediator::divide)->signal("1-2+4*3-6/2+8*3-2*70/10");\ncout<<"result : "<<mediatori.value()<<endl;\nmediatori.getoperation(mediator::divide)->signal("1+3/3*2-2+6/2/3-2");\ncout<<"result : "<<mediatori.value()<<endl;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\ndividestate : 1-2+4*3-6/2+8*3-2*70/10\nmultiplierstate : 1-2+4*3-3+8*3-2*7\nsubstractstate : 1-2+12-3+24-14\naddstate : -1+9+10\nresult : 18\ndividestate : 1+3/3*2-2+6/2/3-2\nmultiplierstate : 1+1*2-2+1-2\nsubstractstate : 1+2-2+1-2\naddstate : 1+0+-1\nresult : 0\n</cc>\n\n<b>- Memento</b>\nThere are scenarios when a class (originator) changes its state and there has to be an option to bring the class to certain state that the class had been to in the past. It should support a kind of undo operation. A class can itself contain all the states it has happened to be in, in the past or a separate opaque class (memento) can be introduced to keep the state of the original class. A caretaker who handles the originator\'s class behavior keeps various states of the originator in opaque memento and when undo operation is required it sets the originator\'s state to a state stored in a particular memento object. For example a simple adder adds two numbers and gives the result. There can be a need that a user needs to see the previous calculations and in this case, the caretaker would let the originator to create many mementos of the past calculations and when an undo operation is required the previous mementos is set as the new state of the originator. Ministers are mementos for a kings actions and decisions and when required they make the king remember his past actions.\n\n\n<c>\n    +-------------------+                 +----------------------+\n    |    caretaker      |---------------->|     calculator       |\n    +-------------------+                 +----------------------+\n    | save(firstnumber: |                 | backup():memento     |\n    |  int,secondnumber | <>--+    +----  |                      |\n    |  :int):void       |     |    |      | restore(memento):void|\n    | firstnumber():int |     |    |      | getresult():int      |\n    | secondnumber():int|     |    |      | setnumber(int,int):  |\n    +-------------------+     |    |      |                void  |\n                              |    |      +----------------------+\n                              |    |         / \\\n                              |    |          -\n                              |    |          |\n        +----------------+    |    |          |\n        |    memento     | <--+    |          |\n        +----------------+         |     +----------------+\n        | memento(firstn | <-------+     |    intadder    |\n        |  o:int,second  |               +----------------+\n        |  no:int)       |               |getresult():int |\n        +----------------+               |                |\n                                         +----------------+\n\n</c>\n\nCode\n<c>\n#include <iostream>\nusing namespace std;\n\nclass memento{\nfriend class calculator;\nint left,right;\nmemento(int leftp,int rightp):left(leftp),right(rightp){}\n};\n\nclass calculator {\nint left,right;\npublic:\nvoid setnumber(int leftp,int rightp){\nleft=leftp;\nright=rightp;\n}\nint getleft(){return left;}\nint getright(){return right;}\nmemento* backup(){return new memento(left,right);}\nvirtual int getresult()=0;\nvoid restore(memento* mementop){\nleft=mementop->left;\nright=mementop->right;\n}\n};\n\n\nclass adder:public calculator{ //originator\npublic:\nadder(int leftp,int rightp){setnumber(leftp,rightp);}\nint getresult(){return getleft()+getright();}\n};\n\n\nint main(void){ //caretaker\ncalculator *adderi=new adder(4,5);\nmemento *memento1=adderi->backup();\ncout<<"adding 4, 5 : "<<adderi->getresult()<<endl;\nadderi->setnumber(10,15);\nmemento *memento2=adderi->backup();\ncout<<"adding 10, 15 : "<<adderi->getresult()<<endl;\nadderi->restore(memento1);\ncout<<"adding again 4, 5 : "<<adderi->getresult()<<endl;\nadderi->restore(memento2);\ncout<<"adding again 10, 15 : "<<adderi->getresult()<<endl;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nadding 4, 5 : 9\nadding 10, 15 : 25\nadding again 4, 5 : 9\nadding again 10, 15 : 25\n</cc>\n\n<b>- Strategy</b>\nThe behavior of a class may contain both static and changeable behavior. Instead of hard-coding the changeable behavior it keeps abstract data type followed by getting the implementation of abstract at runtime. This kind of abstract data type is addressed through a strategy pattern. Abstract data type is then sub-classed into various implementations which are passed to the main class at run time making the possibility of changing the behavior at run time. i.e. an event manager when it receives an event it passes it through an algorithm which parses the event structure and takes necessary action, i.e. logging it, raises alarm etc. The algorithm can then be placed in a strategy abstract type so that it may vary and the event manager code remain unchanged leading to a new and better algorithm run in the fashion. A person plans (makes strategy) for his kid\'s life that at a particular age the kid has to go to school, then take a job there after and then marry at last; but he does not know the names.\n\n<c>\n  -----    +-----------------+            +---------------+\n  | c | -> |   context       | <>-------> |    sortalgo   | <<strategy>>\n  | l |    +-----------------+            +---------------+\n  | i |    |strat:sortalgo   |            | sort(a[]:int, |\n  | e |    +-----------------+            |  n:int):void  |\n  | n |    | setarray(a[]:int|            +---------------+\n  | t |    |  size:int):void |                   / \\\n  -----    | findinarray(q:in|                    -\n           |   t):bool       |                    |\n           +-----------------+                    |\n                                                  |\n                                          +---------------------+\n                                          |                     |\n                                   +--------------+     +--------------+\n                                   |    qsort     |     |   heapsort   |\n                                   +--------------+     +--------------+\n                                   | sort(a[]:int,|     | sort(a[]:int,|\n                                   |   n:int):void|     |  n:int):void |\n                                   +--------------+     +--------------+\n</c>\n\n<c>\n#include <iostream>\n\nusing namespace std;\nclass sortalgo{\npublic:\nvirtual void sort(int a[],int lowindex ,int highindex)=0;\n};\n\nclass context{\nsortalgo *strategy;\nint *array;\nint arraysize;\nbool sortedb;\npublic:\ncontext():sortedb(false){}\nvoid setstrategy(sortalgo *sortalgop){strategy=sortalgop;}\nvoid setarray(int a[],int sizep){\narray=a;\narraysize=sizep;\nsortedb=false;\n}\nbool search(int search){\nbool result=true;\nint first,last,middle;\nif (!sortedb) {\n strategy->sort(array,0,arraysize-1);\n sortedb=true;\n}\nfirst = 0; last = arraysize - 1; middle = (first+last)/2;\nwhile (first <= last) {\n if (array[middle] < search) first = middle + 1;\n else if (array[middle] == search) break;\n      else\n       last = middle - 1;\n middle = (first + last)/2;\n}\nif (first > last) result=false;\nreturn result;\n}\n};\n\nclass quicksort:public sortalgo{\npublic:\nvoid sort(int array[],int m,int n){\nint i,j,t;\nif(m<n) {\ni=m;j=n+1;\ndo {\n do {\n  i=i+1;\n }while(i<=n && array[i]<array[m]);\n do {\n  j=j-1;\n }while(j>=m && array[j]>array[m]);\nif(i<j){t=array[i];array[i]=array[j];array[j]=t;}\n}while(i<j);\nt=array[j];array[j]=array[m];array[m]=t;\nsort(array,m,j-1);\nsort(array,j+1,n);\n}\n}\n};\n\nclass heapsort:public sortalgo{\npublic:\nvoid sort(int a[],int m,int n){\nint i,t;\nn=n+1;\nheapify(a,n);\nfor (i=n-1;i>0;i--) {\n t = a[0]; a[0] = a[i]; a[i] = t; adjust(a,i);\n}\n}\nvoid heapify(int a[],int n) {\nint k,i,j,item;\nfor (k=1;k<n;k++) {\n item = a[k]; i = k; j = (i-1)/2;\n while((i>0)&&(item>a[j])) {\n  a[i] = a[j]; i = j; j = (i-1)/2;\n }\n a[i] = item;\n}\n}\nvoid adjust(int a[],int n) {\nint i,j=0,item;\nitem = a[j]; i = 2*j+1;\nwhile(i<=n-1) {\n if(i+1 <= n-1)\n  if(a[i] <a[i+1])\n   i++;\n if(item<a[i]) {\n  a[j] = a[i]; j = i; i = 2*j+1;\n } else\n  break;\n}\na[j] = item;\n}\n};\n\nostream& operator<<(ostream& os, int arr[]){\nfor(int i=0;i<=16;i++) os<<arr[i]<<" ";\nreturn os;\n}\n\nint main(void){\ncontext contexti;\n\nint arr[]={1,3,4,2,6,7,9,10,12,3,14,15,21,2,3,4,5};\nsortalgo *qsorti=new quicksort;\ncontexti.setarray(arr,17);\ncontexti.setstrategy(qsorti);\ncout<<"array for search through qsort : "<<arr<<endl;\ncout<<"search 5 in array through qsort : "<<contexti.search(5)<<endl;\ncout<<"search 8 in array through qsort : "<<contexti.search(8)<<endl;\n\nint arr1[]={1,3,4,2,6,7,9,10,12,3,14,15,21,2,3,4,5};\nsortalgo *heapsorti=new heapsort;\ncontexti.setarray(arr1,17);\ncontexti.setstrategy(heapsorti);\ncout<<"array for search through heapsort : "<<arr1<<endl;\ncout<<"search 5 in array through heapsort : "<<contexti.search(5)<<endl;\ncout<<"search 8 in array through heapsort : "<<contexti.search(8)<<endl;\n\ndelete qsorti;\ndelete heapsorti;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\narray for search through qsort : 1 3 4 2 6 7 9 10 12 3 14 15 21 2 3 4 5\nsearch 5 in array through qsort : 1\nsearch 8 in array through qsort : 0\narray for search through heapsort : 1 3 4 2 6 7 9 10 12 3 14 15 21 2 3 4 5\nsearch 5 in array through heapsort : 1\nsearch 8 in array through heapsort : 0\n</cc>\n\n<pre style="color:#004000;font-weight:bold;display:inline-block">Article</pre>\n<m>https://www.codeproject.com/Articles/869923/Class-Level-Generic-Logger</m>\n<m>http://minhinc.42web.io/image/dp_training_strategy.jpg</m>\n\n<b>- Template method</b>\nAs per the definition of template, a template draws an architecture of something and lets the implementor to implement the architecture from his perspective. A template is kind of a starting point. Similarly template method draws a layout of behaviors. A class containing the template method later sub-classes in order to fill the architecture into real examples. For example someone writes an algorithm to sort an array or list. Sorting can happen in at-least two ways either ascending or descending.\n\nRather than mentioning these in the algorithm he just writes the architecture and leaves a hook point where ascending and descending specific codes in a specific subclasses would make it two separate algorithms; ascending sorting and descending sorting. A person can work on one task, two or three, but if he wants to work on 100s of tasks, then either he cannot or he has to find common things among them so that they would differ in very few points.\n\n\n<c>\n        ---------           +---------------+\n        |client | ------->  |     qsort     |\n        ---------           +---------------+\n                            | sort(a:list):v|\n                            |  oid          |\n                            | compare(a:int,|\n                            |  b:int):int   |\n                            +---------------+\n                                    / \\\n                                     -\n                                     |\n                 +-------------------------------+\n                 |                               |\n            +---------------+              +---------------+\n            |qsortascending |              |qsortdecending |\n            +---------------+              +---------------+\n            | compare(a:int,|              | compare(a:int,|\n            |  b:int):int   |              |  b:int):int   |\n            +---------------+              +---------------+\n\n</c>\n\nCode\n<c>\n#include <iostream>\nusing namespace std;\nclass qsort{\npublic:\nint* sort(int array[],int m,int n);\nvirtual bool compare(int,int)=0;\n};\n\nint* qsort::sort(int array[],int m,int n){\nint i,j,t;\nif(m<n) {\ni=m;j=n+1;\ndo {\n do {\n  i=i+1;\n }while(i<=n && compare(array[i],array[m]));\n do {\n  j=j-1;\n }while(j>=m && compare(array[m],array[j]));\nif(i<j){t=array[i];array[i]=array[j];array[j]=t;}\n}while(i<j);\nt=array[j];array[j]=array[m];array[m]=t;\nsort(array,m,j-1);\nsort(array,j+1,n);\n}\nreturn array;\n}\n\nclass qsortascend:public qsort{\npublic:\nbool compare(int a,int b){ return a<b; }\n};\n\nclass qsortdescend:public qsort{\npublic:\nbool compare(int a,int b){return a>b;}\n};\n\n\nostream& operator<<(ostream& os, int arr[]){\nfor(int i=0;i<=16;i++) os<<arr[i]<<" ";\nreturn os;\n}\n\nint main(void){\nint arr[]={1,3,4,2,6,7,9,10,12,3,14,15,21,2,3,4,5};\ncout<<"Array to sort : "<<arr<<endl;\nqsortascend sortascend;\ncout<<"------- Ascending sort : --------"<<endl<<sortascend.sort(arr,0,16)<<endl;\nqsortdescend sortdescend;\ncout<<"------- Descending sort : --------"<<endl<<sortdescend.sort(arr,0,16)<<endl;\nreturn 0;\n}\n</c>\n\nOutput\n<cc>\nArray to sort : 1 3 4 2 6 7 9 10 12 3 14 15 21 2 3 4 5\n------- Ascending sort : --------\n1 2 2 3 3 3 4 4 5 6 7 9 10 12 14 15 21\n------- Descending sort : --------\n21 15 14 12 10 9 7 6 5 4 4 3 3 3 2 2 1\n</cc>'
'31!ABS SBA!title!ABS SBA!None!ABS SBA!Design Patterns in C++'
'32!ABS SBA!subtitle!ABS SBA!None!ABS SBA!4-day session'
'33!ABS SBA!h_Overview!ABS SBA!None!ABS SBA!Understanding VTable concepts in C++ Polymorphism\nUnderstanding Object Layout\nUnderstanding 23 GOF Design patterns\nUnderstanding Creational, Structural and Behavioural design patterns'
'34!ABS SBA!h_Duration!ABS SBA!None!ABS SBA!Four days - 32 hours (8 hours a day)\n50% of lecture, 50% of practical labs.'
'35!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'36!ABS SBA!h_Trainer!ABS SBA!None!ABS SBA!<a href=https://www.linkedin.com/in/pravinkumarsinha>http://www.linkedin.com/in/pravinkumarsinha</a>'
'37!ABS SBA!h_Audience!ABS SBA!None!ABS SBA!Professionals developing medium scale to large scale software'
'38!ABS SBA!h_Prerequisite!ABS SBA!None!ABS SBA!<b>Knowledge of Object Oriented Concepts</b>\nOops concept like Abstraction, Inheritance, Polymorphism would help.'
'39!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'40!ABS SBA!h_Setup!ABS SBA!None!ABS SBA!Machine with g++ installed.'
'41!ABS SBA!h2_Lecture!ABS SBA!None!ABS SBA!Lecture session will be course content presentation through the trainer.\nAny source code example related to the topic will be demonstrated, it would\ninclude executing the binaries.\nComplete lecture material can be downloaded from\n<a href=http://minhinc.42web.io/training/advance-dp-slides.pdf>http://minhinc.42web.io/training/advance-dp-slides.pdf</a>'
'42!ABS SBA!h2_Labs!ABS SBA!None!ABS SBA!Labs session would be completely hands on session where each example\n(with example data and execution instruction) would be provided to the\nstudents. Students can verify their results with the results provided in\nthe material.'
      gl      
"1!ABS SBA!Introduction!ABS SBA!!ABS SBA!<h>\n*OpenGL - Introduction\n</h>\n<a><b>Abstract</b> : OpengGL library is a software interface to graphics hardware. It does not provides any windowing system.</a>\n\n- OpenGL provide 'C' programming interface to control graphics hardware.\n- OpenGL does not provide any windowing system or way to control user input.\n\n<n>Note :\n- OpenGL doesn't provide readymade 3D high level model, like automobile models. It instead provide basic point,line and polygon drawing primitives. GLU library uses glu basic primitives and provides high level mesh, Nurbs surface drawing algorthims.\n- OpenGL is just an alogorithms which takes input from\n a) Vertex primitives\n b) Textures</n>\n\nin order to generate the framebuffer and then finally display buffer.\n<c>\n        ---------------              ------------\n        | texture     |              | vertex   |\n        | (pixel data)|              | primitives|\n        ---------------              -------------\n              |                              |\n              |                              |\n              +------------------------------+\n                              |\n                              .\n                              .\n                              |\n                        ---------------\n                        | Per Fragment|\n                        | Operation   |\n                        ---------------\n                              |\n                        ---------------\n                        | Framebuffer |\n                        | Operation   |\n                        ---------------\n                               |\n                               v\n                          Output data\n</c>\nOpenGL basic architecture is to initialize the various drawing states then draw the primtives\n<c>\n                       |\n                       |\n                       v\n                ---------------\n                |  Set the    |\n                |   States    |\n                |for Primitives|\n                ---------------\n                       |\n                       |\n                       v\n                --------------\n                |  Draw the   |\n                | Primitives  |\n                --------------\n                       |\n                       |\n                       v\n</c>\n\n<h>\n*GPUs\n - Shaders\n - Hardware acceleration\n</h>\n<a><b>Abstract</b>:Graphics process unit (GPU) is a special hardware that does faster mathematical computations for matrixes.</a>\n\nGPU is a processing unit with its own physical memory. Vertex transformations and Fragment computations are done on GPU.\n\nGPU processes code written in shaders language. Shaders are fed to GPU to make the computation. Most used shaders are\n- Vertex shaders\n- Fragment shaders\n\n<h>\n*OpenGL History and evolution\n</h>\n\nOpenGL is a 3D drawing c APIs developed by Silicon Graphics Inc. (SGI) in 1991. Where it inspired by available Iris 3D GL programming. First version 1.0 was released in 1992 without texture support.\n\n1991-2006 - Silicon Graphics\n2006 - Khronos Group\n\nVarious OpenGL major releases\nOpenGL 1.0 (1992)\nOpenGL 1.1 (1997)\n - Vertex arrays\n - Polygon offsets\n - Texture\n  - Texture proxy\n  - Texture objects\nOpenGL 1.2(1998)\n - 3D textures\n - pixel formats\n - vertex array draw element range\nOpengL 1.3 (2001)\n - Multisample\n - Multitexture\n - Transpose matrix\nOpengGL 1.4 (2002)\n - Blend squaring\n - Depth textures and shadows\n - Fog coordinates\n - Multiple draw arrays\n - Stencil wrap\nOpenGL 1.5 (2003)\n - Buffer objects\nOpenGL 2.0 (2004)<c>--+---</c> Shader Programming Language introduced\n - GLSL 1.1<c>          |</c>\n - Shader programs<c>  +----</c> Fixed line functions implemetented through GLSL internally\n - Shader objects\n - Seprate stencil\nOpenGL 2.1 (2006)\n - GLSL 1.2\n - Pixel buffer objects\n - sRGB textures\nOpenGL 3.0 (2008)\n - GLSL 1.3\n - Framebuffer objects\n - Multisample renderbuffer objects\n - conditional rendering\n - array textures\n Deprecated features\n - color index mode\n - Begin/End primitve\n - Fixed function vertex processing\n - Bitmaps\n - Pixel drawing\n - Polygon stripple\n - Display Lists\n - Texture borders\n - Alpha test\n - Accumuation buffers\n - Evaluators\n - Fixed function fragment processing\n - Shading language 1.10 and 1.20\nOpenGL 3.1 (2009)\n - GLSL 1.40 with Instancing\n - Deprecated features removed except wide lines\n - Buffer textures\n - Rectangle textures<c>      /----></c> core (only programming line functions)\nOpenGL 3.2 (2009)<c>-------</c>\n - GLSL 1.5<c>               \\----></c> compatibility (retaining fixed line functions)\n - Core(no deprecated function) and compatibility profiles(with deprecated functions)\nOpenGL 3.3 (2010)\n - GLSL 3.3\n - Dual - source blending\n - Sample Objects\n - Texture swizzle\n - Instanced arrays\n - Vertex attributes 2.10.10.10\nOpenGL 4.0 (2010)\n - GLSL 4.0 with tessalation on GPU, shaders with 64-bit precision\n - Buffer texture\n - Indirect drawing without multidraw\nOpenGL 4.1 (2010)\n - GLSL 4.1 developer-friendly debug output\n - compatibility with OpenGL ES 2.0\n - Query and load binary blob for program objects\nOpenGL 4.2 (2011)\n - GLSL 4.20 Shaders with atomic counters\n - Allowing shaders to read and write images\n - Allowing incrementing/decrementing ad fetching of buffer object memory locations from shaders\nOpenGL 4.3 (2012)\n - GLSL 4.30 Compute shaders leveraging GPU parallelism\n - shader storage buffer objects\nOpenGL 4.4 (2013)\n - GLSL 4.40 Buffer Placement Control\n - Shader Variable Layout\n - Bindless Texture Extension\n - Sparse Texture Extension\nOpenGL 4.5 (2014)\n - GLSL 4.50 Direct State Access (DSA)\n - Flush Control\n - DX11 emulation features\nOpenGL 4.6 (2017)\n - GLSL 4.60 More efficient geometry processing and shader execution\n - polygon offset clamp\n - SPIR-V\n - anisotropic filtering\n\n\nAny functions introduced by venders gets vendor name, i.e NVI introduced constants are GL_NV_half_float, GL_HALF_FLOAT_NV and the function glVertex2hNV(). If these functions become ubiquitous then it is introduced as EXT or ARB (Archtecture review board) extension. Khronos group is new name for ARB group.\n<b>OpenGL stack on Linux</b>\n<m>http://minhinc.42web.io/image/gl-slide-openglstack_s.gif</m>\n\n<h>\n*Graphics terminologies, i.e. Display list,\n Resolution, Modeling, Geometry\n Representation, Evaluators, Primitives,\n Pixel Operations, Rasterization, Fragment\n Operation)\n</h>\n\n<h>\n*Command Syntax\n</h>\n\n<h>\n*State machine\n</h>\n\n<h>\n*Rendering Pipeline\n</h>\n\n<h>\n*OpenGL, OpenGLES, GLX and WebGL\n</h>\n\n<h>\n*GLU and GLEW\n</h>\n\n<h>\n*GLUT, GLFW and OpenGL utility Toolkit\n</h>"
'2!ABS SBA!Drawing Primitives!ABS SBA!*Draw a cylinder using normal glVertex\n*Draw a cylinder using vertex array!ABS SBA!<h>\n*Describing points, lines and polygon\n</h>\n\n<h>\n*State management\n</h>\n\n<h>\n*Normal vector\n</h>\n\n<h>\n*Vertex array\n</h>\n\n<h>\n*Attribute groups\n</h>\n\n<h>\n*Inline functions\n</h>\n\n<h>\n*glu library function\n</h>\n\n<h>\n*Buffer Objects\n</h>\n\n<h>\n*Example, building sphere, cylinder,\n cone\n</h>'
'3!ABS SBA!Viewing!ABS SBA!*Validate if transformations are not associative.\n i.e translation+roation not same to rotation+translaton\n*Add a moon to mars in solar system!ABS SBA!<h>\n*Transformations\n</h>\n\n<h>\n*Viewing and Modeling transformations\n</h>\n\n<h>\n*Projection and Viewport transformations\n</h>\n\n<h>\n*Grand coordinate systems\n</h>\n\n<h>\n*Fix coordinate systems\n</h>\n\n<h>\n*Managing Local coordinate systems\n</h>\n\n<h>\n*Manipulating Matrix Stacks.\n - ModelView matrix\n - Project matrix\n</h>\n\n<h>\n*Example, Building a solar system\n</h>'
'4!ABS SBA!Color & Lighting!ABS SBA!*Draw sphere using glu library. Add and move\nlight source near and far.\n*Let add lighting support in solar system through sun.!ABS SBA!<h>\n*RGBA and Color index mode\n</h>\n\n<h>\n*Color and Shading mode\n</h>\n\n<h>\n*Creating Light source\n</h>\n\n<h>\n*Selecting lighting model\n</h>\n\n<h>\n*Defining material properties\n</h>'
'5!ABS SBA!Blending, Antialiasing, Fog and Polygon Offset!ABS SBA!!ABS SBA!<h>\n*The source and destination factors in blending\n</h>\n\n<h>\n*Three dimensional blending with the Depth Buffer\n</h>\n\n<h>\n*Antialiasing Geometric Primitives with Multisampling\n</h>\n\n<h>\n*Fog equations\n</h>\n\n<h>\n*Polygon Offset\n</h>'
'6!ABS SBA!Display List & Pixel Operation!ABS SBA!*Draw alphabet using DisplayList and Bitmap!ABS SBA!<h>\n*Creating and executing a display list\n</h>\n\n<h>\n*Executing multiple display lists\n</h>\n\n<h>\n*Managing state variable with display lists\n</h>\n\n<h>\n*Bitmaps and Fonts\n</h>\n\n<h>\n*Images\n</h>\n\n<h>\n*Imaging pipeline\n- Pixel Packing and Unpacking, 32 and 64 bit\n- Controlling Pixel-Storage Modes, 32-64 bit\n- Pixel-Transfer Operations\n- Pixel Mapping\n</h>\n\n<h>\n*Using Buffer Objects with Pixel Rectangle Data\n- Using Buffer Objects in Transfer and Retrieve Pixel Data\n</h>'
'7!ABS SBA!Texture Mapping!ABS SBA!*Apply texture on earth in Solar System!ABS SBA!<h>\n*Steps in texture mapping\n</h>\n\n<h>\n*Specifying the texture\n- Texture Proxy, Texture Array\n- Mipmaps:Multiple Level\n</h>\n\n<h>\n*Filtering\n</h>\n\n<h>\n*Texture Object\n</h>\n\n<h>\n*Texture Functions\n- Texture combiner function\n</h>\n\n<h>\n*Multitexturing\n</h>\n\n<h>\n*The texture matrix stack\n</h>\n\n<h>\n*Depth texture\n</h>'
'8!ABS SBA!Framebuffer, Tessallators & Quadrics!ABS SBA!!ABS SBA!<h>\n*Color Buffer\n</h>\n\n<h>\n*Depth Buffer\n</h>\n\n<h>\n*Stencil Buffer\n</h>\n\n<h>\n*Accumulation Buffer\n</h>\n\n<h>\n*Polygon tessallation\n</h>\n\n<h>\n*Quadrics:Rendering Spheres, Cylinders and disks\n</h>'
'9!ABS SBA!Evaluators and NURBS!ABS SBA!!ABS SBA!<h>\n*Evaluators\n</h>\n\n<h>\n*The GLU NURBS Interfaces\n</h>'
'10!ABS SBA!GLSL Shader Programming!ABS SBA!*Create a cube and place a lightsource!ABS SBA!<h>\n*GLSL versions\n</h>\n<h>\n*Syntax (Data types, statements, Functions\n and Sub routines)\n</h>\n<h>\n*Various Shaders (vertex, fragment,\n geometry) and relations to Graphics\n Pipeline\n</h>\n<h>\n*Creating Shader\n</h>\n<h>\n*Inter Shader Communication \n</h>\n<h>\n*Accessing Texture maps in shaders\n</h>'
'31!ABS SBA!title!ABS SBA!None!ABS SBA!OpenGL Essentials Training'
'32!ABS SBA!subtitle!ABS SBA!None!ABS SBA!3-day session'
'33!ABS SBA!h_Overview!ABS SBA!None!ABS SBA!Understanding principles of 3D programming\nUnderstanding drawing Primitives\nUnderstanding transformation matrix and Coloring\nUnderstanding Blending and Texture mapping\nUnderstanding Shaders programming and Display List.\nUnderstanding OpenGL integration with Qt'
'34!ABS SBA!h_Duration!ABS SBA!None!ABS SBA!Three days - 24 hours (8 hours a day)\n50% of lecture, 50% of practical labs.'
'35!ABS SBA!h_Trainer!ABS SBA!None!ABS SBA!<a href="https://www.linkedin.com/in/pravinkumarsinha">http://www.linkedin.com/in/pravinkumarsinha</a>'
'36!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'37!ABS SBA!h_Audience!ABS SBA!None!ABS SBA!Professional 3D Software developers'
'38!ABS SBA!h_Prerequisite!ABS SBA!None!ABS SBA!<b>Knowledge of C programming</b>\nIn particular, participants must be familiar with creating and dealing with\ncomplex data types and structures, with pointers to such symbols, as well as\nwith function pointers.\nAdvance C training agenda is available at\n<a href="http://minhinc.42web.io/training/c/advance-c-agenda.php">http://minhinc.42web.io/training/c/advance-c-agenda.php</a>\n\nand can be downloaded from\n<a href="http://minhinc.42web.io/training/advance-c-agenda.pdf">http://minhinc.42web.io/training/advance-c-agenda.pdf</a>\n\n<b>Knowledge of Object Oriented Concepts</b>\nQt integration requires Oops concept like Abstraction, Inheritance,\nPolymorphism knowledge.'
'39!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'40!ABS SBA!h_Setup!ABS SBA!None!ABS SBA!Linux machine with GNU C++ compiler with Qt OpenGL version installed.'
'41!ABS SBA!h2_Lecture!ABS SBA!None!ABS SBA!Lecture session will be course content presentation through the trainer.\nAny source code example related to the topic will be demonstrated, it would\ninclude executing the binaries. Complete lecture material can be downloaded from\n<a href="http://minhinc.42web.io/training/advance-gl-slides.pdf"/>http://minhinc.42web.io/training/advance-gl-slides.pdf</a>'
'42!ABS SBA!h2_Labs!ABS SBA!None!ABS SBA!Labs session would be completely hands on session where each example\n(with example data and execution instruction) would be provided to the\nstudents. Students can verify their results with the results provided in\nthe material.'
'101!ABS SBA!OpenGL integration with Qt!ABS SBA!!ABS SBA!<h>\n*gl functions through Qt\n-QOpenGLFunctions\n</h>\n<h>\n*Framebuffer operations\n</h>\n<h>\n*Vertex\n-QOpenGLVertexArrayObject\n-QSurfaceFormat\n-QOpenGLContext\n-QOpenGLFramebufferObject\n-QOpenGLFramebufferObjectFormat\n</h>\n<h>\n*Window\n-QOpenGLWidget\n-initialzeGL,resizeGL,paintGL functions\n-painting 2D and 3D together\n</h>\n<h>\n*Shader programming\n-QOpenGLShader\n-QOpenGLShaderProgram\n</h>'
'102!ABS SBA!OpenGL Modeling programs!ABS SBA!!ABS SBA!<h>\n*OpenGL Modeling programs(Overview)\n- Autodesk\n- Maya\n- Google SkethcUp\n</h>\n<h>\n*OpenGL Blender\n- Blender 3D\n</h>'
      headername      
'1!ABS SBA!main!ABS SBA!{\n"pattern":"1",\n"title":"Main",\n"subtitle":"Main",\n"comingtraining":"",\n"child":["product","training","research","service","career","about"],\n"event":[{"title":"Online Qml Training","subtitle":"","link":"http://minhinc.42web.io/training/qml","date":"Sept 2019"},{"title":"Online Training on Design Patterns in C++","subtitle":"","link":"http://minhinc.42web.io/training/dp","date":"Sept 2019"},{"title":"Online Qt Training","subtitle":"","link":"http://minhinc.42web.io/training/qt","date":"Sept 2019"},{"title":"Online Python Training","subtitle":"","link":"http://minhinc.42web.io/training/py","date":"Sept 2019"}]\n}'
'2!ABS SBA!product!ABS SBA!{\n"pattern":"2",\n"title":"Product",\n"subtitle":"Product",\n"child":["fs","ytd","mp","mas","3dv"],\n"link":"http://minhinc.42web.io/product",\n"description":"Company has wide range of products. Primarily 3D Flight simulator, YouTube downloader cum player lightweight media player"\n}'
'3!ABS SBA!training!ABS SBA!{\n"pattern":"2",\n"title":"Training",\n"subtitle":"Training",\n"child":["py","c","qt","cpp","gl","li","ldd","qml","dp"],\n"link":"http://minhinc.42web.io/training",\n"description":"Company primarily provide training in Python, Qt/Qml, OpenGL, Design Patterns and Linux Device Driver. 50% is lecture whereas 50% is lab session with average participant of 15."\n}'
'4!ABS SBA!research!ABS SBA!{\n"pattern":"2",\n"title":"Research",\n"subtitle":"Disclosures",\n"child":["gucdp","casrpi","cdsrpi","hssfrpi","qt2drpi","afupy","qtchordp","qtgl3d","clgl","dpp","sbft"],\n"link":"http://minhinc.42web.io/research",\n"description":"Company has research publications in Python, Data Structures and Algorithms, Perl Design Patterns, C++ Class level Generic Logger, Qt based software installer,Qt/OpenGL based 3D OpenGL animation on online Google Maps, Analog and digital sensor support on Raspberry Pi3, GUI using Composite Design Patterns in Perl/Tk"\n}'
'5!ABS SBA!service!ABS SBA!{\n"pattern":"5",\n"title":"Domain",\n"subtitle":"Our Services",\n"child":["network","multimedia","medicalsystem"],\n"description":"Minh, Inc., based in Bangalore(IN), provides services in application design and development for Networking, Multimedia and Medical Systems based products."\n}'
'6!ABS SBA!career!ABS SBA!{\n"pattern":"7",\n"title":"Career",\n"subtitle":"File Upload Form",\n"child":["cv"],\n"description":"Career"\n}'
'7!ABS SBA!about!ABS SBA!{\n"pattern":"8",\n"child":["online","question","contact"],\n"title":"About Minh",\n"subtitle":"Profile",\n"description":""\n}'
'8!ABS SBA!election!ABS SBA!{\n"pattern":"12",\n"title":"Election Result",\n"subtitle":"Result"\n}'
'51!ABS SBA!email!ABS SBA!{\n "india":{\n  "qt":{\n   "title":"online qt training",\n   "status":"default",\n   "description":"<table width=625 align=\\"center\\">\\n<tr>\\n<td>\\n<p><a href=\\"http://minhinc.42web.io\\" target=\\"_blank\\" style=\\"text-decoration:none\\"><img width=356 height=434 src=\\"cid:image1(http://minhinc.42web.io/image/image.png)\\" align=left></a></p>\\n</td>\\n</tr>\\n</table>"\n  }\n }\n}'
'201!ABS SBA!ytd!ABS SBA!{\n"pattern":"4",\n"parent":"product",\n"title":"You Tube Downloader",\n"date":"Aug 2016",\n"code":"https://github.com/minhinc/MYTD",\n"link":"http://minhinc.42web.io/product/ytd",\n"image":["gfdfronts.jpg","options.jpg","gfdabouts.jpg","gfdpreviews.jpg"],\n"download":{\n"win32":["minhytd.exe",""],\n"win64":["",""],\n"ubuntu32":["",""],\n"ubuntu64":["",""],\n"rpi364":["",""],\n"rpi364":["",""]\n},\n"description":"Provides all possible formats of videos for choice to the user. Supports pause/resume and playes video in the comman dashboard. No pop ups.",\n"tech":["qt","cpp","c"],\n"service":["multimedia","network"]\n}'
'202!ABS SBA!mp!ABS SBA!{\n"pattern":"4",\n"parent":"product",\n"title":"Media Player",\n"date":"Aug 2016",\n"code":"https://github.com/minhinc/MMP",\n"link":"http://minhinc.42web.io/product/mp",\n"image":["gmpfronts.jpg"],\n"download":{\n"win32":["minhgmp.exe","sgmp.zip"],\n"win64":["",""],\n"ubuntu32":["",""],\n"ubuntu64":["",""],\n"rpi364":["",""],\n"rpi364":["",""]\n},\n"description":"It is based upon libavcodec and libsdl. It playes all possible formats supported by libavcodec and sdl2.",\n"tech":["qt","cpp","c"],\n"service":["multimedia"]\n}'
'203!ABS SBA!fs!ABS SBA!{\n"pattern":"4",\n"parent":"product",\n"title":"3D flight simulator",\n"date":"Aug 2016",\n"code":"https://github.com/minhinc/MFS",\n"link":"http://minhinc.42web.io/product/fs",\n"image":["aircrafts.jpg","roadmaps.jpg","climbings.jpg","downs.jpg"],\n"download":{\n"win32":["minhnfs.exe","nazfs.zip"],\n"win64":["",""],\n"ubuntu32":["",""],\n"ubuntu64":["",""],\n"rpi364":["",""],\n"rpi364":["",""]\n},\n"description":"OpenGL 3D algorithms are used to draw 3D aircraft on Qt windowing system. 3D animations are drawn on online moving google maps.",\n"tech":["qt","cpp","gl"],\n"service":["network"]\n}'
'204!ABS SBA!mas!ABS SBA!{\n"pattern":"4",\n"parent":"product",\n"title":"Medical Annotation Software",\n"link":"http://minhinc.42web.io/product/mas",\n"date":"<span style=\\"color:#ff0000\\">Upcoming...<\\/span>",\n"code":"https://github.com/minhinc/MISC/tree/master/annotation",\n"image":["up.png"],\n"description":"It draws drawing primitive annotations (i.e. Line, Ellipse, Triangle, Free Form, Fonts) over medical images.",\n"tech":["qt","cpp"],\n"service":["medicalsystem"]\n}'
'205!ABS SBA!3dv!ABS SBA!{\n"pattern":"4",\n"parent":"product",\n"title":"PythonGL based 3D data Analysis Software",\n"date":"<span style=\\"color:#ff0000\\">Upcoming...<\\/span>",\n"link":"http://minhinc.42web.io/product/3dv",\n"code":"",\n"image":["up.png"],\n"description":"It is a data mining tool can be used to view data in various forms.",\n"tech":["qt","gl","py"],\n"service":["multimedia","network"]\n}'
'301!ABS SBA!qt!ABS SBA!{\n"pattern":"3",\n"parent":"training",\n"title":"Qt Training",\n"link":"http://minhinc.42web.io/training/qt",\n"duration":5,\n"onlineduration":{"day":5,"month":"one and half"},\n"charge":{"in":19500,"us":"400"},\n"description":"Qt training course is of 40hrs. It mainly covers modules core, widgets, gui, network, modelview, graphicsviews, database, 2dpainting and Qml."\n}'
'302!ABS SBA!c!ABS SBA!{\n"pattern":"3",\n"parent":"training",\n"title":"C Training",\n"link":"http://minhinc.42web.io/training/c",\n"duration":3,\n"onlineduration":{"day":4,"month":"one"},\n"charge":{"in":9000,"us":"200"},\n"description":"C training course is of 24 hrs. It covers basic types, functions, control statement, pointer & array, structure and gdb debugging."\n}'
'303!ABS SBA!cpp!ABS SBA!{\n"pattern":"3",\n"parent":"training",\n"title":"C++ Training",\n"link":"http://minhinc.42web.io/training/cpp",\n"duration":5,\n"onlineduration":{"day":5,"month":"one and half"},\n"charge":{"in":19500,"us":"400"},\n"description":"C++ training course is of 40hrs. It mainly covers sequential & associative containers, statement & expression, references, class, interitance, polymorphism, iterator, templates, generic programming, namespaces, C++14."\n}'
'304!ABS SBA!li!ABS SBA!{\n"pattern":"3",\n"parent":"training",\n"title":"Linux Internals Training",\n"link":"http://minhinc.42web.io/training/li",\n"duration":5,\n"onlineduration":{"day":6,"month":"one and half"},\n"charge":{"in":19500,"us":"600"},\n"description":"Linux Internals training is of 40 hrs. It mainly covers Memory management, processes, Multi Threading, IPC and File Systems."\n}'
'305!ABS SBA!ldd!ABS SBA!{\n"pattern":"3",\n"parent":"training",\n"title":"Linux Device Driver Training",\n"link":"http://minhinc.42web.io/training/ldd",\n"duration":5,\n"onlineduration":{"day":6,"month":"one and half"},\n"charge":{"in":29500,"us":"900"},\n"description":"LDD Training is of 40hrs. It main covers linux kernel, building & running modules, character devices, concurrency & race condition, meory management, block drivers, network drivers."\n}'
'306!ABS SBA!qml!ABS SBA!{\n"pattern":"3",\n"parent":"training",\n"title":"Qml Training",\n"link":"http://minhinc.42web.io/training/qml",\n"duration":3,\n"onlineduration":{"day":4,"month":"one"},\n"charge":{"in":19500,"us":"400"},\n"description":"Qml training course is of 24hrs. It mainly covers Qt Properties, QML Building blocks, User Input, Qt Quick classes, Composing UIs, C++ integration and Dynamic creation of items."\n}'
'307!ABS SBA!gl!ABS SBA!{\n"pattern":"3",\n"parent":"training",\n"title":"OpenGL Training",\n"link":"http://minhinc.42web.io/training/gl",\n"duration":3,\n"onlineduration":{"day":4,"month":"one"},\n"charge":{"in":19500,"us":"600"},\n"description":"OpenGL training is of 24 hrs. It mainly covers drawing privitives, viewing, color & lighting, Blending, Antializing, For, Polygon Offset, Display List & Pixel Operation, Texture mapping, framebuffer, Tessallotors & Quadrics, Evaluators."\n}'
'308!ABS SBA!py!ABS SBA!{\n"pattern":"3",\n"parent":"training",\n"title":"Python Training",\n"link":"http://minhinc.42web.io/training/py",\n"charge":{"in":19500,"us":"600"},\n"duration":5,\n"onlineduration":{"day":6,"month":"one and half"},\n"description":"Python training course is of 40hrs. It covers variables, modules, class & Objects, Inheritance & Polymorphism and Exceptions."\n}'
'309!ABS SBA!dp!ABS SBA!{\n"pattern":"3",\n"parent":"training",\n"title":"Design Patterns Training",\n"link":"http://minhinc.42web.io/training/dp",\n"duration":4,\n"onlineduration":{"day":5,"month":"one and quater"},\n"charge":{"in":19500,"us":"400"},\n"description":"Design Patterns training course is of 32hrs. It mainly covers C++ Object Model and Vtable structure. GOF Creational, Structural and Behavioural Design Patterns."\n}'
'401!ABS SBA!casrpi!ABS SBA!{\n"title":"Coding Analog Sensors on the Raspberry Pi 3",\n"link":"http://www.codeguru.com/IoT/coding-analog-sensors-on-the-raspberry-pi3.html",\n"date":"Sep 2017",\n"description":"This is about to make raspberry pi 3 interfacing with Analog sensors through ADC mcp3008 chip using SPI protocol way of communication. Sensors covered are <br>a)JoyStick <br>b)Potentiometer(10k)",\n"tech":["qt","cpp","li"],\n"publisher":"CodeGuru.com",\n"service":["embedded"]\n}'
'402!ABS SBA!cdsrpi!ABS SBA!{\n"title":"Coding Sensors on Raspberry Pi 3",\n"link":"http://www.codeguru.com/IoT/coding-sensors-on-the-rpi3.html",\n"date":"Sep 2017",\n"description":"Digital/Analog sensors communicating with rPI3. Analog signal is captured through ADC pcf8591, communicates using I2C. Sensors covered are <br>a)LED (digital) <br>b)DHT11, humidity and temperature sensor (digital)<br>c)Motion PIR sensor (digital)<br>d)Light sensor, digital and analog<br>e)Moisture sensor, digital and analog",\n"tech":["qt","cpp","li"],\n"publisher":"CodeGuru.com",\n"service":["embedded"]\n}'
'403!ABS SBA!hssfrpi!ABS SBA!{\n"title":"Raspberry Pi 3 Hardware and System Software Reference",\n"link":"http://www.codeguru.com/IoT/raspberry-pi-3-hardware-and-system-software-reference.html",\n"date":"Sep 2017",\n"description":"Discuss about rPI3 interfacing protocol with external hardware including I2C and SPI.",\n"tech":["li"],\n"publisher":"CodeGuru.com",\n"service":["embedded"]\n}'
'404!ABS SBA!qt2drpi!ABS SBA!{\n"title":"Using qt 2d display on a Raspberry pi3",\n"link":"http://www.codeguru.com/IoT/using-the-qt-2d-display-on-a-raspberry-pi3.html",\n"date":"Sep 2017",\n"description":"Discuss about 2D 2 axis graph display library developed in Qt. Its too simple to develop and too simple to integrate.",\n"tech":["qt","cpp"],\n"service":["embedded"],\n"publisher":"CodeGuru.com"\n}'
'405!ABS SBA!afupy!ABS SBA!{\n"title":"Accessing Files Using Python",\n"link":"http://www.developer.com/open/accessing-files-using-python.html",\n"date":"Jan 2017",\n"code":"https://github.com/minhinc/RESEARCH",\n"description":"Discusses various ways to access files in a file system, seprates buffered and unbuffered python file access classes",\n"tech":["py"],\n"service":["script"],\n"publisher":"Developer.com"\n}'
'406!ABS SBA!qtchordp!ABS SBA!{\n"title":"Qt Basic: The Chain Of Responsibility Pattern",\n"link":"http://www.codeguru.com/tools/commsoftfreecondit/qt-basics-the-chain-of-responsibility-pattern.html",\n"date":"May 2016",\n"code":"https://github.com/minhinc/RESEARCH",\n"description":"This article describes writing software installer through chain of responsiblity design patterns.",\n"tech":["qt","cpp"],\n"publisher":"CodeGuru.com"\n}'
'407!ABS SBA!qtgl3d!ABS SBA!{\n"title":"Qt OpenGL 3D Drawing on Google Maps",\n"link":"http://www.codeguru.com/cpp/g-m/drawing-3d-opengl-graphics-on-google-maps.html",\n"date":"May 2016",\n"code":"https://github.com/minhinc/RESEARCH",\n"description":"OpenGL 3D algorithms are used to draw 3D aircraft on Qt windowing system.Animations drawn on onlineGoogle Maps.",\n"tech":["qt","gl","cpp"],\n"service":["network","3d"],\n"publisher":"CodeGuru.com"\n}'
'408!ABS SBA!clgl!ABS SBA!{\n"title":"C++ Class level generic logger",\n"link":"http://www.codeproject.com/Articles/869923/Class-Level-Generic-Logger",\n"date":"Jan 2015",\n"code":"https://github.com/minhinc/RESEARCH",\n"description":"Class level generic logger is a logger which can log to any log level to any device and can put messages at class level granularity.",\n"tech":["cpp"],\n"publisher":"CodeProject.com"\n}'
'409!ABS SBA!dpp!ABS SBA!{\n"title":"Design Patterns in Perl",\n"link":"http://minhinc.42web.io/research/SDJ_Open_2014.pdf",\n"date":"Nov 2014",\n"code":"https://github.com/minhinc/RESEARCH",\n"description":"This article discusses GOF 23 design patterns with new set of examples. It provides fundamentals those are equally useful toprogramers in other languages.",\n"tech":["py","dp"],\n"service":["script"],\n"publisher":"sdjournal.org"\n}'
'410!ABS SBA!sbft!ABS SBA!{\n"title":"Stack Based BFS Tree Traversal",\n"link":"https://developer.ibm.com/technologies/systems/articles/au-aix-stack-tree-traversal/",\n"date":"June 2013",\n"code":"https://github.com/minhinc/RESEARCH",\n"description":"Describes breadth first search on tree using stack. It provides better space and time performance.",\n"tech":["c"],\n"service":["algorithm"],\n"publisher":"ibm.com"\n}'
'411!ABS SBA!gucdp!ABS SBA!{\n"title":"GUI Modeling in Perl/Tk Using Composite Design Pattern",\n"link":"https://www.codeproject.com/Articles/1271791/GUI-Modeling-in-Perl-Tk-Using-Composite-Design-Pat",\n"date":"Dec 2018",\n"description":"It provides an idea to generate graphical User Interface using Composite design pattern with set of some predefined rules (i.e config file) and libraries",\n"tech":["dp"],\n"publisher":"CodeProject.com"\n}'
'501!ABS SBA!network!ABS SBA!{\n"pattern":"6",\n"title":"Networking",\n"description":"We develop network application based upon tcp/ip (socket, http, ftp) protocols through Qt/C++ and Python programming language interfaces."\n}'
'502!ABS SBA!multimedia!ABS SBA!{\n"pattern":"6",\n"title":"Multimedia",\n"description":"We develop multimedia applications based upon sdl & ffmpeg multimedia library interfaces through Qt/C++ and Python programming language."\n}'
'503!ABS SBA!medicalsystem!ABS SBA!{\n"pattern":"6",\n"title":"Medical Systems",\n"description":"We develop Medical Systems applications that uses Qt and Python programming interfaces."\n}'
'601!ABS SBA!cv!ABS SBA!{\n"pattern":"7",\n"title":"Carriculum Vitae",\n"subtitle":"File Upload Form",\n"description":"Minh, Inc. is looking for C++ and Python developers in Networking, Multimedia and Graphics domain."\n}'
'701!ABS SBA!question!ABS SBA!{\n"pattern":"9",\n"title":"Ask a Programming Question",\n"description":""\n}'
'702!ABS SBA!contact!ABS SBA!{\n"pattern":"10",\n"title":"CONTACT US",\n"description":""\n}'
'703!ABS SBA!online!ABS SBA!{\n"pattern":"11",\n"title":"Online Training",\n"description":"",\n"link":"http://minhinc.42web.io/online"\n}'
      junkemail      
'.*?@arago.co'
'.*?@claysol.com'
'.*?@example.com'
'.*?@froglogic.com'
'.*?@monsterindia.com'
'.*?@optmsol.com'
'.*?indeed.com'
'.*[.]gif'
'.*[.]jpeg'
'.*[.]jpg'
'.*[.]png'
'.*[.]svg'
'.*\\@\\d+[.](?:\\d+[.]?)*'
'abc@xyz.com'
'admin@olatopper.com'
'careers?@.*'
'contactus@shine.com'
'contactusdialbe@gmail.com'
'content@glassdoor.com'
'copyright.*@.*'
'copyright2016-17@indiacom.com'
'email@domain[.]com'
'exemple@exemple.fr'
'exemple@mail.com'
'feedback@jobserve[.]com'
'feedback@justdial.com'
'hello@edugorilla.com'
'imesjobs@timesgroup.com'
'job[sS]?@.*'
'johndoe@email.com'
'mail@gdial.in'
'name@company.com'
'name@domain[.]com'
'name@example.com'
'name@mail[.]com'
'name@yoursite[.]com'
'newdicesupport@dice[.]com'
'person@company.com'
'press@.*'
'rahul.negi@fxconsulting[.]in'
'ram@gmail.com'
'rusers@justdial.com'
'sample@test[.]com'
'solutions@mapsofindia.com'
'spam@.*'
'support@magicbricks.com'
'support@myprivatetutor.com'
'support@urbanpro.com'
'tofler@tofler[.]in'
'user@domain[.]com'
'user@email.com'
'webadmin@deldure.com'
'webmaster@techworld.com'
'webmaster@yet5.com'
'xyz@mail.com'
'you@company[.]com'
'you@email[.]com'
'you@xyz[.]com'
'your-email@mail.com'
'your.email@domain.com'
'your.email@domain.name'
'your.name@email.com'
'your@email[.]com'
'your@emailaddress.co.uk'
'youremail@email[.]com'
'yourname@domain[.]com'
'yourname@email[.]com'
'yours@example.com'
      junkextension      
'.*(de|www)[.]indeed[.](com|de).*'
'.*[.]7z.*'
'.*[.]aspx$'
'.*[.]cms$'
'.*[.]cp*?$'
'.*[.]doc.*'
'.*[.]ece.*'
'.*[.]php$'
'.*[.]ppt.*'
'.*[.]rar.*'
'.*[.]txt.*'
'.*[.]xls.*'
'.*[.]xml.*'
'.*[.]zip.*'
'.*bloomberg.*'
'.*facebook.*'
'.*glassdoor[.]co.*'
'.*googleuser.*'
'.*hdfcbank.*'
'.*huntable[.]co.*'
'.*naukri.*'
'.*twitter.*'
'.*webcache.*'
'.*wikimedia.*'
'.*wikipedia.*'
'.*wiktionary.*'
'.*www.glassdoor.*/.*'
'.*www[.]amazon[.]com/.*'
'.*www[.]dnb[.]com/.*'
'.*www[.]easemytrip[.]com.*'
'.*www[.]expedia[.]com.*'
'.*www[.]fundoodata[.]com.*'
'.*www[.]iitjobs[.]com.*'
'.*www[.]indiamart[.]com/.*'
'.*www[.]jobisjob[.]com.*'
'.*www[.]jobserve.com.*'
'.*www[.]jobstairs[.](com|de).*'
'.*www[.]justdial[.]com.*'
'.*www[.]makemytrip[.]com.*'
'.*www[.]mapsofindia[.]com/.*'
'.*www[.]moneycontrol[.]com/.*'
'.*www[.]monster[.](de|com).*'
'.*www[.]payscale[.]com/.*'
'.*www[.]quikr[.]com/.*'
'.*www[.]quora[.]com/.*'
'.*www[.]reed[.]co[.].*'
'.*www[.]stepstone[.].*'
'.*www[.]sulekha[.]com.*'
'.*www[.]timesjobs[.]com.*'
'.*www[.]tradeindia[.]com.*'
'.*www[.]yellowpages[.]com.*'
'.*yesbank[.]in.*'
'.*youtube.*'
'\\bgz\\b'
'\\bpdf\\b'
      ldd      
'1!ABS SBA!Introduction to Linux Kernel!ABS SBA!*Bootloader Architecture\n- Bootloader compilation and downloading on Target board.\n- U-Boot Commands\n- Bootloader commands and usage,\n- Bootloader code customization, adding new Ethernet drivers to U-Boot!ABS SBA!<h>\n*Kernel Mode vs. User Mode\n</h>\n<h>\n*Kernel features\n</h>\n<h>\n*Kernel user interface (/proc and /sys)\n</h>\n<h>\n*User space drivers\n</h>\n<h>\n*Kernel versions and\n</h>\n<h>\n*CONFIG_MODVERSIONS\n</h>\n<h>\n*Kernel data types \n</h>\n<h>\n*Bootloader Architecture\n- Bootloader compilation and downloading on Target board.\n- U-Boot Commands\n- Bootloader commands and usage,\n- Bootloader code customization, adding new Ethernet drivers to U-Boot\n</h>'
'2!ABS SBA!Building and Running Modules!ABS SBA!*Linux Kernel Architecture\n- Linux Source code browsing\n- Configuring and compiling Linux Kernel\n- Build Root file system with busybox!ABS SBA!<h>\n*Include files\n</h>\n<h>\n*Retrieving kernel sources\n</h>\n<h>\n*Build and Install (or recompile) a\nkernel)\n</h>\n<h>\n*Getting and Installing the kernel\nsources.\n</h>\n<h>\n*Configuring and compiling the\nReplacement kernel.\n</h>\n<h>\n*Safely Booting the freshly compiled\n</h>\n<h>\n*Kernel with Grub\n*Linux Kernel Architecture\n- Linux Source code browsing\n- Configuring and compiling Linux Kernel\n- Build Root file system with busybox\n</h>'
'3!ABS SBA!Linux Kernel modules!ABS SBA!*Module\n- Write a simple module to toggle GPIO with timer\n- Link it statically and dynamically!ABS SBA!<h>\n*Various kernel modules\n</h>\n<h>\n*The format of device driver module\n</h>\n<h>\n*Loading and unloading device driver\nmodule\n</h>\n<h>\n*The Hello world module\n</h>\n<h>\n*Compilation and Loading\n</h>\n<h>\n*The kernel symbol table\n</h>\n<h>\n*Module parameters\n</h>\n<h>\n*Module dependencies\n</h>\n<h>\n*Module\n- Write a simple module to toggle GPIO with timer\n- Link it statically and dynamically\n</h>'
'4!ABS SBA!Character Drivers!ABS SBA!*Character special device\n- Register a character device type\n- Write a driver to toggle GPIO with\n  every write operation\n- Read the status of GPIO with read\n  operation !ABS SBA!<h>\n*Character driver module API\n</h>\n<h>\n*Hardware Resources needed by the\nDriver.\n</h>\n<h>\n*Major and Minor numbers.\n</h>\n<h>\n*Char device registration.\n</h>\n<h>\n*Scull introduction.\n</h>\n<h>\n*Executing character device driver\n</h>\n<h>\n*Character special device\n- Register a character device type\n- Write a driver to toggle GPIO with\n  every write operation\n- Read the status of GPIO with read\n  operation\n</h>'
'5!ABS SBA!Concurrency and Race condition!ABS SBA!!ABS SBA!<h>\n*Concurrency and its management\n</h>\n<h>\n*Semaphores and Mutexes.\n</h>\n<h>\n*Completions\n</h>\n<h>\n*Spinlocks\n</h>\n<h>\n*Locking traps\n</h>\n<h>\n*Atomic operations\n</h>\n<h>\n*Typical locking issues\n</h>\n<h>\n*Using the lock validator to identify the\nresource of locking problem.\n</h>'
'6!ABS SBA!Advanced char driver operation!ABS SBA!*Interrupt\n- Setup ISR for interrupt and trigger it\n  through GPIO!ABS SBA!<h>\n*Probing for and allocating the I/O\nAddress.\n</h>\n<h>\n*Interrupts.\n</h>\n<h>\n*ioctl\n</h>\n<h>\n*Blocking I/O, poll and select\n</h>\n<h>\n*Access control on a Device File\n</h>\n<h>\n*PCI device drivers\n</h>\n<h>\n*The PCI bus\n</h>\n<h>\n*Read/Write Functionality.\n</h>\n<h>\n*Asynchronous operator\n*Interrupt\n- Setup ISR for interrupt and trigger it\n  through GPIO \n</h>'
'7!ABS SBA!Memory Management!ABS SBA!!ABS SBA!<h>\n*Supporting mmap()\n</h>\n<h>\n*Zero copy user space access for I/O\n</h>\n<h>\n*Atomic kmaps\n</h>\n<h>\n*Performing Direct I/O, DMA\n</h>\n<h>\n*Quick access to high - memory via kmap\natomic\n</h>\n<h>\n*Allocating by pages, vmalloc\n</h>'
'8!ABS SBA!Block Drivers!ABS SBA!*Write a simple block driver!ABS SBA!<h>\n*RAM disk drivers\n</h>\n<h>\n*Registration, Entry points\n</h>\n<h>\n*The Block Device operation.\n</h>\n<h>\n*The request_for\n</h>\n<h>\n*Remaining functions \n</h>\n<h>\n*Write a simple block driver\n</h>'
'9!ABS SBA!Network Drivers!ABS SBA!*Write a dummy network driver!ABS SBA!<h>\n*Comparison to Block and Character\nDrivers.\n</h>\n<h>\n*Exploring the skelton Driver - stage 1\n</h>\n<h>\n*Snull design\n</h>\n<h>\n*Connecting to the kernel\n</h>\n<h>\n*Opening and Closing\n</h>\n<h>\n*Packet Transmission\n</h>\n<h>\n*Packet Reception\n</h>\n<h>\n*Exploring the skelton Driver - stage 2\n</h>\n<h>\n*The Interrupt Handler\n</h>\n<h>\n*Receive Interrupt Mitigation\n</h>\n<h>\n*Changes in Link state\n</h>\n<h>\n*The virtual Network Interface\n</h>\n<h>\n*Write a dummy network driver\n</h>'
'10!ABS SBA!Debugging Kernel Code!ABS SBA!!ABS SBA!<h>\n*Using printk\n</h>\n<h>\n*Oops and Ksymoops\n</h>\n<h>\n*The Magic Sys Rq Key\n</h>\n<h>\n*Using strace\n</h>\n<h>\n*Remote debugging via the Serial Port\n</h>\n<h>\n*Debugging by query & watching.\n</h>\n<h>\n*Debugging system faults.\n</h>'
'31!ABS SBA!title!ABS SBA!None!ABS SBA!Linux Device Drivers Training'
'32!ABS SBA!subtitle!ABS SBA!None!ABS SBA!5-day session'
'33!ABS SBA!h_Overview!ABS SBA!None!ABS SBA!Understanding the responsibilities and structure of a Linux device.\nUnderstanding the development and operating environment for a LDD.\nUnderstanding Character drivers, Block drivers and Network drivers.\nUnderstanding Debug and Deployment of device drivers.\nPractical labs.'
'34!ABS SBA!h_Duration!ABS SBA!None!ABS SBA!Five days - 40 hours (8 hours a day)\n50% of lecture, 50% of practical labs'
'35!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'36!ABS SBA!h_Trainer!ABS SBA!None!ABS SBA!<a href="https://www.linkedin.com/in/pravinkumarsinha">http://www.linkedin.com/in/pravinkumarsinha</a>'
'37!ABS SBA!h_Audience!ABS SBA!None!ABS SBA!Professional device driver developers for Linux'
'38!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'39!ABS SBA!h_Prerequisite!ABS SBA!None!ABS SBA!<b>Knowledge of C programming</b>\nIn particular, participants must be familiar with creating and dealing with\ncomplex data types and structures, with pointers to such symbols, as well as\nwith function pointers.\nAdvance C training agenda is available at\n<a href="http://minhinc.42web.io/training/c/advance-c-slides.php">http://minhinc.42web.io/training/c/advance-c-slides.php</a>\ncan be dowloaded from\n<a href="http://minhinc.42web.io/training/c/advance-c-slides.pdf">http://minhinc.42web.io/training/advance-c-slides.pdf</a>\n\n<b>Knowledge of system programing Concepts</b>\nIn particular, participants must be familiar with various aspects of system\nprogramming, i.e. File System, Process management, Virtual memory management,\nIPC, Signals etc.\nLinux internals training agenda is available at\n<a href="http://minhinc.42web.io/training/li/advance-li-slides.php">http://minhinc.42web.io/training/li/advance-li-slides.php</a>'
'40!ABS SBA!h_Setup!ABS SBA!None!ABS SBA!Raspberry pi 3, Ubuntu 16/17 LTS'
'41!ABS SBA!h2_Description!ABS SBA!None!ABS SBA!This course gives developers the knowledge of design, write and debug linux\ndevice drivers. All examples are written and executed on Raspberry Pi3 hardware\nwith Raspibian (flavour of Debian) OS installed. All cross compilation will be\ndone on Ubuntu 16/17 LTS.'
'42!ABS SBA!h2_Lecture!ABS SBA!None!ABS SBA!Lecture session will be course content presentation through the trainer.\nAny source code example related to the topic will be demonstrated, it would\ninclude executing the binaries. Complete lecture material can be downloaded from\n<a href="http://minhinc.42web.io/training/advance-ldd-slides.pdf">http://minhinc.42web.io/training/advance-ldd-slides.pdf</a>'
'43!ABS SBA!h2_Labs!ABS SBA!None!ABS SBA!Labs session would be completely hands on session where each example\n(with example data and execution instruction) would be provided to the\nstudents. Students can verify their results with the results provided in\nthe material.'
'101!ABS SBA!Multimedia drivers!ABS SBA!!ABS SBA!None'
'102!ABS SBA!Display drivers!ABS SBA!!ABS SBA!None'
'103!ABS SBA!Advanced char driver operation!ABS SBA!*Interrupt\n- Setup ISR for interrupt and trigger it\n  through GPIO!ABS SBA!None'
      li      
'1!ABS SBA!Introduction to Linux!ABS SBA!*mknod!ABS SBA!<h>\n*GNU Project/GPL Licensing\n</h>\n\na) You must cause the modified files to carry prominent notices stating that you changed the files and the date of any changes.\nb) You must cause any work that you distribute or publish, that in whole or in part contains or is derived from the Program or any part thereof, to be licensed as a whole at no charge to all third parties under the terms of this License.\nc) If the modified program normally reads commands interactively when run, you must cause it, when started running for such interactive use in the most ordinary way, to print or display an announcement including an appropriate copyright notice and a notice that there is no warranty (or else, saying that you provide a warranty) and that users may redistribute the program under these conditions, and telling the user how to view a copy of this License. (Exception: if the Program itself is interactive but does not normally print such an announcement, your work based on the Program is not required to print an announcement.)\n\n<h>\n*Evolution of Linux & Development Model\n</h>\n\n<cc>\n* 1991: The Linux kernel is publicly announced on 25 August by the 21-year-old Finnish student Linus Benedict Torvalds.^[13]\n* 1992: The Linux kernel is relicensed under the GNU GPL. The first Linux distributions are created.\n* 1993: Over 100 developers work on the Linux kernel. With their assistance the kernel is adapted to the GNU environment, which creates a large spectrum of application types for Linux. The oldest currently (as of 2015) existing Linux distribution, Slackware, is released for the first time. Later in the same year, the Debian project is established. Today it is the largest community distribution.\n* 1994: Torvalds judges all components of the kernel to be fully matured: he releases version 1.0 of Linux. The XFree86 project contributes a graphical user interface (GUI). Commercial Linux distribution makers Red Hat and SUSE publish version 1.0 of their Linux distributions.\n* 1995: Linux is ported to the DEC Alpha and to the Sun SPARC.Over the following years it is ported to an ever greater number of platforms.\n* 1996: Version 2.0 of the Linux kernel is released. The kernel can now serve several processors at the same time using symmetric multiprocessing (SMP), and thereby becomes a serious alternative for many companies.\n* 1998: Many major companies such as IBM, Compaq and Oracle announce their support for Linux. The Cathedral and the Bazaar is first published as an essay (later as a book), resulting in Netscape publicly releasing the source code to its Netscape Communicator web browser suite. Netscape\'s actions and crediting of the essay^[50] brings Linux\'s open source development model to the attention of the popular  technical press. In addition a group of programmers begins developing the graphical user interface KDE.\n* 1999: A group of developers begin work on the graphical environment GNOME, destined to become a free replacement for KDE, which at the time, depends on the, then proprietary, Qt toolkit. During the year IBM announces an extensive project for the support of Linux.\n* 2000: Dell announces that it is now the No. 2 provider of Linux-based systems worldwide and the first major  manufacturer to offer Linux across its full product\n* 2002: The media reports that "Microsoft killed Dell Linux"^[52]\n* 2004: The XFree86 team splits up and joins with the existing X standards body to form the X.Org Foundation, which results in a substantially faster development of the X server for Linux.\n* 2005: The project openSUSE begins a free distribution from Novell\'s community. Also the project OpenOffice.org introduces version 2.0 that then started supporting OASIS OpenDocument standards.\n* 2006: Oracle releases its own distribution of Red Hat Enterprise Linux.  Novell and Microsoft announce cooperation for a better interoperability and mutual patent protection.\n* 2007: Dell starts distributing laptops with Ubuntu pre-installed on them.\n* 2009: RedHat\'s market capitalization equals Sun\'s, interpreted as a symbolic moment for the "Linux-based  economy".^[53]\n* 2011: Version 3.0 of the Linux kernel is released.\n* 2012: The aggregate Linux server market revenue exceeds that of the rest of the Unix market.^[54]\n* 2013: Google\'s Linux-based Android claims 75% of the smartphone market share, in terms of the number of phones  shipped.^[55]\n* 2014: Ubuntu claims 22,000,000 users.^[56]\n* 2015: Version 4.0 of the Linux kernel is released.\n</cc>\n\n<m>http://minhinc.42web.io/image/li-slide-linuxhistory.png</m>\n\n<h>\nDevice Identities in Linux-Partitioning Schema\n</h>\n\nDevice comes in two flavours:\n- A character device represents a hardware device that reads or writes a serial stream of data bytes. Serial and parallel ports, tape drives, terminal devices, and sound cards.\n\n-A block device represents a hardware device that reads or write data in fixed size blocks.unlike a character device, a block device provides random access to data stored on the device.a disk drive is an example of a block device.\n\nLinux identifies devices using two numbers:the major device number and the minor device number.\n\nMajor device number generally identifies a driver where as minor number identifies devices controlled by the driver.so actual device is identified as major:minor combination. A device can be master and slave. master are identified with 1,2,3... and slaves as 65,66,67...\n\nFor each device there is a device file or device entry in the file system.cp rm mv commands works on device file as regular file.data transfer happens from actual device through device driver. use mknod to create file entry for the device.\n\n$mknod ./lp0 c 6 0\n<c>\nlp0 - path to the device file\nc - character device, b for block device\n6 - major device number, driver id\n0 - minor master device number\n</c>\n\n$ls -l lp0\n<c>\ncrw-r----- 1 root root 6, 0 Mar 7 17:03 lp0\n#include <stdio.h>\nint main(int argc, char *argv[]){\nstat("lp0")\nprintf("file type\n");\nprintf("major file number\n");\nprintf("minor file number\n");\nreturn 0;\n}\n</c>'
'2!ABS SBA!Introduction to Kernel!ABS SBA!!ABS SBA!<h>\n*History of Linux\n</h>\n\n<pre class="blue">History</pre>\n<c>\n- UNIX: 1969 Thompson & Ritchie AT&T Bell Labs.\n- BSD: 1978 Berkeley Software Distribution.\n- Commercial Vendors: Sun, HP, IBM, SGI, DEC.\n- GNU: 1984 Richard Stallman, FSF.\n- POSIX: 1986 IEEE Portable Operating System unIX.\n- Minix: 1987 Andy Tannenbaum.\n- SVR4: 1989 AT&T and Sun.\n- Linux: 1991 Linus Torvalds Intel 386 (i386).\n- Open Source: GPL.\n</c>\n\n<pre class="blue">Linux Features</pre>\n- UNIX-like operating system\n- Features:\n   - Preemptive multitasking.\n   - Virtual memory (protected memory, paging).\n   - Shared libraries.\n   - Demand loading, dynamic kernel modules.\n   - Shared copy-on-write executables.\n   - TCP/IP networking.\n   - SMP support.\n   - Open source.\n\n<pre class="blue">What\'s a Kernel?</pre>\n- AKA: executive, system monitor.\n- Controls and mediates access to hardware.\n- Implements and supports fundamental abstractions:\n  - Processes, files, devices etc.\n- Schedules / allocates system resources:\n  - Memory, CPU, disk, descriptors, etc.\n- Enforces security and protection.\n- Responds to user requests for service (system calls).\n- Etc...\n\n<pre class="blue">Kernel Design Goals</pre>\n- Performance: efficiency, speed.\n   - Utilize resources to capacity with low overhead.\n- Stability: robustness, resilience.\n   - Uptime, graceful degradation.\n- Capability: features, flexibility, compatibility.\n- Security, protection.\n   - Protect users from each other & system from bad\n    users.\n- Portability.\n- Extensibility.\n\n<pre class="blue">Kernel Modules</pre>\n<m>http://minhinc.42web.io/image/li-slide-kerneldesigngoal.png</m>\n\n<h>\n*Types of kernel\n</h>\n\nTypes of Kernel\n- Monolithic.\n- Layered.\n- Modularized.\n- Micro-kernel.\n- Virtual machine.\n\n<m>http://minhinc.42web.io/image/li-slide-kerneltype_s.png</m>\n\nA monolithic kernel is a kernel where all services (file system, VFS, device drivers, etc) as well as core functionality (scheduling, memory allocation, etc.) are a tight knit group sharing the same space. This directly opposes a microkernel.\n\nA monolithic kernel is a kernel architecture where the entire operating system is working in the kernel space and alone as supervisor mode. In difference with other architectures,1 the monolithic kernel defines alone a high-level virtual interface over computer hardware, with a set of primitives or system calls to implement all operating system services such as process management, concurrency, and memory management itself and one or more device drivers as modules.\n\nA microkernel prefers an approach where core functionality is isolated from system services and device drivers (which are basically just system services). For instance, VFS (virtual file system) and block device file systems (i.e. minixfs) are separate processes that run outside of the kernel\'s space, using IPC to communicate with the kernel, other services and user processes. In short, if it\'s a module in Linux, it\'s a service in a microkernel, indicating an isolated process.\n\nRecent versions of Windows on the other hand use a Hybrid kernel.\n\nA hybrid kernel is a kernel architecture based on combining aspects of microkernel and monolithic kernel architectures used in computer operating systems. The category is controversial due to the similarity to monolithic kernel; the term has been dismissed by some as simple marketing. The traditional kernel categories are monolithic kernels and microkernels (with nanokernels and exokernels seen as more extreme versions of microkernels).\n\n<h>\n*The Linux Kernel\n</h>\n\n<pre class="blue">The Linux Kernel</pre>\n-Monolithic\n\n<h>\n*Kernel Architecture\n</h>\n\n<pre class="blue">Linux Source Tree</pre>\n<m>http://minhinc.42web.io/image/li-slide-linuxtreelayout.png</m>\n\n<pre class="blue">linux/arch</pre>\n- Subdirectories for each current port.\n- Each contains kernel, lib, mm, boot and other directories whose contents override code stubs in architecture independent code.\n- lib directory contains highly-optimized common utility routines\n  such as memcpy, checksums, etc.\n- arch directory as of 2.4:\n   - alpha, arm, i386, ia64, m68k, mips, mips64.\n   - ppc, s390, sh, sparc, sparc64.\n\n<pre class="blue">linux/drivers</pre>\n- Largest amount of code in the kernel tree (~1.5M).\n- device, bus, platform and general directories.\n- drivers/char - n_tty.c is the default line discipline.\n- drivers/block - elevator.c, genhd.c, linear.c, ll_rw_blk.c, raidN.c.\n- drivers/net - specific drivers and general routines Space.c and net_init.c.\n- drivers/scsi - scsi_*.c files are generic; sd.c (disk), sr.c (CD- ROM), st.c (tape), sg.c (generic).\n- General:\n   - cdrom, ide, isdn, parport, pcmcia, pnp, sound, telephony, video.\n- Buses - fc4, i2c, nubus, pci, sbus, tc, usb.\n- Platforms - acorn, macintosh, s390, sgi.\n\n<pre class="blue">linux/fs</pre>\n- Contains:\n   - virtual filesystem (VFS) framework.\n   - subdirectories for actual filesystems.\n- vfs-related files:\n   - exec.c, binfmt_*.c - files for mapping new process images.\n   - devices.c, blk_dev.c - device registration, block device support.\n   - super.c, filesystems.c.\n   - inode.c, dcache.c, namei.c, buffer.c, file_table.c.\n   - open.c, read_write.c, select.c, pipe.c, fifo.c.\n   - fcntl.c, ioctl.c, locks.c, dquot.c, stat.c.\n\n<pre class="blue">linux/include</pre>\n- include/asm-*:\n   - Architecture-dependent include subdirectories.\n- include/linux:\n   - Header info needed both by the kernel and user apps.\n   - Usually linked to /usr/include/linux.\n   - Kernel-only portions guarded by #ifdefs\n       - #ifdef __KERNEL__\n       -      /* kernel stuff */\n       - #endif\n- Other directories:\n   - math-emu, net, pcmcia, scsi, video.\n\n<pre class="blue">linux/init</pre>\n- Just two files: version.c, main.c.\n- version.c - contains the version banner that prints at\n  boot.\n- main.c - architecture-independent boot code.\n- start_kernel is the primary entry point.\n\n<pre class="blue">linux/ipc</pre>\n- System V IPC facilities.\n- If disabled at compile-time, util.c exports stubs that\n  simply return -ENOSYS.\n- One file for each facility:\n   - sem.c - semaphores.\n   - shm.c - shared memory.\n   - msg.c - message queues.\n\n<pre class="blue">linux/kernel</pre>\n- The core kernel code.\n- sched.c - "the main kernel file":\n   - scheduler, wait queues, timers, alarms, task queues.\n- Process control:\n   - fork.c, exec.c, signal.c, exit.c etc...\n- Kernel module support:\n   - kmod.c, ksyms.c, module.c.\n- Other operations:\n   - time.c, resource.c, dma.c, softirq.c, itimer.c.\n   - printk.c, info.c, panic.c, sysctl.c, sys.c.\n\n<pre class="blue">linux/lib</pre>\n- kernel code cannot call standard C library routines.\n- Files:\n   - brlock.c - "Big Reader" spinlocks.\n   - cmdline.c - kernel command line parsing routines.\n   - errno.c - global definition of errno.\n   - inflate.c - "gunzip" part of gzip.c used during boot.\n   - string.c - portable string code.\n       - Usually replaced by optimized, architecture-\n         dependent routines.\n   - vsprintf.c - libc replacement.\n\n<pre class="blue">linux/mm</pre>\n- Paging and swapping:\n   - swap.c, swapfile.c (paging devices), swap_state.c (cache).\n   - vmscan.c - paging policies, kswapd.\n   - page_io.c - low-level page transfer.\n- Allocation and deallocation:\n   - slab.c - slab allocator.\n   - page_alloc.c - page-based allocator.\n   - vmalloc.c - kernel virtual-memory allocator.\n- Memory mapping:\n   - memory.c - paging, fault-handling, page table code.\n   - filemap.c - file mapping.\n   - mmap.c, mremap.c, mlock.c, mprotect.c.\n\n<pre class="blue">linux/scripts</pre>\n- Scripts for:\n  - Menu-based kernel configuration.\n  - Kernel patching.\n  - Generating kernel documentation.'
'3!ABS SBA!Shell commands & Shell!ABS SBA!*Write a Makefile to compile file\n*Create a static library using Makefile\n*Create a dynamic library using Makefile\n*Write application using static library and\ndynamic library generated!ABS SBA!<h>\n*Basic Shell commands\n*Bash Shell Essentials\n- Introduction\n</h>\n\n<pre class="blue">Shell structure</pre>\nShell scripting has four components\n1) Kernel\n2) Shell Process\n3) Command Process\n4) Redirectors, Pipes, Filters etc.\n\nKernel does\n- I/O management\n- Process management\n- File management\n- Memory management\n\n\n\n<c>\n-----------          -----------------            -------------\n|  User   | ------>  |   Linux Shell | ---------> |  Kernel   |\n-----------          -----------------            -------------\n                             |\n                             V\n                    -------------------\n                    | command process |\n                    -------------------\n</c>\n\n<m>http://minhinc.42web.io/image/li-slide-shellstructure.png</m>\n\n<pre class="blue">Shells</pre>\n\n<m>http://minhinc.42web.io/image/li-slide-shellstructure1.png</m>\n\nNOTE: To find your shell type following command\n$ echo $SHELL\n\n<pre class="blue">Linux Common Commands</pre>\n$ date --help\n\n$ ls --help | more\n<c>\nSyntax: command-name --help\nSyntax: man command-name\nSyntax: info command-name\n</c>\n\n$ man ls\n$ info bash\n<c>\nNOTE: In MS-DOS, you get help by using /? clue or by typing help command as\nC:\\> dir /?\nC:\\> date /?\nC:\\> help time\nC:\\> help date\nC:\\> help\n</c>\n\n<pre class="black">Linux Command</pre>\n$ date\n$ who\n$ pwd\n$ ls\n$ cat > myfile\n$ more    myfile\n$ mv sales\n\n\n$ ln  Page1  Book1\n$ rm    myfile\n$ rm -rf  oldfiles\n$ chmod u+x,g+wx,o+x   myscript\n$ mail\n$ who am i\n$ logout\n$ mail ashish\n$ wc    myfile\n$ grep  fox\n$ sort  myfile\n$ tail +5   myfile\n$ cmp myfile\n$ pr  myfile\n\n<h>\n* - Process\n</h>\n\n<pre class="blue">Process</pre>\nA process is program (command given by user) to perform some Job. In Linux when you start process, it gives a number (called PID or process-id), PID starts from 0 to 65535.\n$ ls -lR , is command or a request to list files in a directory and all sub directory in your current directory.\n\n<pre class="black">Why Process required</pre>\nLinux is multi-user, multitasking o/s. It means you can run more than two process simultaneously if you wish. For e.g.. To find how many files do you have on your system you may give command like\n$ ls / -R | wc -l\nThis command will take lot of time to search all files on your system. So you can run such command in Background or simultaneously by giving command like\n$ ls / -R | wc -l &\nThe ampersand (&) at the end of command tells shells start command (ls / -R | wc -l) and run it in background takes next command immediately. An instance of\nrunning command is called process and the number printed by shell is called process-id (PID), this PID can be use to refer specific running process.\n\n<h>\n*-Shell Programming\n</h>\n\n<pre class="blue">Redirection of Standard output/input or Input - Output redirection</pre>\n(1) > Redirector Symbol (Truncate to zero and write)\n<c>\nSyntax: Linux-command > filename\n</c>\n$ ls > myfiles\n<c>\n(2) >> Redirector Symbol  (Append)\nSyntax: Linux-command >> filename\n</c>\n$ date >> myfiles\n(3) < Redirector Symbol\n<c>\nSyntax: Linux-command < filename\nTo take input to Linux-command from file instead of key-board. For e.g. To take input for cat command give\n</c>\n$ cat < myfiles\n\n<pre class="black">Pipes</pre>\nA pipe is a way to connect the output of one program to the input of another program without any temporary file.\n\n\n<m>http://minhinc.42web.io/image/li-slide-shellpipe.png</m>\n\nA pipe is nothing but a temporary storage place where the output of one command is stored and then passed as the input for second command. Pipes are used to run more than two commands ( Multiple commands) from same command line.\n<c>\nSyntax: command1 | command2\n</c>\n\nFilter\nA filter command takes input from a pipe and constricts the output of the previous program.\n$ tail +20 < hotel.txt | head -n30 >hlist\nHere head is filter which takes its input from tail command (tail command start\nselecting from line number 20 of given file i.e. hotel.txt) and passes this lines to\ninput to head, whose output is redirected to \'hlist\' file.\n\n<h>\n* - Shell Programming\n</h>\n\n<pre class="blue">Introduction to Shell Programming</pre>\nShell program is series of Linux commands.\n\nVariables in Linux\nSometimes to process our data/information,  variables are remembered by shell Process.\n\n1) System variables - Created and maintained by Linux itself. This type of variable defined in CAPITAL LETTERS.\n2) User defined variables (UDV) - Created and maintained by user. This type of variable defined in lower LETTERS.\n\n<m>http://minhinc.42web.io/image/li-slide-shellsystemvariable.png</m>\n\n$ echo $USERNAME\n$ echo $HOME\n<c>\nCaution: Do not modify System variable this can some time create problems.\n\n<pre class="black">User Defined Variable</pre>\nSyntax: variablename=value\nNOTE: Here \'value\' is assigned to given \'variablename\' and Value must be on right side = sign For\ne.g.\n</c>\n$ no=10           # this is ok\n$ 10=no           # Error, NOT Ok, Value must be on right side of = sign.\nTo define variable called \'vech\' having value Bus\n\n$ vech=Bus\nTo define variable called n having value 10\n$ n=10\n\nYou can define NULL variable as follows (NULL variable is variable which has no value at the time of definition) For e.g.\n$ vech=\n$ vech=""\nTry to print it\'s value $ echo $vech , Here nothing will be shown because variable has no value i.e. NULL variable.\n\nTo print or access variables use following syntax\n<c>\nSyntax: $variablename\nFor eg. To print contains of variable \'vech\'\n</c>\n$ echo $vech\n\n<pre class="black">How to Run Shell Scripts</pre>\n(1) Use chmod command as follows to give execution permission to our script\n<c>\nSyntax: chmod +x shell-script-name\nOR Syntax: chmod 777 shell-script-name\n(2) Run our script as\nSyntax: ./your-shell-program-name\nFor e.g.\n</c>\n$ ./first\n\nOR /bin/sh your-shell-program-name\nFor e.g.\n$ bash first\n$ /bin/sh first\n\nScript file name complete path is required OR  PATH variable needs to be set.\nTo run the script, file name complete path is required\n\n<m>http://minhinc.42web.io/image/li-slide-filepath.png</m>\n\nOR  PATH variable needs to be set.\n\n<pre class="blue">Commands Related with Shell Programming</pre>\n(1)echo [options] [string, variables...]\nDisplays text or variables value on screen.\nOptions\n<c>\n-n Do not output the trailing new line.\n-e Enable interpretation of the following backslash escaped characters in the strings:\n\\a alert (bell)\n\\b backspace\n\\c suppress trailing new line\n\n new line\n\\r carriage return\n\\t horizontal tab\n\\\\ backslash\n</c>\nFor eg. $ echo -e "An apple a day keeps away \\a\\t\\tdoctor\n"\n\n(2)More about Quotes\nThere are three types of quotes\n<c>\n" i.e. Double Quotes\n\' i.e. Single quotes\n` i.e. Back quote\n1."Double Quotes" - Anything enclose in double quotes removed meaning of that characters (except \\ and $).\n2. \'Single quotes\' - Enclosed in single quotes remains unchanged.\n3. `Back quote` - To execute command.\n</c>\nFor eg.\n$ echo "Today is date"\n<c>\nCan\'t print message with today\'s date.\n$ echo "Today is `date`".\nNow it will print today\'s date as, Today is Tue Jan ....,See the `date` statement uses back quote,\n(See also Shell Arithmetic NOTE).\n</c>\n\n3) Shell Arithmetic\n<c>\nUse to perform arithmetic operations For e.g.\n$ expr 1 + 3\n$ expr 2 - 1\n$ expr 10 / 2\n$ expr 20 % 3 # remainder read as 20 mod 3 and remainder is 2)\n$ expr 10 \\* 3 # Multiplication use \\* not * since its wild card)\n$ echo `expr 6 + 3`\nFor the last statement note the following points\n1) First, before expr keyword we used ` (back quote) sign not the (single quote i.e. \') sign. Back\nquote is generally found on the key under tilde (~) on PC keyboards OR To the above of TAB key.\n2) Second, expr is also end with ` i.e. back quote.\n3) Here expr 6 + 3 is evaluated to 9, then echo command prints 9 as sum\n4) Here if you use double quote or single quote, it will NOT work, For eg.\n$ echo "expr 6 + 3" # It will print expr 6 + 3\n$ echo \'expr 6 + 3\'\n</c>\n\n<pre class="black">Command Line arguments\n$ myshell foo bar</pre>\n\n<m>http://minhinc.42web.io/image/li-slide-shellcommandlineargument.png</m>\n<m>http://minhinc.42web.io/image/li-slide-shellcommandlineargument1.png</m>\n\n<pre class="black">Command line arguments or Function arguments</pre>\n\n<m>http://minhinc.42web.io/image/li-slide-shellcommandlineargument2.png</m>\n\n<pre class="black">Exit Status</pre>\nBy default in Linux if particular command is executed, it return two type of values,\nif return value is zero (0), command is successful\nIf return value is nonzero (>0), command is not successful or some sort of error executing command/shell script.\nThis value is know as Exit Status of that command.\nTo determine this exit Status we use $? variable of shell. For eg.\n$ rm unknow1file\nrm: cannot remove \'unkowm1file\': No such file or directory\nand after that if you give command $ echo $?\nit will print nonzero value(>0) to indicate error. Now give command\n$ ls\n$ echo $?\nIt will print 0 to indicate command is successful.\n\n<m>http://minhinc.42web.io/image/li-slide-shellreturn.png</m>\n\n<h>\n*-Programming commands\n</h>\n\n<pre class="blue">If-then-fi for decision making is shell script</pre>\n$ bc\n<c>\nfollows type 5 + 2 as\n5+2\n7\n7 is response of bc i.e. addition of 5 + 2 you can even try\n5-2\n5/2\nNow what happened if you type 5 > 2 as follows\n5>2\n0\n</c>\n\n<m>http://minhinc.42web.io/image/li-slide-shellprogrammingcommand.png</m>\n\n<c>\nSyntax:\nif condition\n then\n    command1 if condition is true or if exit status\n    of condition is 0 (zero)\n     ...\n     ...\nfi\n</c>\n\n<pre class="black">$ cat > showfile</pre>\n<c>\n#!/bin/sh\n#\n#Script to print file\n#\nif cat $1\nthen\n    echo -e "\n\nFile $1, found and successfully echoed"\nfi\n</c>\n\n<pre class="blue">test command or [ expr ]</pre>\ntest command or [ expr ] is used to see if an expression is true, and if it is true it return zero(0),\notherwise returns nonzero(>0) for false. Syntax: test expression OR [ expression ]\nNow will write script that determine whether given argument number is positive. Write script as follows\n$ cat > ispostive\n<c>\n#!/bin/sh\n#\n# Script to see whether argument is positive\n#\nif test $1 -gt 0\nthen\n    echo "$1 number is positive"\nfi\n\nOr\n</c>\n\n$ cat > ispostive\n<c>\n#!/bin/sh\n#\n# Script to see whether argument is positive\n#\nIf [ test $1 -gt 0 ]\nthen\n    echo "$1 number is positive"\nfi\n</c>\n\ntest or [ expr] works with\n1.Integer ( Number without decimal point)\n2.File types\n3.Character strings\nFor Mathematics use following operator in Shell Script\n\n<m>http://minhinc.42web.io/image/li-slide-shellprogrammingcommand1.png</m>\n\nNOTE: == is equal, != is not equal.\nFor string Comparisons use\n\n<m>http://minhinc.42web.io/image/li-slide-shellprogrammingcommand2.png</m>\n\nShell also test for file and directory types\n\n<m>http://minhinc.42web.io/image/li-slide-shellprogrammingcommand3.png</m>\n\n<pre class="blue">if...else...fi</pre>\nIf given condition is true then command1 is executed otherwise command2 is executed.\nSyntax:\n<c>\nif condition\nthen\n  command1 if condition is true or if exit status\n  of condition is 0(zero)\n  ...\n  ...\nelse\n command2 if condition is false or if exit status\n of condition is >0 (nonzero)\n ...\n ...\nfi\n</c>\n$ cat > isnump_n\n<c>\n#!/bin/sh\n# Script to see whether argument is positive or negative\n#\nif [ $# -eq 0 ]\nthen\n      echo "$0 : You must give/supply one integers"\n      exit 1\nfi\nif test $1 -gt 0\nthen\n      echo "$1 number is positive"\nelse\n      echo "$1 number is negative"\nfi\n</c>\n<pre class="blue">Multilevel if-then-else</pre>\nSyntax:\n<c>\nif condition\nthen\n condition is zero (true - 0)\n execute all commands up to elif statement\nelif condition1\n condition1 is zero (true - 0)\n execute all commands up to elif statement\nelif condition2\n condition2 is zero (true - 0)\n execute all commands up to elif statement\nelse\n None of the above condtion,condtion1,condtion2 are true (i.e.\n all of the above nonzero or false)\n execute all commands up to fi\nfi\n\n<pre class="blue">for loop Syntax:</pre>\n for { variable name } in { list }\n do\n   execute one for each item in the list until the list is\n   not finished (And repeat all statement between do and done)\n done\n</c>\n\nSuppose,\n$ cat > testfor\n<c>\nfor i in 1 2 3 4 5\ndo\n    echo "Welcome $i times"\ndone\n</c>\nRun it as,\n$ chmod +x testfor\n$ ./testfor\n\n<pre class="blue">while loop</pre>\nSyntax:\n<c>\nwhile [ condition ]\ndo\n command1\n command2\n command3\n ..\n ....\ndone\n</c>\n\n$cat > nt1\n#!/bin/sh\n#Script to test while statement\n<c>\nif [ $# -eq 0 ]\nthen\n     echo "Error - Number missing form command line argument"\n     echo "Syntax : $0 number"\n     echo " Use to print multiplication table for given number"\n     exit 1\nfi\nn=$1\ni=1\nwhile [ $i -le 10 ]\ndo\n   echo "$n * $i = `expr $i \\* $n`"\n   i=`expr $i + 1`\ndone\n</c>\n\n<pre class="blue">The case Statement</pre>\nThe case statement is good alternative to Multilevel if-then-else-fi statement. It enable you to match several values against one variable. Its easier to read and write.\nSyntax:\n<c>\ncase     $variable-name in\npattern1)             command\n ..\n command;;\npattern2)             command\n ..\n command;;\npatternN) command\n ..\n command;;\n *)           command\n ..\n command;;\nesac\n</c>\n\nThe $variable-name is compared against the patterns until a match is found. The shell then executes all the statements up to the two semicolons that are next to each other. The default is *) and its executed if no match is found. For eg. Create script as follows\n$ cat > car\n<c>\n#\n# if no vehicle name is given\n# i.e. -z $1 is defined and it is NULL\n#\n# if no command line arg\nif [ -z $1 ]\nthen\n      rental="*** Unknown vehicle ***"\nelif [ -n $1 ]\nthen\n# otherwise make first arg as rental\n      rental=$1\nfi\ncase $rental in\n   "car") echo "For $rental Rs.20 per k/m";;\n   "van") echo "For $rental Rs.10 per k/m";;\n   "jeep") echo "For $rental Rs.5 per k/m";;\n   "bicycle") echo "For $rental 20 paisa per k/m";;\n   *) echo "Sorry, I can not gat a $rental for you";;\nesac\n</c>\n\nSave it by pressing CTRL+D\n$ chmod +x car\n$ car van\n$ car car\n$ car Maruti-800\n\n<pre class="blue">The read Statement</pre>\nUse to get input from keyboard and store them to variable.\n<c>\nSyntax: read varible1, varible2,...varibleN\n</c>\nCreate script as\n$ cat > sayH\n#\n#Script to read your name from key-board\n#\n<c>\necho "Your first name please:"\nread fname\necho "Hello $fname, Lets be friend!"\nRun it as follows\n</c>\n$ chmod +x sayH\n$ ./sayH\n<c>\n\n<pre class="blue">Filename Shorthand or meta Characters (i.e. wild cards)</pre>\n* or ? or [...] is one of such shorthand character.\n* Matches any string or group of characters.\nFor e.g. $ ls * , will show all files, $ ls a* - will show all files whose first name is starting with letter\n\'a\', $ ls *.c ,will show all files having extension .c $ ls ut*.c, will show all files having extension .c but first two letters of file name must be \'ut\'.\n? Matches any single character.\nFor e.g. $ ls ? , will show one single letter file name, $ ls fo? , will show all files whose names are 3 character long and file name begin with fo\n[...] Matches any one of the enclosed characters.\nFor e.g. $ ls [abc]* - will show all files beginning with letters a,b,c\n[..-..] A pair of characters separated by a minus sign denotes a range;\nFor eg. $ ls /bin/[a-c]* - will show all files name beginning with letter a,b or c like\n/bin/arch        /bin/awk       /bin/bsh    /bin/chmod         /bin/cp\n/bin/ash         /bin/basename  /bin/cat    /bin/chown         /bin/cpio\n/bin/ash.static  /bin/bash      /bin/chgrp  /bin/consolechars  /bin/csh\n</c>\n\nBut\n\n$ ls /bin/[!a-o]\n$ ls /bin/[^a-o]\n\n<pre class="blue">command1;command2</pre>\nTo run two command with one command line.For eg. $ date;who ,Will print today\'s date followed\n http://www.freeos.com/guides/lsst/shellprog.htm (18 of 19) [17/08/2001 17.42.21]\n Linux Shell Script Tutorial\nby users who are currently login.\n\n<h>\n*- Advance Shell Programming\n   - Function\n   - Array\n   - I/O Redirection and file descriptor\n   - Local and Global variables\n   - Conditional Execution\n</h>\n\n<pre class="blue">/dev/null - Use to send unwanted output of program</pre>\nSyntax: command > /dev/null\nFor e.g. $ ls > /dev/null , output of this command is not shown on screen its send to this special file. The /dev directory contains other device files. The files in this directory mostly represent peripheral devices such disks liks floppy disk, sound card, line printers etc.\n<pre class="blue">local and Global Shell variable (export command)</pre>\nNormally all our variables are local. Local variable can be used in same shell, if you load another copy of shell (by typing the /bin/bash at the $ prompt) then new shell ignored all old shell\'s variable. For e.g.\nConsider following example\n$ vech=Bus\n$ echo $vech\nBus\n$ /bin/bash\n$ echo $vech\nNOTE:-Empty line printed\n$ vech=Car\n$ echo $vech\nCar\n$ exit\n$ echo $vech\n\n<pre class="blue">Syntax: export variable1, variable2,.....variableN</pre>\nFor e.g.\n$ vech=Bus\n$ echo $vech\nBus\n$ export vech\n$ /bin/bash\n$ echo $vech\nBus\n$ exit\n$ echo $vech\n\n<pre class="blue">Conditional execution i.e. && and ||</pre>\nThe control operators are && (read as AND) and || (read as OR). An AND list has the\nSyntax: command1 && command2\nHere command2 is executed if, and only if, command1 returns an exit status of zero. An OR list has the\nSyntax: command1 || command2\nHere command2 is executed if and only if command1 returns a non-zero exit status. You can use both as follows\ncommand1 && comamnd2 if exist status is zero || command3 if exit status is non-zero\nHere if command1 is executed successfully then shell will run command2 and if command1 is not successful then command3 is executed. For e.g.\n$ rm myf && echo File is removed successfully || echo File is not removed\nIf file (myf) is removed successful (exist status is zero) then "echo File is removed successfully" statement is executed, otherwise "echo File is not removed" statement is executed (since exist status is non-zero)\n\n<pre class="blue">Functions</pre>\nFunction is series of instruction/commands. Function performs particular activity in shell. To define function use following\nSyntax:\n<c>\nfunction-name ( )\n{\n command1\n command2\n .....\n ...\n commandN\n return\n}\n</c>\n\nWhere function-name is name of you function, that executes these commands. A return statement will terminate the function. For e.g. Type SayHello() at $ prompt as follows\n<c>\n$ SayHello()\n{\necho "Hello $LOGNAME, Have nice computing"\nreturn\n}\n</c>\n$ SayHello\nHello xxxxx, Have nice computing\nEdit /etc/bashrc (as root) or ~/.bashrc for executing function at login time.\n\n<pre class="blue">I/O Redirection and file descriptors</pre>\n$ cat > myf\n<c>\n      This is my file\n      ^D\n</c>\nAbove command send output of cat command to myf file. Redirection can be used to send output to stderr, stdout and can be used to read input for stdin files\n\n<m>http://minhinc.42web.io/image/li-slide-standarddescriptor.png</m>\n\n<c>\n[sc@localhost ~]$ rm > tmp1\n<b>rm: missing operand\nTry \'rm --help\' for more information.\n[sc@localhost ~]$ cat tmp1\n[sc@localhost ~]$ rm > tmp1 2>&1\n[sc@localhost ~]$ cat tmp1\nrm: missing operand\nTry \'rm --help\' for more information.</b>\n[sc@localhost ~]$\n</c>\n\n\n<pre class="blue">Array</pre>\nArrays are define as\nar=(one two three)\n\nfor i in 2 4 5 6; do\ndone\n\nfor i in {1..6}; do\ndone\n\n${ar[1]} ${ar[2]} ...\n\n$ar[*] or $ar[@]  # for list\n\n${#ar[*]}  # for number of elements\n\nfor i in ${ar[@]}; do\ndone\n\n<h>\n*Creating Makefiles\n</h>\n\nConstituents of a make file\n* Rules\n* Variables\n* Directives\n  - Inclusion of another make\n  - Conditional directives\n* Comments\n  - Text that follows # symbol is treated as comment\n  - To include # literally, prefix with \\\n\nRules\nSyntax\n<c>\ntarget1 [target2] : [prerequisite1] [prerequisite2]\n<TAB>command-1\n<TAB>command-2\n</c>\n\n<m>http://minhinc.42web.io/image/li-slide-makefile.png</m>\n\n* Explicit rule\n  - explicitly specify the prerequisites for a specific target\n* Implicit rules\n  - Take advantage of the knowledge make has about known patterns of files (e.g., .c, .cpp .o, .s)\n  - Further classified into pattern rules & suffix rules\n\n Variables\nPredefined\no Some commonly used variables predefined by GNU make CC , FLAGS , CFLAGS, LDFLAGS, $@, $^, $<\n\n$@ name of the target\n               foo1.o: foo1.c foo1.h\n$<    name of the first prerequisite\n               gcc -c $<\n$^       names of all prerequisites\n\nfoo: foo1.o foo2.o\n\tgcc -o $@ $^\n\nfoo: foo1.o foo2.o\n\tgcc -o foo foo1.o foo2.o\n\nfoo2.o: foo2.c foo2.h\n\tgcc -c $<\nfoo2.o: foo2.c foo2.h foo1.h\n gcc -c foo2.c\n\nUser defined\nABC:=10  # const assigment\nABC=10 # non const assignment\n\nCommand line  variables\nVariables can be defined or redefined from command line\n$ make\n$ make VAR1=abc VAR2=xyz\n\nUse <b>override</b> directive to let undesirable command line redefines for a variable be ignored\nex.\nVAR1=dummy\nVAR2=\nAll:\n\techo  VAR1 =  $(VAR1)\n\techo VAR2 = override    $(VAR2)\n\tVAR1=dummy\n\nConditional assingment\nARCH ?= x86\nAppend\nSRC += x.c\n\nImplicit rules\n\nWildcard\nfoo: *.o\ngcc -o $@ $^X\n\nFunctions\nGeneral syntax\n  $(function-name arg1[,argn])\n       SRC := x.c y.c z.c\n* String functions\n- $(subst search-str,replace-str,text)\n           OBJS := $(subst .c,.o,$(SRC))\n- $(patsubst search-pat,replace-pat,text)\n           OBJS := $(patsubst %.c, obj/%.o, x.c y.c z.c)\n\n* Warning function\n   - Very useful for debugging\n   - Can be placed anywhere in a makefile\n             $(warning TARGET not defined)\n     outputs in the format\n     <filename>:<linenum>:TARGET not defined\n* Shell function\n   - Can be used to invoke any external program\n             today := $(shell date)\n\nWildcard function\nSRCS := $(wildcard *.c)\nOBJS := $(subst .c,.o,$(SRCS))\n\nfoo: $(OBJS)\n\tgcc -c $< cc -o $@ $^\nfoo2.o: foo2.c foo2.h foo1.h\n  gcc -c $<\nfoo1.o: foo1.c foo1.h\n gcc -c $<\n\n\nPattern rule\nfoo : foo1.o foo2.o\n\tg++ -o $@ $^\nfoo2.o: foo2.h  foo1.h\nfoo1.o: foo1.h\n\n# pattern rule for .cpp to .o\n %.o : %.cpp\n\tg++ -c $<\n\nMore advanced\n  %.o:%.c\n       $(COMPILE.c) $(OUTPUT_OPTION) $<\nwhere\n   COMPILE.c =$(CC) $(CFLAGS) $(CPPFLAGS ) $(TARGET_ARCH) -c\n   CC =cc\n   OUTPUT_OPTION =-o $@\n\n\nconditionals\nconditional-directive\n    text-if-true\nendif\n\nconditional-directive\n    text-if-true\nelse\n    text-if-false\nendif\n\nConditional directives\n - ifeq\n - ifneq\n - ifdef variable-name\n - ifndef variable-name'
'4!ABS SBA!Creating Libraries!ABS SBA!!ABS SBA!<h>\n*Creating Static Library\n - Using Static Library\n*Creating Shared Library\n</h>\nRefer\n<m>http://minhinc.42web.io/training/cpp/advance-cpp-slides.php#chap1_7</m>\n\n<h>\n* -Using Shared Library\n</h>\n\n<b>Dynamic Loading and Unloading</b>\nThis functionality is available under Linux by using the dlopen function.\n dlopen ("libtest.so", RTLD_LAZY)\n\nThe second parameter is a flag that indicates how to bind symbols in the shared\nLibrary.\nInclude the <dlfcn.h> header file and link with the -ldl option to pick up the\nlibdl library.\n\n<c>\nvoid* handle = dlopen ("libtest.so", RTLD_LAZY);\nvoid (*test)() = dlsym (handle, "my_function");\n(*test)();\ndlclose (handle);\n</c>\n\nBoth dlopen and dlsym return NULL if they do not succeed. In that event, you can call dlerror (with no parameters) to obtain a human-readable error message describing the problem.\n\n<b>C++ file linking to C shared library</b>\nIf you\'re writing the code in your shared library in C++, you will probably want to declare those functions and variables that you plan to access elsewhere with the\n<c>\nextern "C" linkage specifier.\n   extern "C" void foo ();\n</c>\nThis prevents the C++ compiler from mangling the function name, which would change the function\'s name from foo to a different, funny-looking name that encodes extra information about the function. A C compiler will not mangle names; it will use whichever name you give to your function or variable.'
'5!ABS SBA!The Boot Process!ABS SBA!*Cross compiling kernel\n*Board Support packages!ABS SBA!<h>\n*The Boot Process\n</h>\n\nLinux Boot flow\n\n<m>http://minhinc.42web.io/image/li-slide-bootflow.png</m>\n\nBooting Sequence\n\n1. Tern on\n2. CPU jump to address of BIOS (0xFFFF0)\n3. BIOS runs POST (Power-On Self Test)\n4. Find bootale devices\n5. Loads and execute boot sector form MBR\n6. Load OS\n\n<h>\n*BIOS Level\n</h>\n\nBIOS refers to the software code run by a computer when first powered on\nThe primary function of BIOS is code program embedded on a chip that recognizes and controls various devices that make up the computer.\n\n<m>http://minhinc.42web.io/image/li-slide-bios.bmp</m>\n\nMBR Master Boot Record\n- OS is booted from a hard disk, where the Master Boot Record (MBR) contains the primary boot loader\n- The MBR is a 512-byte sector, located in the first sector on the disk (sector 1 of cylinder 0, head 0)\n- After the MBR is loaded into RAM, the BIOS yields control to it.\n\n<m>http://minhinc.42web.io/image/li-slide-MBR.png</m>\n\nMBR, Master Boot Record\n\n - The first 446 bytes are the primary boot loader, which contains both executable code and error message text\n - The next sixty-four bytes are the partition table, which contains a record for each of four partitions\n - The MBR ends with two bytes that are defined as the magic number (0xAA55). The magic number serves as a validation check of the MBR\n\nExtract MBR, Master Boot Record\n<c>\n# dd if=/dev/hda of=mbr.bin bs=512 count=1\n# od -xa mbr.bin\n</c>\n\n<h>\n* - Boot Loader - Setup\n  - startup_32 functions\n*The start_kernel() function\n</h>\n\nBoot Loader\n - Boot loader or kernel loader first decompress kernel zImage file then calls kernel start_kernel() function passing the arguments.\n - Optional, initial RAM disk\n - GRUB and LILO are the most popular Linux boot loader.\n\nList of Boot loaders\nbootman, GRUB, LILO, NTLDR, XOSL, BootX, loadlin, Gujin, Boot Camp, Syslinux, GAG\n\n<m>http://minhinc.42web.io/image/li-slide-bootloader.png</m>\n\nGRUB Boot Loader\n - GRUB is an operating system independent boot loader\n - A multi-boot software packet from GNU\n - Flexible command line interface\n - File system access\n - Support multiple executable format\n - Support disk less system\n - Download OS from network\n\nGRUB Boot Process\n1. The BIOS finds a bootable device (hard disk) and transfers control to the master boot record\n2. The MBR contains GRUB stage 1. Given the small size of the MBR, Stage 1 just load the next stage of GRUB\n3. GRUB Stage 1.5 is located in the first 30 kilobytes of hard disk immediately following the MBR. Stage 1.5 loads Stage 2.\n4. GRUB Stage 2 receives control, and displays to the user the GRUB boot menu (where the user can manually specify the boot parameters).\n5. GRUB loads the user-selected (or default) kernel into memory and passes control on to the kernel.\n\nGRUB Config File\n\n<m>http://minhinc.42web.io/image/li-slide-grub.png</m>\n\nLILO: LInux LOader\n - A versatile boot manager that supports:\n    - Choice of Linux kernels.\n    - Boot time kernel parameters.\n    - Booting non-Linux kernels.\n    - A variety of configurations.\n - Characteristics:\n    - Lives in MBR or partition boot sector.\n    - Has no knowledge of filesystem structure so...\n    - Builds a sector "map file" (block map) to find kernel.\n - /sbin/lilo - "map installer".\n    - /etc/lilo.conf is lilo configuration file.LILO Boot Loader\n\nlilo.conf\n<m>http://minhinc.42web.io/image/li-slide-lilo.png</m>\n<m>http://minhinc.42web.io/image/li-slide-lilo2.png</m>\n\nKernel Booting, Init process\nKernel execute init(pid 1) program,  getting init process.\n - Init is the root/parent of all processes executing on Linux\n - The first processes that init starts is a script /etc/rc.d/rc.sysinit\n - Based on the appropriate run-level, scripts are executed to start various processes to run the system and make it functional\n - Init is responsible for starting system processes as defined in the /etc/inittab file\n - Init typically will start multiple instances of "getty" which waits for console logins which spawn one\'s user shell process\n - Upon shutdown, init controls the sequence and processes for shutdown\n\n<b>Process ID</b>    <b>Description</b>\n0             The Scheduler\n1             The init process\n2               kflushd\n3               kupdate\n4               kpiod\n5               kswapd\n6               mdrecoveryd\n\nLinux files structure\n<m>http://minhinc.42web.io/image/li-slide-linuxfilestructure_s.png</m>'
'6!ABS SBA!The File System!ABS SBA!*Implement late binding\n*Create hard link\n*Create soft link\n*Write a program to enumerate stat structure\nfor both hard link and soft link. Illustrate which\nfield is different!ABS SBA!<h>\n*The File System\n</h>\n\nThe File System\n\nFilesystems are containers of files, that are stored, probably in a directory tree, together with attributes, like size, owner, creation date and the like. A filesystem has a type. It defines how things are arranged on the disk. For example, one has the types minix, ext2, reiserfs, iso9660, vfat, hfs.\n\nLinux File System Layout\n<m>http://minhinc.42web.io/image/li-slide-filesystemlayout.png</m>\n\nInode and direntry\n\n<m>http://minhinc.42web.io/image/li-slide-filesysteminode.png</m>\n\n$mkdir testdir\n\n<m>http://minhinc.42web.io/image/li-slide-filesysteminode1.png</m>\n\nInode\nAn (in-core) inode contains the metadata of a file: its serial number, its protection (mode), its owner, its size, the dates of last access, creation and last modification, etc. It also points to the superblock of the filesystem the file is in, the methods for this file, and the dentries (names) for this file.\n\n<cc>\nstruct inode {\nunsigned long i_ino;\numode_t i_mode;\nuid_t i_uid;\ngid_t i_gid;\nkdev_t i_rdev;\nloff_t i_size;\nstruct timespec i_atime;\nstruct timespec i_ctime;\nstruct timespec i_mtime;\nstruct super_block *i_sb;\nstruct inode_operations *i_op;\nstruct address_space *i_mapping;\nstruct list_head i_dentry;\n...\n}\n</cc>\n\nUser space stat structure provides similar interface\n\n<cc>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\nint stat (const char *path, struct stat *buf);\nint fstat (int fd, struct stat *buf);\nint lstat (const char *path, struct stat *buf);\n\ntruct stat {\ndev_t st_dev; /*ID of device containing file */\nino_t st_ino; /*inode number *\nmode_t st_mode;  /*permissions */\nnlink_t st_nlink; /*number of hard links */\nuid_t st_uid; /*user ID of owner */\ngid_t st_gid; /*group ID of owner */\ndev_t st_rdev; /*device ID (if special file) */\noff_t st_size; /*total size in bytes */\nblksize_t st_blksize; /*blocksize for filesystem I/O */\nblkcnt_t st_blocks; /* number of blocks allocated */\ntime_t st_atime; /*last access time */\ntime_t st_mtime; /*last modification time */\ntime_t st_ctime; /*last status change time */\n};\n</cc>\n\nlstat()  is  identical to stat(), except that if pathname is a symbolic link, then it returns information about the link itself, not  the  file that it refers to.\n\nfstat() is identical to stat(), except that the file about which information is to be retrieved is specified by the file descriptor fd.\n\n<cc>\n#include\n#include\n#include\n#include\n<sys/types.h>\n<sys/stat.h>\n<unistd.h>\n<stdio.h>\nint main (int argc, char *argv[])\n{\nstruct stat sb;\nint ret;\nif (argc < 2) {\nfprintf (stderr,\n"usage: %s <file>\n", argv[0]);\nreturn 1;\n}\nret = stat (argv[1], &sb);\nif (ret) {\nperror ("stat");\nreturn 1;\n}\nprintf ("%s is %ld bytes\n",\nargv[1], sb.st_size);\nreturn 0;\n}\n</cc>\n\nThe following mask values are defined for the file type of the st_mode field:\n<c>\nS_IFMT     0170000   bit mask for the file type bit field\nS_IFSOCK   0140000   socket\nS_IFLNK    0120000   symbolic link\nS_IFREG    0100000   regular file\nS_IFBLK    0060000   block device\nS_IFDIR    0040000   directory\nS_IFCHR    0020000   character device\nS_IFIFO    0010000   FIFO\n</c>\n\nThus, to test for a regular file (for example), one could write:\n<c>\nstat(pathname, &sb);\nif ((sb.st_mode & S_IFMT) == S_IFREG) {\n/* Handle regular file */\n}\n</c>\n\n<cc>\n#include "apue.h"\nint\nmain(int argc, char *argv[])\n{\nint          i;\nstruct stat buf;\nchar         *ptr;\nfor (i = 1; i < argc; i++) {\n printf("%s: ", argv[i]);\n if (lstat(argv[i], &buf) < 0) {\n  err_ret("lstat error");\n   continue;\n }\n\n if (S_ISREG(buf.st_mode))\n  ptr = "regular";\n else if (S_ISDIR(buf.st_mode))\n  ptr = "directory";\n else if (S_ISCHR(buf.st_mode))\n  ptr = "character special";\n else if (S_ISBLK(buf.st_mode))\n  ptr = "block special";\n else if (S_ISFIFO(buf.st_mode))\n  ptr = "fifo";\n else if (S_ISLNK(buf.st_mode))\n  ptr = "symbolic link";\n else if (S_ISSOCK(buf.st_mode))\n  ptr = "socket";\n else\n ptr = "** unknown mode **";\n printf("%s\n", ptr);\n}\n exit(0);\n}\n</cc>\n\nPrinting all fields\n\n<cc>\n# include <fcntl.h>\n# include <stdio.h>\n# include <time.h>\n# include <sys/types.h>\n# include<sys/stat.h>\n\nmain()\n{\nstruct stat fst;\nstruct tm  *Time;\nint fd;\nfd = open("testfile",O_RDONLY);\nfstat(fd,&fst);\nprintf("Listing the detailsd of the file\n");\nprintf(" The inode no of the file is %d\n",fst.st_ino);\nprintf(" The device ID  of the file is %d\n",fst.st_dev);\nprintf(" The block size of the file system is %d\n",fst.st_blksize);\nprintf("The user ID is %d\n",fst.st_uid);\nprintf("The group ID is %d\n",fst.st_gid);\nprintf("Access time is %d\n",fst.st_atime);\nprintf("creation time is %d\n",fst.st_ctime);\nprintf("modification time is %d\n",fst.st_mtime);\nTime = localtime(&fst.st_atime);\n\nprintf("day : %d\n  ",Time->tm_mday);\nprintf("month: %d\n ",Time ->tm_mon);\nprintf("year : %d\n ",Time->tm_year);\nprintf("hour : %d\n ",Time->tm_hour);\nprintf("min : %d\n ",Time ->tm_min);\n}\n</cc>\n\nPermissions\nWhile the stat calls can be used to obtain the permission values for a given file, two other system calls set those values:\n<c>\n#include <sys/types.h>\n#include <sys/stat.h>\nint chmod (const char *path, mode_t mode);\nint fchmod (int fd, mode_t mode);\n</c>\nExample chmod\n\n<c>\nint ret;\n/*\n* Set \'map.png\' in the current directory to\n* owner-readable and -writable. This is the\n* same as \'chmod 600 ./map.png\'.\n*/\nret = chmod ("./map.png", S_IRUSR | S_IWUSR);\nif (ret)\nperror ("chmod");\n</c>\n\nOwnership\nIn the stat structure, the st_uid and st_gid fields provide the file\'s owner and group, respectively. Three system calls allow a user to change those two values:\n<c>\n#include <sys/types.h>\n#include <unistd.h>\nint chown (const char *path, uid_t owner, gid_t group);\nint lchown (const char *path, uid_t owner, gid_t group);\nint fchown (int fd, uid_t owner, gid_t group);\n\nstruct group *gr;\nint ret;\n/*\n* getgrnam() returns information on a group\n* given its name.\n*/\ngr = getgrnam ("officers");\nif (!gr) {\n/* likely an invalid group */\nperror ("getgrnam");\nreturn 1;\n}\n/* set manifest.txt\'s group to \'officers\' */\nret = chown("manifest.txt", -1, gr->gr_gid);\nif (ret)\nperror ("chown");\n</c>\n\nReading a Directory\'s Contents\nA directory is represented by DIR object\n\n<c>\n#include <sys/types.h>\n#include <dirent.h>\nDIR * opendir (const char *name);\n</c>\nTo obtain the file descriptor behind a given directory stream:\n<c>\n#define _BSD_SOURCE /* or _SVID_SOURCE */\n#include <sys/types.h>\n#include <dirent.h>\nint dirfd (DIR *dir);\n</c>\n\nReading from a directory stream\nOnce you have created a directory stream with opendir() , your program can begin reading entries from the directory. To do this, use readdir() , which returns entries one by one from a given DIR object:\n\n<c>\n#include <sys/types.h>\n#include <dirent.h>\nstruct dirent * readdir (DIR *dir);\n</c>\n\nA successful call to readdir() returns the next entry in the directory represented by dir . The dirent structure represents a directory entry. Defined in <dirent.h> , on\nLinux, its definition is:\nApplications successively invoke readdir() , obtaining each file in the directory, until they find the file they are searching for or until the entire directory is read, at which time readdir() returns NULL .\n\n<c>\nstruct dirent {\nino_t d_ino; /* inode number */\noff_t d_off; /* offset to the next dirent */\nunsigned short d_reclen; /* length of this record */\nunsigned char d_type; /* type of file */\nchar d_name[256]; /* filename */\n};\n</c>\n\nTo close the DIR*\n<c>\nint closedir (DIR *dir);\n\n/*\n* find_file_in_dir - searches the directory \'path\' for a\n* file named \'file\'.\n*\n* Returns 0 if \'file\' exists in \'path\' and a nonzero\n* value otherwise.\n*/\nint find_file_in_dir (const char *path, const char *file)\n{\n struct dirent *entry;\n int ret = 1;\n DIR *dir;\n dir = opendir (path);\n errno = 0;\n while ((entry = readdir (dir)) != NULL) {\n  if (strcmp(entry->d_name, file) == 0) {\n  ret = 0;\n  break;\n  }\n }\nif (errno && !entry)\n perror ("readdir");\n\nclosedir (dir);\nreturn ret;\n}\n</c>\n\nSystem calls for reading directory contents\nThe previously discussed functions for reading the contents of directories are standar- dized by POSIX and provided by the C library. Internally, these functions use one of two system calls, readdir() and getdents() , which are provided here for completeness:\n\n<c>\n#include <unistd.h>\n#include <linux/types.h>\n#include <linux/dirent.h>\n\n#include <errno.h>\n/*\n* Not defined for user space: need to\n* use the _syscall3() macro to access.\n*/\nint readdir (unsigned int fd,\nstruct dirent *dirp,\nunsigned int count);\nint getdents (unsigned int fd,\nstruct dirent *dirp,\nunsigned int count);\n</c>\n\nLinks\nA link is essentially just a name in a list (a directory) that points at an inode-there would appear to be no reason why multiple links to the same inode could not exist. That is, a single inode (and thus a single file) could be referenced from, say, both /etc/customs and /var/run/ledger.\n\nHard Link\nFiles can have 0, 1, or many links. Most files have a link count of 1-that is, they are pointed at by a single directory entry-but some files have 2 or even more links. These are called hard link.\n\nThe link() system call, one of the original Unix system calls, and now standardized by POSIX, creates a new link for an existing file:\n\n<c>\n#include <unistd.h>\nint link (const char *oldpath, const char *newpath);\n\nint ret;\n/*\n* create a new directory entry,\n* \'/home/kidd/privateer\', that points at\n* the same inode as \'/home/kidd/pirate\'\n*/\nret = link ("/home/kidd/privateer", /home/kidd/pirate");\nif (ret)\nperror ("link");\n</c>\n\nSymbolic Links\nSymbolic links, also known as symlinks or soft links, are similar to hard links in that both point at files in the filesystem. The symbolic link differs, however, in that it is not merely an additional directory entry, but a special type of file altogether. This special file contains the pathname for a different file, called the symbolic link\'s target. At runtime, on the fly, the kernel substitutes this pathname for the symbolic link\'s pathname (unless using the various l versions of system calls, such as lstat() , which operate on the link itself, and not the target).\nSoft links, unlike hard links, can span filesystems also called dangling softlink.\n\n<c>\n#include <unistd.h>\nint symlink (const char *oldpath, const char *newpath);\n\nint ret;\n/*\n* create a symbolic link,\n* \'/home/kidd/privateer\', that\n* points at \'/home/kidd/pirate\'\n*/\nret = symlink ("/home/kidd/privateer", "/home/kidd/pirate");\nif (ret)\nperror ("symlink");\n</c>\n\nUnlinking\nThe converse to linking is unlinking, the removal of pathnames from the filesystem. A single system call, unlink(), handles this task:\n\n<c>\n#include <unistd.h>\nint unlink (const char *pathname);\n</c>\n\n<h>\n*Virtual File system & its role\n</h>\n\nVFS, Virtual File Systems\n\n- The Linux kernel implements the concept of Virtual File System (VFS, originally Virtual Filesystem Switch), so that it is (to a large degree) possible to separate actual "low-level" filesystem code from the rest of the kernel.\n- The VFS is more of an Interface rather than an actual complete file system.\n- An important role of the VFS is to perform what is called "Standard Actions". For example, the function lseek() is not actually implemented by any file system, as the function of lseek() is provided by a "standard action" of VFS.\n- Two important native filesystems in the Linux environment are ext2 and the proc file system.\n\n<m>http://minhinc.42web.io/image/li-slide-virtualfilesystem.png</m>\n\nFour main objects in VFS API: superblock, dentries, inodes, files\n- The kernel keeps track of files using in-core inodes ("index nodes"), usually derived by the low-level filesystem from on-disk inodes.\n - A file may have several names, and there is a layer of dentries ("directory entries") that represent pathnames, speeding up the lookup operation.\n - Several processes may have the same file open for reading or writing, and file structures contain the required information such as the current file position.\n - Access to a filesystem starts by mounting it. This operation takes a filesystem type (like ext2, vfat, iso9660, nfs) and a device and produces the in-core superblock that contains the information required for operations on the filesystem; a third ingredient, the mount point, specifies what pathname refers to the root of the filesystem.\n\nAuxiliary objects\n We have filesystem types, used to connect the name of the filesystem to the routines for setting it up (at mount time) or tearing it down (at umount time).\n - A struct vfsmount represents a subtree in the big file hierarchy - basically a pair (device, mountpoint).\n - A struct nameidata represents the result of a lookup.\n - A struct address_space gives the mapping between the blocks in a file and blocks on disk. It is needed for I/O.\n\n<pre class="black">Filesystem type registration</pre>\nThe struct is of type struct file_system_type . Here the 2.2.17 version:\n<c>\nstruct file_system_type {\nconst char *name;\nint fs_flags;\nstruct super_block *(*read_super) (struct super_block *, void *, int);\nstruct file_system_type *next;\n};\n</c>\n\nThe call register_filesystem() hangs this struct in the chain with head file_systems , and unregister_filesystem() removes it again.\nAccesses to this chain are protected by the spinlock file_systems_lock . There are no other writers. The main reader is of course the mount() system call (via get_fs_type() ). Other readers are get_filesystem_list() used for /proc/filesystems , andthe sysfs system call.\nThe code is in fs/filesystems.c .\n\n<c>\nstatic struct file_system_type tue_fs_type = {\n.owner= THIS_MODULE,\n.name= "tue",\n.get_sb= tue_get_sb,\n.kill_sb= kill_block_super,\n.fs_flags= FS_REQUIRES_DEV,\n}\n\nstatic int __init init_tue_fs(void) {\nreturn register_filesystem(&tue_fs_type);\n}\nstatic void __exit exit_tue_fs(void)\n{\nunregister_filesystem(&tue_fs_type);\n}\n</c>\n\n<pre class="black">Struct file_system_type</pre>\n\n<c>\nstruct file_system_type {\nconst char *name;\nint fs_flags;\nstruct super_block *(*get_sb)(struct file_system_type *,\nint, char *, void *, struct vfsmount *);\nvoid (*kill_sb) (struct super_block *);\nstruct module *owner;\nstruct file_system_type *next;\nstruct list_head fs_supers;\nstruct lock_class_key s_lock_key;\nstruct lock_class_key s_umount_key;\n};\n</c>\n\n<cc>\n(In 2.4 there was no kill_sb() , and the role of get_sb() was taken by read_super() . The final parameter of get_sb() and the lock_class_key fields are present since 2.6.18.)\n</cc>\n\n<b>name</b>\nHere the filesystem type gives its name ("tue"), so that the kernel can find it when someone does mount -t tue /dev/foo /dir\n\n<b>get_sb</b>\nAt mount time the kernel calls the fstype->get_sb() routine that initializes things and sets up a superblock. Typically this is a 1-line routine that calls one of get_sb_bdev , get_sb_single , get_sb_nodev , get_sb_pseudo\n\n<b>kill_sb</b>\nAt umount time the kernel calls the fstype->kill_sb() routine to clean up.  Typically one of kill_block_super , kill_anon_super , kill_litter_super .\n\nExample of the use of owner - sysfs\nThere exists a strange SYSV system call sysfs that will return (i) a sequence number given a filesystem type, and (ii) a filesystem type given a sequence number, and (iii) the total number of filesystem types registered now. This call is not supported by libc or glibc.\nThese sequence numbers are rather meaningless since they may change any moment. But this means that one can get a snapshot of the list of filesystem types without looking at /proc/filesystems . For example, the program\n\n<c>\n#include <stdio.h>\n#include <linux/unistd.h>\n/* define the 3-arg version of sysfs() */\nstatic _syscall3(int,sysfs,int,option,unsigned int,fsindex,char *,buf);\n/* define the 1-arg version of sysfs() */\nstatic int sysfs1(int i) {\nreturn sysfs(i,0,NULL);\n}\n\nmain(){\nint i, tot;\nchar buf[100];\n/* how long is a filesystem type name?? */\ntot = sysfs1(3);\nif (tot == -1) {\nperror("sysfs(3)");\n\nexit(1);\nfor (i=0; i<tot; i++) {\nif (sysfs(2, i, buf)) {\nperror("sysfs(2)");\nexit(1);\n}\nprintf("%2d: %s\n", i, buf);\n}\nReturn 0;\n</c>\n\nmight give output like\n<c>\n0:ext2\n1:minix\n2:romfs\n3:msdos\n4:vfat\n5:proc\n6:nfs\n7:smbfs\n8:iso9660\n</c>\n\n<pre class="black">Mounting</pre>\nThe mount system call attaches a filesystem to the big file hierarchy at some indicated point. Ingredients needed:\n(i) a device that carries the filesystem (disk, partition, floppy, CDROM, SmartMedia card, ...), (ii) a directory where the filesystem on that device must be attached, (iii) a filesystem type.\n\nThe code for sys_mount() is found in fs/namespace.c and fs/super.c . The connection with the filesystem type name is made in do_kern_mount() :\n\n<c>\n<b>struct file_system_type *type = get_fs_type(fstype);</b>\nstruct super_block *sb;\nif (!type)\nreturn ERR_PTR(-ENODEV);\nsb = type->get_sb(type, flags, name, data);\n</c>\nand this is the only call of the get_sb() routine.\n\nThe code for sys_umount() is found in fs/namespace.c and fs/super.c . The counterpart of the just quoted code is the cleanup in deactivate_super() :\n<c>\nfs->kill_sb(s);\n</c>\nand this is the only call of the kill_sb() routine.\n\n<pre class="black">The superblock</pre>\nThe superblock gives global information on a filesystem: the device on which it lives, its block size, its type, the dentry of the root of the filesystem, the methods it has, etc., etc.\n<cc>\nstruct super_block {\ndev_t s_dev;\nunsigned long s_blocksize;\nstruct file_system_type *s_type;\nstruct super_operations *s_op;\nstruct dentry *s_root;\n...\n}\nstruct super_operations {\nstruct inode *(*alloc_inode)(struct super_block *sb);\nvoid (*destroy_inode)(struct inode *);\nvoid (*read_inode) (struct inode *);\nvoid (*dirty_inode) (struct inode *);\nvoid (*write_inode) (struct inode *, int);\nvoid (*put_inode) (struct inode *);\nvoid (*drop_inode) (struct inode *);\nvoid (*delete_inode) (struct inode *);\nvoid (*put_super) (struct super_block *);\nvoid (*write_super) (struct super_block *);\nint (*sync_fs)(struct super_block *sb, int wait);\nvoid (*write_super_lockfs) (struct super_block *);\nvoid (*unlockfs) (struct super_block *);\nint (*statfs) (struct super_block *, struct statfs *);\nint (*remount_fs) (struct super_block *, int *, char *);\nvoid (*clear_inode) (struct inode *);\nvoid (*umount_begin) (struct super_block *);\nint (*show_options)(struct seq_file *, struct vfsmount *);\n};\n</cc>\nThis is enough to get started: the dentry of the root directory tells us the inode of this root directory (and in particular its i_ino ), and sb->s_op->read_inode(inode) will read this inode from disk. Now inode->i_op->lookup() allows us to find names in the root directory, etc.\nEach superblock is on six lists, with links through the fields s_list , s_dirty , s_io , s_anon , s_files , s_instances , respectively.\n\n<b>The super_blocks list</b>\nAll superblocks are collected in a list super_blocks with links in the fields s_list . This list is protected by the spinlock sb_lock . The main use is in super.c:get_super() or user_get_super() to find the superblock for a given block device. (Bothroutines are identical, except that one takes a bdev , the other a dev_t .) This list is also used various places where all superblocks must be sync\'ed or all dirty inodes must be written out.\n\n<b.The fs_supers list</b>\nAll superblocks of a given type are collected in a list headed by the fs_supers field of the struct filesystem_type, with links in the fields s_instances . Also this list is protected by the spinlock sb_lock .\n\n<b>The file list</b>\nAll open files belonging to a given superblock are chained in a list headed by the s_files field of the superblock, with links in the fields f_list of the files. These lists are protected by the spinlock files_lock . This list is used for example in fs_may_remount_ro() to check that there are no files currently open for writing.\n\n<b>The list of anonymous dentries</b>\nNormally, all dentries are connected to root. However, when NFS filehandles are used this need not be the case. Dentries that are roots of subtrees potentially unconnected to root are chained in a list headed by the s_anon field\nof the superblock, with links in the fields d_hash . These lists are protected by the spinlock dcache_lock . They are grown in dcache.c:d_alloc_anon() and shrunk in super.c:generic_shutdown_super() .\n\n<b>The inode lists s_dirty, s_io</b>\nLists of inodes to be written out. These lists are headed at the s_dirty (resp. s_io ) field of the superblock, with links in the fields i_list . These lists are protected by the spinlock inode_lock . See fs/fs-writeback.c .\n\n\n<pre class="black">Inodes</pre>\nAn (in-core) inode contains the metadata of a file: its serial number, its protection (mode), its owner, its size, the dates of last access, creation and last modification, etc. It also points to the superblock of the filesystem the file is in, the methods for this file, and the dentries (names) for this file.\n<cc>\nstruct inode {\nunsigned long i_ino;\numode_t i_mode;\nuid_t i_uid;\ngid_t i_gid;\nkdev_t i_rdev;\nloff_t i_size;\nstruct timespec i_atime;\nstruct timespec i_ctime;\nstruct timespec i_mtime;\nstruct super_block *i_sb;\n\nstruct inode_operations *i_op;\nstruct address_space *i_mapping;\nstruct list_head i_dentry;\n...\n}\n\nstruct inode_operations {\nint (*create) (struct inode *, struct dentry *, int);\nstruct dentry * (*lookup) (struct inode *, struct dentry *);\nint (*link) (struct dentry *, struct inode *, struct dentry *);\nint (*unlink) (struct inode *, struct dentry *);\nint (*symlink) (struct inode *, struct dentry *, const char *);};\nint (*mkdir) (struct inode *, struct dentry *, int);\nint (*rmdir) (struct inode *, struct dentry *);\nint (*mknod) (struct inode *, struct dentry *, int, dev_t);\nint (*rename) (struct inode *, struct dentry *, struct inode *, struct dentry *);\nint (*readlink) (struct dentry *, char *,int);\nint (*follow_link) (struct dentry *, struct nameidata *);\nvoid (*truncate) (struct inode *);\nint (*permission) (struct inode *, int);\nint (*setattr) (struct dentry *, struct iattr *);\nint (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);\nint (*setxattr) (struct dentry *, const char *, const void *, size_t, int);\nssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);\nssize_t (*listxattr) (struct dentry *, char *, size_t);\nint (*removexattr) (struct dentry *, const char *);\n</cc>\n\nEach inode is on four lists, with links through the fields i_hash , i_list , i_dentry , i_devices .\n\n<pre class="black">Dentries</pre>\nThe dentries encode the filesystem tree structure, the names of the files. Thus, the main parts of a dentry are the inode (if any) that belongs to it, the name (the final part of the pathname), and the parent (the name of the containing directory). There are also the superblocks, the methods, a list of subdirectories, etc.\n<cc>\nstruct dentry {\nstruct inode *d_inode;\nstruct dentry *d_parent;\nstruct qstr d_name;\nstruct super_block *d_sb;\nstruct dentry_operations *d_op;\nstruct list_head d_subdirs;\n...\n}\nstruct dentry_operations {\nint (*d_revalidate)(struct dentry *, int);\nint (*d_hash) (struct dentry *, struct qstr *);\nint (*d_compare) (struct dentry *, struct qstr *, struct qstr *);\nint (*d_delete)(struct dentry *);\nvoid (*d_release)(struct dentry *);\nvoid (*d_iput)(struct dentry *, struct inode *);\n};\n</cc>\n\n\nEach dentry is on five lists, with links through the fields d_hash , d_lru , d_child , d_subdirs , d_alias .\n\n<pre class="black">Files</pre>\nFile structures represent open files, that is, an inode together with a current (reading/writing) offset. The offset can be set by the lseek() system call. Note that instead of a pointer to the inode we have a pointer to the dentry -that means that the name used to open a file is known. In particular system calls like getcwd() are possible.\n\n<cc>\nstruct file {\nstruct dentry *f_dentry;\nstruct vfsmount *f_vfsmnt;\nstruct file_operations *f_op;\nmode_t f_mode;\nloff_t f_pos;\nstruct fown_struct f_owner;\nunsigned int f_uid, f_gid;\nunsigned long f_version;\n...\n}\n</cc>\nHere the f_owner field gives the owner to use for async I/O signals.\n\n<cc>\nstruct file_operations {\nstruct module *owner;\nloff_t (*llseek) (struct file *, loff_t, int);\nssize_t (*read) (struct file *, char *, size_t, loff_t *);\nssize_t (*aio_read) (struct kiocb *, char *, size_t, loff_t);\nssize_t (*write) (struct file *, const char *, size_t, loff_t *);\nssize_t (*aio_write) (struct kiocb *, const char *, size_t, loff_t);\nint (*readdir) (struct file *, void *, filldir_t);\nunsigned int (*poll) (struct file *, struct poll_table_struct *);\nint (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);\nint (*mmap) (struct file *, struct vm_area_struct *);\nint (*open) (struct inode *, struct file *);\nint (*flush) (struct file *);\nint (*release) (struct inode *, struct file *);\nint (*fsync) (struct file *, struct dentry *, int datasync);\nint (*aio_fsync) (struct kiocb *, int datasync);\nint (*fasync) (int, struct file *, int);\nint (*lock) (struct file *, int, struct file_lock *);\nssize_t (*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);\nssize_t (*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);\nssize_t (*sendfile) (struct file *, loff_t *, size_t, read_actor_t, void *);\nssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\nunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\n</cc>\n\nEach file is in two lists, with links through the fields f_list , f_ep_links .\n\n<b>f_list</b>\nThe list with links through f_list was discussed above. It is the list of all files belonging to a given superblock. There is a second use: the tty driver collects all files that are opened instances of a tty in a list headed by tty->tty_files with links through the file field f_list . Conversely, these files point back at the tty via their field private_data .\n(This field private_data is also used elsewhere. For example, the proc code uses it to attach a struct seq_file to a file.)\n\nThe event poll list\nAll event poll items belonging to a given file are collected in a list with head f_ep_links , protected by the file field\nf_ep_lock . (For event poll stuff, see epoll_ctl(2).)\n\n\n<pre class="black">struct vfsmount</pre>\nA struct vfsmount describes a mount. The definition lives in mount.h :\n\n<cc>\nstruct vfsmount {\nstruct list_head mnt_hash;\nstruct vfsmount *mnt_parent; /* fs we are mounted on */\nstruct dentry *mnt_mountpoint; /* dentry of mountpoint */\nstruct dentry *mnt_root;\n/* root of the mounted tree */\nstruct super_block *mnt_sb;\n/* pointer to superblock */\nstruct list_head mnt_mounts; /* list of children, anchored here */\nstruct list_head mnt_child;\n/* and going through their mnt_child */\natomic_t mnt_count;\nint mnt_flags;\nchar *mnt_devname;\n/* Name of device e.g. /dev/dsk/hda1 */\nstruct list_head mnt_list;\n};\n</cc>\n\n<b>fs_struct</b>\nA struct fs_struct determines the interpretation of pathnames referred to by a process (and also, somewhat illogically, contains the umask). The typical reference is current->fs . The definition\n\nlives in fs_struct.h :\n<cc>\nstruct fs_struct {\natomic_t count;\nrwlock_t lock;\nint umask;\nstruct dentry * root, * pwd, * altroot;\nstruct vfsmount * rootmnt, * pwdmnt, * altrootmnt;\n};\n</cc>\n\nSemantics of root and pwd are clear. Remains to discuss altroot .\n\n<h>\n*Files associated with a process\n</h>\n<m>http://minhinc.42web.io/image/li-slide-filesystemvtable.png</m>\n\nThere are two normal cases for handling the descriptors after a fork.\n1. The parent waits for the child to complete. In this case, the parent does not need to do anything with its descriptors. When the child terminates, any of the shared descriptors that the child read from or wrote to will have their file offsets updated accordingly.\n2. Both the parent and the child go their own ways. Here, after the fork, the parent closes the descriptors that it doesn\'t need, and the child does the same thing. This way, neither interferes with the other\'s open descriptors. This scenario is often found with network servers.\n\nBesides the open files, numerous other properties of the parent are inherited by the child:\n*  Real user ID, real group ID, effective user ID, and effective group ID\n*  Supplementary group IDs\n*  Process group ID\n*  Session ID\n*  Controlling terminal\n*  The set-user-ID and set-group-ID flags\n*  Current working directory\n*  Root directory\n*  File mode creation mask\n*  Signal mask and dispositions\n*  The close-on-exec flag for any open file descriptors\n*  Environment\n*  Attached shared memory segments\n*  Memory mappings\n*  Resource limits\nThe differences between the parent and child are\n* The return values from fork are different.\n* The process IDs are different.\n* The two processes have different parent process IDs: the parent process ID of the\n    child is the parent; the parent process ID of the parent doesn\'t change.\n* The child\'s tms_utime, tms_stime, tms_cutime, and tms_cstime values are set to 0\n* File locks set by the parent are not inherited by the child.\n* Pending alarms are cleared for the child.\n* The set of pending signals for the child is set to the empty set.\n\n<h>\n*proc file system\n</h>\n\n/proc is a window into the running Linux kernel. Files in the /proc file system don\'t corre-spond to actual files on a physical device. Instead, they are magic objects that behave like files but provide access to parameters, data structures, and statistics in the kernel. The "contents" of these files are not always fixed blocks of data, as ordinary file contents are. Instead, they are generated on the fly by the Linux kernel when you read\nfrom the file.You can also change the configuration of the running kernel by writing to certain files in the /proc file system.\nLet\'s look at an example:\n<c>\n    % ls -l /proc/version\n    -r--r--r--      1 root     root            0 Jan 17 18:09 /proc/version\nSize is 0 as this generated by kernel\n</c>\n\n$mount\nnone on /proc type proc (rw)\n\nnone reveals that is not a file systemon disk.\n\nExtracting Information from /proc\n<c>\n#include <stdio.h>\n#include <string.h>\n/* Returns the clock speed of the system\'s CPU in MHz, as reported by\n   /proc/cpuinfo. On a multiprocessor machine, returns the speed of\n   the first CPU. On error returns zero. */\nfloat get_cpu_clock_speed ()\n{\n  FILE* fp;\n  char buffer[1024];\n  size_t bytes_read;\n  char* match;\n  float clock_speed;\n  /* Read the entire contents of /proc/cpuinfo into the buffer. */\n  fp = fopen ("/proc/cpuinfo", "r");\n  bytes_read = fread (buffer, 1, sizeof (buffer), fp);\n  fclose (fp);\n  /* Bail if read failed or if buffer isn\'t big enough. */\n  if (bytes_read == 0 || bytes_read == sizeof (buffer))\n    return 0;\n  /* NUL-terminate the text. */\n  buffer[bytes_read] = \'\\0\';\n  /* Locate the line that starts with "cpu MHz". */\n\n  match = strstr (buffer, "cpu MHz");\n  if (match == NULL)\n    return 0;\n  /* Parse the line to extract the clock speed. */\n  sscanf (match, "cpu MHz : %f", &clock_speed);\n  return clock_speed;\n}\nint main ()\n{\n  printf ("CPU clock speed: %4.0f MHz\n", get_cpu_clock_speed ());\n  return 0;\n}\n</c>\n\nVarious directories and files in /proc\n<cc>\n1)/proc/<number>  # for processes running\n2)/proc/self    #for current process\n3)/proc/cpuinfo\n4)/proc/devices\n5)/proc/pci #summary of devices connected to pci bus\n6)/proc/tty/driver/serail #serial ports\n7)/proc/sys/kernel #kernel information\n8)/proc/meminfo #system\'s memory usage\n9)/proc/filesystem #filesystems mounted in kernel\n10) /proc/mount #all mounted filesytems\n</cc>\n\n<h>\n*System calls\n</h>\n\n<b>1. fcntl Record Locking</b>\n\n<cs>\n#include <fcntl.h>\nint fcntl(int fd, int cmd);\nint fcntl(int fd, int cmd, long arg);\nint fcntl(int fd, int cmd, struct flock *lock);\n    Returns: depends on cmd if OK (see following), -1 on error\n\n<c>For record locking cmd is F_GETLK, </c>\n<c>F_SETLK or F_SETLKW</c>\n\nstruct flock {\n short l_type;  /* F_RDLCK, F_WRLCK, or F_UNLCK */\n short l_whence; /* SEEK_SET, SEEK_CUR, or SEEK_END */\n off_t l_start; /* offset in bytes, relative to l_whence */\n off_t l_len; /* length, in bytes; 0 means lock to EOF */\n pid_t l_pid; /* returned with F_GETLK */\n};\n\n# include <stdio.h>\n# include<fcntl.h>\nMain() {\nint fd, pid, retval;\nstruct flock lockc, lockp;\nfd = open("testlock",O_WRONLY);\nlockp.l_type = F_WRLCK;\nlockp.l_whence = 0;\nlockp.l_start = 10;\nlockp.l_len = 15;\nif((retval = fcntl(fd, F_SETLK,&lockp)) == -1) // Parent is locking the file\n perror("parent write lock\n");\nprintf("retval is %d\n",retval);\nif((pid = fork()) == 0){\n lockc.l_type = F_WRLCK;\n lockc.l_whence = 0;\n lockc.l_start = 40;\n lockc.l_len = 55;\n //Child is locking the file\n if((retval = fcntl(fd, F_SETLK,&lockc)) == -1)perror("Child write lock\n");\n  printf("retval is %d\n",retval);\n  printf("Child Process over\n");\n }\n else {\n  sleep(3);\n  lockp.l_type = F_UNLCK;\n  lockp.l_whence = 0;\n  lockp.l_start = 10;\n  lockp.l_len = 15;\n  // Parent is unlocking the file\n  if((retval = fcntl(fd, F_SETLK,&lockp)) == -1)perror("parent write lock\n");\n    printf("Parent Process over\n");\n }\n}\n\n<c>Both are trying to make READ LOCK,</c>\n<c>Successfull can try at WRITE LOCK</c>\n# include <stdio.h>\n# include<fcntl.h>\n\nmain()\n{\nint fd, pid, retval;\nstruct flock lockc, lockp;\n\nfd = open("testlock",O_RDONLY);\n\nlockp.l_type = F_RDLCK;\nlockp.l_whence = 0;\t//SEEK_SET\nlockp.l_start = 10;\nlockp.l_len = 15;\nif((retval = fcntl(fd, F_SETLK,&lockp)) == -1) // Parent is locking the file\n perror("parent read lock\n");\nprintf("Parent retval is %d\n",retval);\n\n//Child starts here\nif((pid = fork()) == 0){\n if((retval = fcntl(fd, F_GETLK,&lockc)) == -1)\n  perror("child write lock\n");\n\nprintf("retval is %d\n",retval);\nprintf("process %d has locked this section\n",lockc.l_pid);\nprintf("lock type   %d\n",lockc.l_type);\nprintf("whence \t\t%d\n",lockc.l_whence);\nprintf("start \t\t%d\n",lockc.l_start);\nprintf("lenth is \t%d\n",lockc.l_len);\n\nlockc.l_type = F_RDLCK;\nlockc.l_whence = 0;\nlockc.l_start = 10;\nlockc.l_len = 15;\n//Child is locking the file\nif((retval = fcntl(fd, F_SETLK,&lockc)) == -1)\n perror("Child read lock\n");\n\n printf("Child retval is %d\n",retval);\n printf("Child Process over\n");\n}\nelse {\nsleep(3);\nprintf("Parent Process over\n");\n}\n}\n</cs>\n\n<b>2. lockf</b>\n\nSYNOPSIS\n<c>\n#include <unistd.h>\nint lockf(int fd, int cmd, off_t len);\n</c>\n- apply, test or remove a POSIX lock on an open file\n\nDEADLOCK,  avoid deadlock with F_TLOCK in child lockf() call\n\n<c>\n# include <fcntl.h>\n# include <unistd.h>\nmain()\n{\nint fd, retvelue;\npid_t pid;\n\nchar   buff[100];\n\nif((fd = open("locktest",O_RDWR|O_CREAT, 0666)) == -1)\n perror("open file locktest\n");\n\nif(lockf(fd,F_LOCK,10) == -1)\n perror("lockf failed");\n\nif((pid = fork()) == 0){\n if(lockf(fd,F_LOCK,10) == -1)\t//child blocked dead lock....!\n  perror("lockf failed");\n  puts("The child process over");\n }\n else{\n  wait(0);\n  printf("Process %d is over\n",getpid());\n}\n}\n</c>\n\n<b>3. access</b>\n<c>\n#include <unistd.h>\nint access(const char *pathname, int mode);\n</c>\n\naccess() checks whether the process would be allowed to read, write or test for existence of the file (or other file system object) whose name is pathname.  If pathname  is  a  symbolic link permissions of the file referred to by this symbolic link are tested.\nmode is a mask consisting of one or more of R_OK, W_OK, X_OK and F_OK.\nR_OK, W_OK and X_OK request checking whether the file exists and has read, write and execute permissions, respectively.  F_OK just requests checking for the existence of the file.\n<c>\n#include<errno.h>\n#include<stdio.h>\n#include<unistd.h>\nint main(int argc, char* argv[]) {\nchar* path = argv[1];\nint ret;\nret = access(path,F_OK); // check for file exists\nif(ret == 0)\nprintf(" %s file exists\n",path);\n}\n</c>\n\n<b>4. create</b>\n<c>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint open(const char *pathname, int flags);\nint open(const char *pathname, int flags, mode_t mode);\nint creat(const char *pathname, mode_t mode);\n</c>\n\n\n<b>5. dup, dup2</b>\n<c>\n#include <unistd.h>\n\nint dup(int oldfd);\nint dup2(int oldfd, int newfd);\n</c>\n\ndup() and dup2() create a copy of the file descriptor oldfd.\n\nAfter a successful return from dup() or dup2(), the old and new file descriptors may be used interchangeably. They refer to the same open file descriptor thus share file offset and file status flags; for example, if the file offset is modified by using\nlseek(2) on one of the descriptors, the offset is also changed for the other.\n\nThe two descriptors do not share file descriptor flags (the close-on-exec flag).  The close- on-exec flag (FD_CLOEXEC;\n\ndup() uses the lowest-numbered unused descriptor for the new descriptor.\n\ndup2() makes newfd be the copy of oldfd, closing newfd first if necessary.\n\n<c>\n# include <stdio.h>\n# include <stdlib.h>\n# include <fcntl.h>\n# include <sys/stat.h>\nmain(){\nint fd, newfd;\nif((fd = creat("testfile",0666)) == -1){\n perror("Creat failed\n");\n exit(0);\n}\nprintf("Descriptor is %d",fd);\nnewfd= dup2(fd,5);//try with stdout\nprintf("\nNew Descriptor is %d\n",newfd);\nprintf("The PID is %d\n",getpid());\nfor(;;);\nclose(fd);\nclose(newfd);\n}\n\nUsing fcntl to create a copy\n# include <stdio.h>\n# include <fcntl.h>\nmain()\n{\nint fd,fd1, newfd;\nfd = open("temp",O_RDWR | O_CREAT ,0666);\nprintf("The file discriptor is %d\n",fd);\n\nfd1 = open("temp1",O_RDWR | O_CREAT ,0666);\nnewfd=fcntl(fd,F_DUPFD,NULL);\nprintf("The file discriptor is %d\n",newfd);\n\t\t\t\t\n}\n</c>\n\n<b>6. mmap</b>\n<c>\n#include <sys/mman.h>\n\nvoid *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nint munmap(void *start, size_t length);\n</c>\n\nThe mmap() function asks to map length bytes starting at offset offset from the file (or  other object) specified by the file descriptor fd into memory, preferably at address start.\nThis latter address is a hint only, and is usually specified as 0. The actual place where the object is mapped is returned by mmap().\n\nThe prot argument describes the desired memory protection (and must not conflict with the open mode of the file).It is either PROT_NONE or is the bitwise OR of one or more of the  other PROT_* flags.\n<c>\nPROT_EXEC  Pages may be executed.\nPROT_READ  Pages may be read.\nPROT_WRITE Pages may be written.\nPROT_NONE  Pages may not be accessed.\n</c>\n\nThe flags parameter specifies the type of the mapped object,  mapping  options  and  whether modifications  made  to  the mapped copy of the page are private to the process or are to be shared with other references.  It has bits\n\n<c>MAP_FIXED</c> Do not select a different address than the one specified. If the memory region specified by start.\n<c>MAP_SHARED</c> Share this mapping with all other processes that map this object. Storing to the region is equivalent to writing to the file.\n<c>MAP_PRIVATE</c> Create a private copy-on-write mapping. Stores to the region do not affect the original file. It is unspecified whether changes made to the file after the mmap() call are visible in the mapped region.\n\n<m>http://minhinc.42web.io/image/li-slide-memorymap.png</m>\n\n<cs>\n#include<unistd.h>\n#include<stdlib.h>\n#include<sys/mman.h>\n#include<sys/types.h>\n#include<sys/stat.h>\n#include<fcntl.h>\n#include<stdio.h>\n#include<syscall.h>\n\nmain(int argc,char *argv[])\n{\nint fd;\nvoid *addr;\n\nif( (fd=open(argv[1],O_RDWR|O_CREAT,0777)) < 0) {\n perror("open");\n exit(1);\n}\n\nlseek(fd,5,SEEK_SET);\nwrite(fd,"",1);\n//lseek(fd,0,SEEK_SET);\naddr=mmap(0,5,PROT_WRITE,MAP_SHARED,fd,0); /* Mapping the file to memory*/\nclose(fd);\nsprintf(addr,"%s\n","hello");\nmunmap(addr,5);\n}\n//#define BCM2708_PERI_BASE  0x20000000\n#define BCM2708_PERI_BASE    0x3F000000\n#define GPIO_BASE  (BCM2708_PERI_BASE + 0x200000) /* GPIO controller */\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <unistd.h>\n\n#define PAGE_SIZE (4*1024)\n#define BLOCK_SIZE (4*1024)\n\nint  mem_fd;\nvoid *gpio_map;\n\n// I/O access\nvolatile unsigned *gpio;\n\n\n// GPIO setup macros. Always use INP_GPIO(x) before using OUT_GPIO(x) or SET_GPIO_ALT(x,y)\n#define INP_GPIO(g) *(gpio+((g)/10)) &= ~(7<<(((g)%10)*3))\n#define OUT_GPIO(g) *(gpio+((g)/10)) |=  (1<<(((g)%10)*3))\n#define SET_GPIO_ALT(g,a) *(gpio+(((g)/10))) |= (((a)<=3?(a)+4:(a)==4?3:2)<<(((g)%10)*3))\n\n//#define GPIO_SET *(gpio+7)  // sets   bits which are 1 ignores bits which are 0\n//#define GPIO_CLR *(gpio+10) // clears bits which are 1 ignores bits which are 0\n//temporarily introduced for pint 4\n#define GPIO_SET *(volatile unsigned int*)(gpio+7) |= 0x10  // sets   bits which are 1 ignores bits which are 0\n#define GPIO_CLR *(volatile unsigned int*)(gpio+10)|= 0x10 // clears bits which are 1 ignores bits which are 0\n#define GPIO_READ(g) *(gpio + 13) &= (1<<(g))\n\nvoid setup_io();\n\nint main(int argc, char **argv)\n{\nint g,rep;\n\n// Set up gpi pointer for direct register access\nsetup_io();\n// set GPIO pin 7 as output\n//    INP_GPIO(7); // must use INP_GPIO before we can use OUT_GPIO\n    INP_GPIO(4); // must use INP_GPIO before we can use OUT_GPIO\n//    OUT_GPIO(7);\n    OUT_GPIO(4);\n\n// flash LED on and off 10 times\n for (rep = 0; rep < 10; rep++) {\n//        GPIO_SET = (1 << 7);\n        printf("setting\n");\n        GPIO_SET;\n        sleep(1);\n//        GPIO_CLR = (1 << 7);\n\n        printf("resetting\n");\n        GPIO_CLR;\n        sleep(1);\n }\n  return 0;\n} // main\n// Set up a memory regions to access GPIO\nvoid setup_io()\n{\n/* open /dev/mem */\nif ((mem_fd = open("/dev/mem", O_RDWR|O_SYNC) ) < 0) {\n printf("can\'t open /dev/mem\n");\n exit(-1);\n}\n/* mmap GPIO */\ngpio_map = mmap(\n NULL,                 //Any adddress in our space will do\n BLOCK_SIZE,           //Map length\n PROT_READ|PROT_WRITE, // Enable reading & writting to mapped memory\n MAP_SHARED,           //Shared with other processes\n mem_fd,               //File to map\n GPIO_BASE             //Offset to GPIO peripheral\n );\n close(mem_fd); //No need to keep mem_fd open after mmap\n if (gpio_map == MAP_FAILED) {\n  printf("mmap error %d\n", (int)gpio_map); //errno also set!\n  exit(-1);\n }\n // Always use volatile pointer!\n gpio = (volatile unsigned *)gpio_map;\n} // setup_io()\n</cs>\n\n<m>http://minhinc.42web.io/image/li-slide-raspberrypigpio.png</m>\n\n<m>http://minhinc.42web.io/image/li-slide-raspberrypigpio2.png</m>\n\n\n<b>7. mount</b>\n<c>\nmount [-lhV]\n\nmount -a [-fFnrsvw] [-t vfstype] [-O optlist]\nmount [-fnrsvw] [-o options [,...]] device | dir\nmount [-fnrsvw] [-t vfstype] [-o options] device dir\n</c>\n\nMount a file system\n\nAll files accessible in a Unix system are arranged in one big tree, the file hierarchy, rooted at /. These files can be spread out over several devices. The mount command serves to attach the file system found on some device to the big file tree. Conversely, the umount(8) command will detach it again.\n\nThe standard form of the mount command, is mount -t type device dir\n<c>\n#include<sys/mount.h>\n#include<stdio.h>\nmain(){\nint fd;\nfd = mount("/dev/fd0","/mnt/floppy","ext2",MS_NOSUID,NULL);\nif(fd != -1)\nprintf(" Floppy mounted successfully\n");\nprintf(" Changing Directory to floppy\n");\nchdir("/mnt/floppy");\nprintf(" Creating a file test_file in floppy\n");\nfd = creat("test_file",0644);\nif (fd != -1)\nprintf(" File Creation successful\n");\n}\n</c>\n\n<b>8. readv, writev</b>\n<c>\n#include <sys/uio.h>\n\nssize_t readv(int fd, const struct iovec *vector, int count);\nssize_t writev(int fd, const struct iovec *vector, int count);\nreadv, writev - read or write data into multiple buffers\n</c>\n\nThe readv() function reads count blocks from the file associated with the file descriptor fd into the multiple buffers described by vector.\n\nThe writev() function writes at most count blocks described by vector to the file associated with the file descriptor fd.\n\nThe pointer vector points to a struct iovec defined in <sys/uio.h> as\n\n<c>\nstruct iovec {\n void *iov_base;   /* Starting address */\n size_t iov_len;   /* Number of bytes */\n};\n\n# include<stdio.h>\n# include <fcntl.h>\n# include <sys/uio.h>\n\nstruct emp{\nchar name[25];\nint age;\nfloat  sal;\n}obj[2], Emp [2]={{"Hello",10,123.345},{"World",20,234.567}};\n\nmain()\n{\nstruct iovec  readiovobj,ioobj;\nint fd;\nint retval;\nioobj.iov_base = Emp;\nioobj.iov_len =sizeof(Emp);\n\nprintf("%d",ioobj.iov_len );\n\nfd = open("temp",O_CREAT|O_RDWR,0666);\nretval=writev(fd,&ioobj,1);\nprintf("%d",retval);\n\nlseek(fd,0,SEEK_SET);\nreadiovobj.iov_base = obj;\nreadiovobj.iov_len =sizeof(Emp);\nretval=readv(fd,&readiovobj,1);\nprintf("%d",retval);\n}\n</c>\n\n<b>9. pread, pwrite </b>\n<c>\n#define _XOPEN_SOURCE 500\n\n#include <unistd.h>\n\nssize_t pread(int fd, void *buf, size_t count, off_t offset);\n\nssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);\n pread, pwrite - read from or write to a file descriptor at a given offset\n</c>\n\npread() reads up to count bytes from file descriptor fd at offset offset (from the start of the file) into the buffer starting at buf. The file offset is not changed.\npwrite() writes up to count bytes from the buffer starting at buf to the file descriptor  fd at offset offset.  The file offset is not changed.\nThe file referenced by fd must be capable of seeking.\n\n<c>\n#include<stdio.h>\n#include<sys/stat.h>\n#include<sys/types.h>\n#include<fcntl.h>\n#include<unistd.h>\n\nmain()\n{\nint fd1, fd2,n;\nchar ch[1024];\nif((fd1 = open("/etc/passwd",O_RDONLY)) == -1)\n perror("Un able to open source");\n\nn = pread(fd1,ch,100,100);\nprintf(ch);\nclose(fd1);\n\nif((fd2 = open("newfile",O_WRONLY,0666)) == -1){\n perror("Un able to open target");\n exit(1);\n}\npwrite(fd2,"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",40,500);\n pwrite(fd2,"YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY",40,500);\n\nclose(fd2);\n}\n</c>'
'7!ABS SBA!Process Management!ABS SBA!\'*Create a child process and validates if all\\nopen descriptors are copied to child process also.\\n - Use file seek from parent and see child\'s\\n  descriptor also got seeked.!ABS SBA!<h>\n*Process Defined\n</h>\n\n- A Process is a file in file system.\n- A Process is  object code in execution-active, alive, running programs\n- Processes are more than just assembly language; they consist of data, resources, state,\nand a virtualized computer.\n- A process uses many resources like memory space, CPU, files, etc., during its lifetime.\n- A Process contains threads, contained in a process group and has parent Process.\n  A process group contained in Session. Session has tty, terminal attached to it where at most one process group (Foreground process group) attached to the terminal.\n Rest detached process groups are background process group.\n\n - A Process is sub program that is scheduled, by kernel, to the process for execution.\n Main thread in a process is actual entity that get scheduled to the CPU. Kernel maintains separate copy of registers and various other data structure for a process.\n - In multi processing environment register values in context of process gets loaded to actual register when execution resumes.\n\n - A process is an entry in task vector, and is an instance of task_struct.\n\n<m>http://minhinc.42web.io/image/li-slide-processaddressspace.png</m>\n\n<h>\n*Process Descriptor Structures in the kernel\n</h>\n\nProcess Structure\n* Every process is represented by a task_struct data structure.\n* This structure is quite large and complex.\n* When ever a new process is created a new task_struct structure is created by the kernel and the complete process information is maintained by the structure.\n* When a process is terminated, the corresponding structure is removed.\n* Uses doubly linked list data structure.\n* Solaris uses proc structure to manage processes.\n\n<cc>\ntask_struct task[256];\n\nstruct task_struct {\nvolatile long state;    /* -1 unrunnable, 0 runnable, >0 stopped */\nvoid *stack;\natomic_t usage;\nunsigned int flags;     /* per process flags, defined below */\nunsigned int ptrace;\n\n#ifdef CONFIG_SMP\nstruct llist_node wake_entry;\nint on_cpu;\nstruct task_struct *last_wakee;\nunsigned long wakee_flips;\nunsigned long wakee_flip_decay_ts;\n\nint wake_cpu;\n#endif\nint on_rq;\n\nint prio, static_prio, normal_prio;\nunsigned int rt_priority;\nconst struct sched_class *sched_class;\nstruct sched_entity se;\nstruct sched_rt_entity rt;\n\n#ifdef CONFIG_CGROUP_SCHED\nstruct task_group *sched_task_group;\n#endif\n\n#ifdef CONFIG_PREEMPT_NOTIFIERS\n/* list of struct preempt_notifier: */\nstruct hlist_head preempt_notifiers;\n#endif\n/*\n* fpu_counter contains the number of consecutive context switches\n* that the FPU is used. If this is over a threshold, the lazy fpu\n* saving becomes unlazy to save the trap. This is an unsigned char\n* so that after 256 times the counter wraps and the behavior turns\n* lazy again; this to deal with bursty apps that only use FPU for\n* a short time\n*/\nunsigned char fpu_counter;\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n unsigned int btrace_seq;\n#endif\nunsigned int policy;\nint nr_cpus_allowed;\ncpumask_t cpus_allowed;\n\n#ifdef CONFIG_PREEMPT_RCU\n int rcu_read_lock_nesting;\n char rcu_read_unlock_special;\n struct list_head rcu_node_entry;\n#endif /* #ifdef CONFIG_PREEMPT_RCU */\n#ifdef CONFIG_TREE_PREEMPT_RCU\n struct rcu_node *rcu_blocked_node;\n#endif /* #ifdef CONFIG_TREE_PREEMPT_RCU */\n#ifdef CONFIG_RCU_BOOST\n struct rt_mutex *rcu_boost_mutex;\n#endif /* #ifdef CONFIG_RCU_BOOST */\n\n#if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)\n struct sched_info sched_info;\n#endif\n\n        struct list_head tasks;\n#ifdef CONFIG_SMP\n struct plist_node pushable_tasks;\n#endif\n\n struct mm_struct *mm, *active_mm;\n#ifdef CONFIG_COMPAT_BRK\n unsigned brk_randomized:1;\n#endif\n#if defined(SPLIT_RSS_COUNTING)\n struct task_rss_stat    rss_stat;\n#endif\n/* task state */\nint exit_state;\nint exit_code, exit_signal;\nint pdeath_signal;  /*  The signal sent when the parent dies  */\nunsigned int jobctl;    /* JOBCTL_*, siglock protected */\n..\n..\n</cc>\n\nIn order to run unix, the computer hardware must provide two modes of execution:\n- kernel mode\n- user mode\n\nSome computers have more than two execution modes.\n- eg: Intel processor. It has four modes of execution.\n\nEach process has virtual address space; references to virtual memory are translated to physical memory locations using set of address translation maps.\n\n<h>\n*Process States\n</h>\n\nProcess States\n\n<m>http://minhinc.42web.io/image/li-slide-processstate.png</m>\n\n<h>\n*Process Scheduling\n</h>\n\nScheduling (Kernel perspective)\n* The kernel keeps track of a processes creation time as well as the CPU time that it consumes during its lifetime.\n* This clock is the combination of software and hardware setup.\n* It is independent of CPU frequency.\n* A clock tick unit is Jiffy. System\'s interactive response depends on the clock frequency.\n- For example: the jiffy value may be 10ms (100Hz) or 1ms (1000Hz) depending on implementation\n\nEach clock tick, the kernel updates the amount of time that the current process has spent in system and in user mode.\n* Linux also supports process specific interval timers, processes can use system calls to set up timers to send signals to themselves when the timers expire. These timers can be single-shot or periodic timers.\n\nProcess Scheduling\n* The job of a scheduler is to select the most deserving process to run out of all of the runnable processes in the run queue.\n* Implement fair scheduling to avoid starvation\n* Implement suitable scheduling policy\n* Updates state of the processes in every clock tick (jiffy)\n\nPolicy - FIFO, Round Robin, Shortest Job First,\nFILO, Priority based etc.\n* Priority - higher priority process will be allowed to run.\n* Pre-emptive and Non-preemptive scheduling.\n* rt_priority - many UNIX variants support real time scheduling priority range.\n\nPriority Range\nScheduling priorities (in a typical UNIX system)\nhave integer values\nbetween 0 and 127, with smaller numbers\nmeaning higher priorities.\n* For Solaris: 0 to 169\n* For Linux: 0 to 139\n\nProcess Scheduling: Linux\n* The Linux kernel implements two separate priority ranges.\n* The first is the nice value, a number from -20 to 19 with a default of zero. Larger nice values correspond to a lower priority.\n* A process with a nice value of -20 receives the maximum time slice, whereas a process with a nice value of 19 receives the minimum time slice.\n* Time slice: minimum -10ms, default -150ms and maximum\n- 300ms\n\n* The second range is the real-time priority\n* By default, it ranges from zero to 99.\n* All real time processes are at a higher priority than normal processes.\n* Linux implements real-time priorities in accordance with POSIX.\n\n* Linux provides two real-time scheduling policies, <c>SCHED_FIFO</c> and <c>SCHED_RR</c>\n* The normal non real-time scheduling policy is <c>SCHED_OTHER</c>\n* <c>SCHED_FIFO</c> implements without time slices- so it can run until it blocks or explicitly yields the processor.\n* <c>SCHED_RR</c> is identical to <c>SCHED_FIFO</c> except that each process can only run until it exhausts a predetermined time Slice.\n\nScheduler System Calls\n<cc>\n nice() Set a process\'s nice value\n sched_setscheduler() Set a process\'s scheduling policy\n sched_getscheduler() Get a process\'s scheduling policy\n sched_setparam() Set a process\'s real-time priority\n sched_getparam() Get a process\'s real-time priority\n sched_get_priority_max() Get the maximum real-time priority\n sched_get_priority_min() Get the minimum real-time priority\n sched_rr_get_interval() Get a process\'s timeslice value\n</cc>\n\n<h>\n*Process Creation\n</h>\n\n<m>http://minhinc.42web.io/image/li-slide-unixprocess.png</m>\n\nProcess Creation\nParent process creates children processes, which, in turn create other\n   processes, forming a tree of processes.\nResource sharing\n   Parent and children share all resources.\n   Children share subset of parent\'s resources.\n   Parent and child share no resources.\nExecution\n   Parent and children execute concurrently.\n   Parent waits until children terminate.\nAddress space\n   Child duplicate of parent.\n   Child has a program loaded into it.\n\nfork()\n* pid_t fork (void); creates a new process.\n* All statements after the fork() system call in a program are executed by two processes - the original process that used fork(), plus the new process that is created by fork( ).\n<c>\nmain ( ) {\nprintf (" Hello fork %d\n, fork ( ) ");\n}\n- Hello fork: 0\n- Hello fork: x ( > 0);\n- Hello fork: -1\n</c>\n\n\nParent and Child\n<c>\nif (!fork( )) {\n/* Child Code */\n}\nelse {\n/* parent code */\nwait (0); /* or */\nwaitpid(pid, ....);\n}\n</c>\n\nZombie State and Orphan Process\n* When a child process exits, it has to give the exit status to the parent process.\n* If the parent process is busy or suspended then the child process will not be able to terminate.\n* Such state is called Zombie.\n* If parent exits before child, the child will become an orphan process and the init process (grand parent) will take care of the child process.\n\n\nCopy on Write (COW)\n* Instead of copying the address space of the parent, UNIX uses the COW technique for economical use of the memory page.\n* The parent space is not copied, it can be shared by both the parent and the child process but the memory pages are marked as write protected.\n* If parent or child wants to modify the pages, then kernel copies the parent pages to the child process.\n* Advantage: Kernel can defer or prevent copying of a parent process address space.\n\nexecl\nTo run a new program in a process, you use one of\nthe "exec" family of\ncalls (such as "execl") and specify following:\n* the pathname of the program to run\n* the name of the program\n* each parameter to the program\n* (char *)0 or NULL as the last parameter to specify end of parameter list\n\nexec Family\n<c>\nint execl (const char *path, const char *arg, .....);\nint execlp (const char *file, const char *arg);\nint execle (const char *path, const char *arg, ......., char *const envp[ ]);\nint execv (const char *path, char *const argv[ ]);\nint execvp (const char *file, char *const argv[ ]);\n  All the above library functions call internally execve system call.\nint execve (const char *filename, char *const argv [ ] , char *const evnp [ ]);\n</c>\n\n<m>http://minhinc.42web.io/image/li-slide-executableimage.png</m>\n\nText Portion\n* User Context consists portions accessible to the process while running in user mode.\n* The text portion of a process contains the actual machine instructions that are executed by the hardware.\n* When a program is executed by the OS, the text portion is read into memory from its disk file, unless the OS supports shared text and a copy of program is already being executed.\nData Portion\n* The data portion contains the program\'s data. It is possible for this to be divided into 3 pieces.\n* Initialized read only data contains elements that are initialized by the program and are read only while the process is executing.\n* Initialized read write data contains data elements that are initialized by the program and may have their values modified during execution of the process.\n\nStack Portion\n* Un-initialized data contains data elements that are not initialized by the program but are set to zero before execution starts .\n* The heap is used while a process is running to allocate more data space dynamically to the process.\n* The stack is used dynamically while the process is running to contain the stack frames that are used by many programming languages.\n\nKernel Context\n* The stack frames contain the return address linkage for each function call and also the data elements required by a function.\n* A gap is shown between heap and stack to indicate that many OS leave some room between these 2 portions, so\nthat both can grow dynamically.\n* The kernel context of a process is maintained and accessible only to the kernel. This area contains info that the kernel needs to keep track of the process and to stop and restart the process while other processes are allowed to execute.\n\nDaemon Process\nIntroduction\n* Daemon process starts during system startup.\n* They frequently spawn other process to handle services requests.\n- Mostly started by initialization script /etc/rc\n* Waits for an event to occur.\n* perform some specified task on periodic basis (cron job)\n* perform the requested service and wait\n- Example print server\n\nCharacteristics\n* executed at the background process\n* Orphan process\n* No controlling terminal\n* run with super user privileges\n* process group leaders\n* session leaders\n\nHow to daemonize\n1. Call umask to set the file mode creation mask to a known value, usually 0.\n2. Call fork and have the parent exit. Child inherits the process group ID of the parent but gets a new process ID, so we\'re guaranteed  that the child is not a process group leader. This is a prerequisite for the call to  setsid that is done next.\n3. Call setsid to create a new session. The three steps listed in Section 9.5 occur.  The process (a) becomes the leader of a new session, (b) becomes the leader of a new process group, and (c) is disassociated from its controlling terminal.\n4. Change the current working directory to the root directory. The current working directory inherited from the parent could be on a mounted file system.\n5. Unneeded file descriptors should be closed. This prevents the daemon from holding open any descriptors that it may have inherited from its parent (which could be a shell or some other process).\n6. Some daemons open file descriptors 0, 1, and 2 to /dev/null so that any library routines that try to read from standard input or write to standard output or standard error will have no effect.\n\n$ ps -axj   #to get all daemon process, does not have terminal\n\n<cc>\n#include  "apue.h"\n#include  <syslog.h>\n#include  <fcntl.h>\n#include  <sys/resource.h>\nvoid\ndaemonize(const char *cmd)\n{\nint                 i, fd0, fd1, fd2;\npid_t               pid;\nstruct rlimit       rl;\nstruct sigaction    sa;\n/*\n* Clear file creation mask.\n*/\numask(0);\n/*\n* Get maximum number of file descriptors.\n*/\nif (getrlimit(RLIMIT_NOFILE, &rl) < 0)\n err_quit("%s: can\'t get file limit", cmd);\n/*\n* Become a session leader to lose controlling TTY.\n*/\nif ((pid = fork()) < 0)\n err_quit("%s: can\'t fork", cmd);\nelse if (pid != 0) /* parent */\n exit(0);\nsetsid();\n/*\n* Ensure future opens won\'t allocate controlling TTYs.\n*/\n sa.sa_handler = SIG_IGN;\n sigemptyset(&sa.sa_mask);\n  sa.sa_flags = 0;\n  if (sigaction(SIGHUP, &sa, NULL) < 0)\n       err_quit("%s: can\'t ignore SIGHUP", cmd);\n  if ((pid = fork()) < 0)\n       err_quit("%s: can\'t fork", cmd);\n  else if (pid != 0) /* parent */\n       exit(0);\n  /*\n    * Change the current working directory to the root so\n    * we won\'t prevent file systems from being unmounted.\n    */\n  if (chdir("/") < 0)\n       err_quit("%s: can\'t change directory to /", cmd);\n  /*\n    * Close all open file descriptors.\n    */\n  if (rl.rlim_max == RLIM_INFINITY)\n       rl.rlim_max = 1024;\n  for (i = 0; i < rl.rlim_max; i++)\n       close(i);\n  /*\n    * Attach file descriptors 0, 1, and 2 to /dev/null.\n    */\n  fd0 = open("/dev/null", O_RDWR);\n  fd1 = dup(0);\n  fd2 = dup(0);\n  /*\n    * Initialize the log file.\n    */\n  openlog(cmd, LOG_CONS, LOG_DAEMON);\n  if (fd0 != 0 || fd1 != 1 || fd2 != 2) {\n       syslog(LOG_ERR, "unexpected file descriptors %d %d %d",\n         fd0, fd1, fd2);\n       exit(1);\n  }\n}\n</cc>\n\n<h>\n*System calls related to process management\n</h>\n\n<b>1. wait, waitpid</b>\n<c>\n#include <sys/types.h>\n#include <sys/wait.h>\n\npid_t wait(int *status);\npid_t waitpid(pid_t pid, int *status, int options);\nint waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);\n    wait, waitpid - wait for process to change state\n</c>\nA state change is considered  to be: the child terminated; the child was stopped by a signal; or the child was resumed by a1. wait, waitpid signal.  In the case of a terminated child, performing a wait allows the system to  release the resources associated with the child; if a wait is not performed, then termi nated the child remains in a "zombie" state.\n\nIf a child has already changed state, then these calls return immediately. Otherwise they block until either a child changes state or a signal handler interrupts the call (assuming that system calls are not automatically restarted using the <c>SA_RESTART</c> flag of sigaction(2)).\n\n<c>\nwaitpid(-1, &status, 0);\n</c>\n\nThe value of pid can be:\n< -1 meaning wait for any child process whose process group ID is equal to the absolute value of pid.\n-1 meaning wait for any child process.\n0 meaning wait for any child process whose process group ID is equal to that of the calling process.\n> 0 meaning wait for the child whose process ID is equal to the value of pid.\n\n<c>\n#include <stdio.h>\nint main ()\t{\nint i=0,pid;\nprintf ("Ready to fork\n");\npid = fork();\nif (pid == 0)\n{\nprintf ("Child starts\n");\nfor(i=0;i<1000;i++) printf ("%d\\t",i);\nprintf ("Child ends\n");\nsleep(30);  uncomment this to get child orphaned process\n}else {\nWait(0); //comment and sleep to get child as zombie process\nprintf ("Parent process\n");\n}\n}\n</c>\n\n<b>2. exec</b>\n<c>\n#include <unistd.h>\n\nextern char **environ;\n\nint execl(const char *path, const char *arg, ...);\nint execlp(const char *file, const char *arg, ...);\nint execle(const char *path, const char *arg,\n                  ..., char * const envp[]);\nint execv(const char *path, char *const argv[]);\nint execvp(const char *file, char *const argv[]);\n       execl, execlp, execle, execv, execvp - execute a file\n</c>\nexecl\n<c>\n#include <stdio.h>\nint main ()\n{\nint pid;\npid = fork();\nif (pid == 0)\n{\n printf ("Exec starts\n");\n execl("/bin/ls","ls","-l",(char *)0);\n printf ("Execl did not work\n");\n}\nelse\n{\n wait(0);\n printf ("Parent:Is completed in child\n");\n }\n}\n</c>\nexecv\n<c>\n#include <stdio.h>\nint main ()\n{\nchar *temp[4];\ntemp[0] = "ls";\ntemp[1] = "-l";\ntemp[2] = (char *)0;\nexecv("/bin/ls",temp);\nprintf ("This will not print\n");\n}\n</c>'
'8!ABS SBA!Memory Management!ABS SBA!!ABS SBA!<h>\n*Defining and Creating secondary memory\nareas\n</h>\n\nFactors to be considered while designing secondary memory\n\nLatency, Throughput and Bandwidth\nLatency - : Amount of time for a single operation to execute.\nThroughput - Rate at which operations get executed.\n              Normally expressed as Operations/second.\n              In sequential processing throughput = 1 /latency\nBandwidth - : Total rate at which data moves between processor and memory.\n              Product of throughput and datawidth\n\nPipelining, Parallelism and Pre-charging\nMemory systems can be pipelined similar to the processors are pipelined, allowing operations to overlap execution to improve throughput.\nMany memory technologies require a certain delay (idle time ) between operations to pre-charge circuitry for the next access.\nAttaching multiple memories to the processor\'s memory bus allows parallelism. This increases the rate at which memory is accessed without increasing the pin count of the processor.\n\nTwo kinds of systems that support parallelism - Replicated & Banked.\nReplicated provides multiple copies of entire memory. Store needs to write into all copies( more expensive than loads ).\nBanked memory - Data is divided or interleaved across memories.\n\n<m>http://minhinc.42web.io/image/li-slide-processormemory.png</m>\n\nExample:\nWhat is the bandwidth of a memory system with a latency of 40 ns that transfers 1 byte per operation and is pipelined to allow 4 operations to overlap execution (\nassume no pipelining overhead ) ?\n\nDividing latency 40 ns by number of overlapped operations ( 4 ) gives a rate of 1 operation per 10 ns as the throughput of the memory system. At 1 byte of data per operation, this gives a bandwidth of 100 Mbyte/sec.\n\n<m>http://minhinc.42web.io/image/li-slide-memoryhierarchy.png</m>\n\n<m>http://minhinc.42web.io/image/li-slide-memoryhierarchy1.png</m>\n\nLevels in the Memory Hierarchy\nCache :\n1. Generally implemented using SRAM.\n2. Use hardware to keep track of addresses stored in them.\n3. Tend to be small ( capacity ).\n4. Small Block Sizes ( 32 to 128 bytes ).\n\nMain Memory:\n1. Generally implemented using DRAM.\n2. Use software to keep track of addresses.\n3. Larger capacity ( Few MB to several Gigabytes ).\n4. Larger Block Sizes ( several kilobytes ).\n\nVirtual Memory:\n1. Implemented using disks.\n2. Contains all of the data in the memory system.\n\nSome terminology...\nHit : When an address is found at a given hierarchy.\nMiss: When an address is NOT found at a given hierarchy.\nHit Rate: % of references that reach a given level & result in hits.\nMiss Rate: % of references that reach a given level & result in misses.\nNote: Hit Rate + Miss Rate = 100% ALWAYS.\n\nWhen a miss occurs, a BLOCK of data is brought in from a lower level into the current level of the hierarchy. As time progresses, the current level may fill up, and run out of free space. A block must be removed to accommodate the new block. This is called eviction or replacement. The method to decide on what block to remove is called replacement policy.\nTo simplify evicting data blocks, many memory systems maintain a property called inclusion. The presence of an address at a given level of a memory hierarchy GUARANTEES that the address is present in ALL LOWER LEVELS of the memory system.\n\nComputing average access times in a memory hierarchy...\n\nIf we know the hit-rate and access-time ( time to complete a request that hits ) for each level in the hierarchy, we can compute average access time of the memory hierarchy. For each level in the hierarchy, the average access time is\n( T hit x P hit ) + ( T miss x P miss )\nWhere T hit = Time to resolve requests that hit in the level\nP hit = Hi-rate of the level, expressed as a probability.\nT miss = Average access time of the level below this one. rate of the level.\nP miss = Miss\nNote that Hit-rate of the lowest level is 100%, we start at the bottom and compute the average access time of each level upwards in the hierarchy.\n\nExample:\nA memory system contains a cache, a DRAM and a Virtual Store. The access time of the cache is 5 ns with a hit-rate of 80%, whereas the access time of the DRAM is 100 ns with a 99.5 % hit-rate. The access time of the virtual store is 10 ms. What is the average access time of the hierarchy ?\nWe start at the bottom and work upwards:\nThe hit-rate of Virtual store is always 100%.\nAverage access time for requests that reach DRAM\n= ( 100 ns x 0.995 ) + ( 10 ms x 0.005 ) = 50,099.5 ns\nThe average access time for requests that reach the cache\n( which is ALL REQUESTS !!)\n= ( 5 ns x 0.80 ) + ( 50,099.5 ns x 0.20 ) = 10,024 ns\n\n\nSRAM and DRAM Chips\nThese have the same basic structure ( shown in next slide )\nData is stored in rectangular array of bit cells, each holding 1 bit. To read data from the array, half of the address to be read ( generally high order bits) is fed into a decoder. The decoder asserts (drives high) the word line corresponding to the value of its input bits, which causes all of the bit cells in the corresponding row to drive their values onto bit lines that they are connected to.\n\nThe other half of the address is then used as an input to a multiplexer that selects the\nappropriate bit line and drives its output onto the output pins of the chip.\n\nTo store data on the chip, the same process is used, except the value to be written is\ndriven on appropriate bit line and written into the selected bit cell.\n\n<m>http://minhinc.42web.io/image/li-slide-memoryorgnization.png</m>\n<m>http://minhinc.42web.io/image/li-slide-memorysramdram_s.png</m>\n\n<h>\n*Memory allocation & deallocation system\ncalls malloc, calloc, alloca, free\n</h>\n\n<c>\n#include <stdlib.h>\n\nvoid *malloc(size_t size);\nvoid free(void *ptr);\nvoid *calloc(size_t nmemb, size_t size);\nvoid *realloc(void *ptr, size_t size);\n</c>\n\nThe malloc() function allocates size bytes and returns a pointer to the allocated memory. The memory is not initialized. If size is 0, then malloc() returns either NULL, or a unique pointer value that can later be successfully passed to free().\n\nThe free() function frees the memory space pointed to by ptr, which must have been returned by a previous call to malloc(), calloc(), or realloc().\n\nThe calloc() function allocates memory for an array of nmemb elements of size bytes each and returns a pointer to the allocated memory. The memory is set to zero. If nmemb or size is 0, then calloc() returns either NULL, or a unique pointer value that can later be successfully passed to free().\n\nThe  realloc() function changes the size of the memory block pointed to by ptr to size bytes. The contents will be unchanged in the range from the start of the region up to the minimum of the old and new sizes.\n\n<c>\n#include <alloca.h>\nvoid *alloca(size_t size);\n</c>\n\nDESCRIPTION\nThe  alloca() function allocates size bytes of space in the stack frame of the caller.  This temporary space is automatically  freed  when  the function that called alloca() returns to its caller.\n\n<h>\n*Virtual Memory Management\n</h>\n\nVirtual Memory\nEach program has a virtual address space which is the set of addresses that programs use for load and store operations.\n\nThe physical address space is the set of addresses used to reference locations in main memory.\n\nThe virtual address space is divided into pages some of which reside inside a page frame ( slots in main memory ) while others reside on the disk. Pages are always aligned on a multiple of the page size so that the addresses never overlap.\n\nThe terms virtual page and physical page are used to describe a page of data in the virtual and physical address spaces respectively.\n\nPages that have been loaded into main memory are said to have been mapped.\n\nVirtual memory allows a computer to act as if its main memory were much larger than it actually is.\n\nWhen a program references a virtual address, it cannot tell, except by timing the latency of the operation, whether the virtual address was resident in the main memory or whether it had to be fetched from disk.\n\nThis makes it possible for the computer to shuffle pages in and out of the main memory exactly like data is brought in and out of the cache.\n\n<m>http://minhinc.42web.io/image/li-slide-memoryvirtualconcept_s.png</m>\n\n<h>\n*Address Translation and page fault\nhandling\n</h>\n\nAddress Translation\nPrograms running on systems with Virtual Memory use Virtual Addresses as the arguments to load and store instructions.\n\nThe main memory uses Physical Addresses to record locations where data is actually stored.\n\nWhenever a program uses a Virtual Address, this must be converted into a Physical Address and this process is known as Address Translation.\n\nWhen a program accesses a memory location, the O.S accesses a Page Table, which is a data structure that contains the mapping of the virtual address to the physical address.\n\nIf the virtual page is mapped ( present in memory ) then the physical address is retrieved and the operation proceeds.\n\nIf the virtual page is NOT mapped, then a page fault occurs and the O.S fetches the page from the hard disk, loading it into a page frame, and updating the page table with the new translation. Once the page has been read into memory from disk, and the page table updated, the physical address of the page can be determined and the memory reference completed.\n\nIf all the page frames already contain data, one of them must be evicted to the disk to make room for the incoming data. The replacement policies used to select the page that is evicted are similar to the ones for set-associative caches.\n\nBecause both virtual and physical pages are always aligned on a multiple of their size, the page table does not need to keep track of the full virtual or physical address of a page that is mapped. Instead virtual addresses are divided into a Virtual Page Number or VPN and a set of bits that describe an offset from the start of the virtual page to the virtual address. Similarly, the physical pages are divided into Physical Page Numbers or PPN and an offset\n\nBecause both virtual and physical pages are always aligned on a multiple of their size, the page table does not need to keep track of the full virtual or physical address of a page that is mapped. Instead virtual addresses are divided into a Virtual Page Number or VPN and a set of bits that describe an offset from the start of the virtual page to the virtual address. Similarly, the physical pages are divided into Physical Page Numbers or PPN and an offset from the start of the physical page to the physical address.\n\nThe virtual and physical pages in a given system are generally the same size, so the number of bits\n(log 2 of the page size) for the offset of the virtual and physical addresses are the same.\n\nThe VPN and PPN may be of different lengths. For example, on 64-bit systems, the virtual addresses are generally much longer than physical addresses.\n\n<m>http://minhinc.42web.io/image/li-slide-addresstranslationtable_s.png</m>\n\n<m>http://minhinc.42web.io/image/li-slide-virtualtable_s.png</m>\n\nThe page table is accessed using the virtual page frame number as an offset.\n\nVirtual page frame 5 would be the 6th element of the table (0 is the first element).\n\nTo translate a virtual address into a physical one, the processor must first work out\nthe virtual addresses page frame number and the offset within that virtual page. By\nmaking the page size a power of 2 this can be easily done by masking and shifting.\nAssuming a page size of 0x2000 bytes (which is decimal 8192) and an address of 0x2194 in process Y\'s virtual address space then the processor would translate that address into offset 0x194 into virtual page frame number 1.\n\n<m>http://minhinc.42web.io/image/li-slide-pageentry.png</m>\n\n<b>V</b> Valid, if set this PTE is valid,\n<b>FOE</b> "Fault on Execute", Whenever an attempt to execute instructions in this page\noccurs, the processor reports a page fault and passes control to the operating system,\n\n<b>FOW</b> "Fault on Write", as above but page fault on an attempt to write to this page,\n<b>FOR</b> "Fault on Read", as above but page fault on an attempt to read from this page,\n<b>ASM</b> Address Space Match. This is used when the operating system wishes to clear only some of the entries from the Translation Buffer,\n<b>KRE</b> Code running in kernel mode can read this page,\n<b>URE</b> Code running in user mode can read this page,\n<b>GH</b> Granularity hint used when mapping an entire block with a single Translation. Buffer entry rather than many,\n<b>KWE</b> Code running in kernel mode can write to this page,\n<b>UWE</b> Code running in user mode can write to this page,\n\n<b>page frame number</b> For PTEs with the V bit set, this field contains the physical Page Frame Number (page frame number) for this PTE. For invalid PTEs, if this field is not zero, it contains information about where the page is in the swap file.\nThe following two bits are defined and used by Linux:\n<b>PAGE DIRTY</b> if set, the page needs to be written out to the swap file,\n<b>PAGE ACCESSED</b> Used by Linux to mark a page as having been accessed.\n\nTLB, Translation Lookaside Buffers\nA major disadvantage of using page tables is that a page table must be accessed for every memory reference. On a system with a single-level page table, this doubles the number of memory accesses, since each load or store operation requires one memory reference to access the appropriate page table and one to perform the actual load/store. This greatly increases the latency of a memory reference.\n\nThe problem is even greater on multi-level page tables, because multiple references are required to traverse the page table. To reduce penalty, CPUs that incorporate virtual memory use Translation Looaside Buffers ( TLBs) that act as caches for the page table. Whenever a program performs a memory reference the virtual address is sent\nto the TLB to determine if it contains a translation for that address. If so, the TLB returns the physical address and the memory reference continues.\n\nIf not, a TLB miss occurs and the system searches the page table for a translation. Some systems provide hardwaresupport for a TLB miss while others require the OS to access the page table thru software.\n\n<m>http://minhinc.42web.io/image/li-slide-tlb_s.png</m>\n\nTLB misses versus Page Faults\nIn a system that supports TLBs, 3 possible cases exist:\n1. Hit in the TLB : The TLB contains the physical address and it is returned immediately.\n2. TLB miss, but page mapped : In this case the system accesses the page table from memory to find the translation for the virtual address, copies that translation into TLB returns the memory reference\n3. TLB miss and page not mapped: The system accesses the page table and finds that its is not mapped. This results in a page fault. The O.S loads the page\'s data from disk in the same manner as a virtual memory system that does not contain TLB.\n\nTLB misses and page faults are handled very differently by the O.S because of the difference in the amount of time it takes to resolve each event.\n\nTLB misses generally take a short time to resolve if the page is mapped and normally takes a few hundred cycles so user programs can just wait for its completion.\n\nTLB misses that result in a page fault can take a few milliseconds which is the amount of time slice generally given to a process. Therefore, a page fault can trigger a context switch through invoking the scheduler while the page fault is being resolved.\n\n<m>http://minhinc.42web.io/image/li-slide-tlborgnization.png</m>\n\nTLB Entry\nTLBs are organized similar to caches having an associativity and number of sets. While cache sizes are typically described in bytes, TLBs are in number of entres or translations contained in them, since the amount of space taken up by each entry is mostly irrelevant to the performance of the system.\n\nThis a 128-entry, 4-way set-associative TLB would have 32 sets each containing 4 entries.\n\nThe TLB entry contains the VPN of the page that it is a translation for, which is compared to the VPN of the address of a memory reference to determine if a hit has occurred.\n\nLike a cache\'s tag array entry, bits of the VPN used to select an entry in the TLB are omitted to save space. All the bits of the PPN are stored however, since they may differ from the corresponding bits in the VPN.\n\n<h>\n*Demand Paging defined\n</h>\n\nDemand Paging\nAs there is much less physical memory than virtual memory the operating system must be careful that it does not use the physical memory inefficiently. One way to save physical memory is to only load virtual pages that are currently being used by the executing program.\n\nThis technique of only loading virtual pages into memoryas they are accessed is known as demand paging.\n\nWhen a process attempts to access a virtual address that is not currently in memory the processor cannot find a page table entry for the virtual page referenced. For Example in previous figure there is no entry in process X\'s page table for virtual page frame number 2 and so if process X attempts to read from an address within virtual page frame number 2 the processor cannot translate the address into a physical one. At this point the processor notifies the operating system that a page fault has Occurred.\n\nIf the faulting virtual address is invalid this means that the process has attempted to access a virtual address that it should not have. Maybe the application has gone wrong in some way, for example writing to random addresses in memory. In this case the operating system will terminate it, protecting the other processes in the system from this rogue process.\n\nIf the faulting virtual address was valid but the page that it refers to is not currently in memory, the operating system must bring the appropriate page into memory from the image on disk.\n\nThe fetched page is written into a free physical page frame and an entry for the virtual page frame number is added to the processes page table. The process is then restarted at the machine instruction where the memory fault occurred. This time the virtual memory access is made, the processor can make the virtual to physical address translation and so the process continues to run.\n\nLinux uses demand paging to load executable images into a processes virtual memory.  Whenever a command is executed, the file containing it is opened and its contents are mapped into the processes virtual memory. This is done by modifying the data structures describing this processes memory map and is known as memory mapping.\n\nHowever, only the first part of the image is actually brought into physical memory.  The rest of the image is left on disk. As the image executes, it generates page faults and Linux uses the processes memory map in order to determine which parts of the image to bring into memory for execution.\n\n<m>http://minhinc.42web.io/image/li-slide-demandpaging.png</m>\n\n<h>\n*Process Organization in Memory\n</h>\n\nProcess Address Space\n\n<m>http://minhinc.42web.io/image/li-slide-processorganization.png</m>'
'9!ABS SBA!Multi Thread Programming!ABS SBA!*Write a multi threaded application and check if\nglobal variables are shared.\n - Protect them using semaphores!ABS SBA!<h>\n*Creating multiple threads\n</h>\n\nIntroduction\n* Thread is a sequential flow of control through a program.\n* If a process is defined as a program in execution then a thread is defined as a function in execution.\n* If a thread is created, it will execute a specified function.\n* Two type of threading:\n- Single Threading\n- Multi threading\n\n\nPOSIX Thread\nThe created threads within a process share\ninstructions of a process\nprocess address space and data\nopen file descriptors\npwd, uid and gid\n\nThe created threads maintain its own:\nthread identification number (tid)\npc, sp, set of registers\nstack\nSignal Handlers priority of the threads scheduling policy\n\nAdvantages of Threads:\nTakes less time for:\n* Creation of a new thread\n* Termination of a thread\n* Communication between threads are easier.\n\n\nThere are two broad categories of thread\nimplementation:\n1. User level Threads (ULT)\n2. Kernel level threads (or kernel-supported threads or Light weight processes)\n\nThread management\nThread management is done by the application and the kernel is not aware of the existence of threads.\n* Thread library contains code for creating and destroying threads, passing messages and data between threads, for scheduling thread execution and for saving and restoring\nthread contexts.\n* This thread application are allocated to a single process managed by the kernel.\n* All the activity takes place in user space and within a single process. The kernel continues to schedule the process as a unit and assigns a single execution state to that process.\n\n\nULT\nAdvantages:\n* Thread switching does not require kernel mode.\n* Scheduling can be application specific.\n* Can run on any OS.\nDisadvantages:\n* When it executes a system call, not only is that thread is\nblocked, but all the threads within the process are blocked.\n\nKLT\nKernel Level Threads:\n* Thread management is done by the kernel\n- Advantage: If one thread in a process is blocked, kernel can schedule another thread of the same process.\n- Disadvantage: Transfer of control from one thread to another within the same process requires a mode switch to the kernel\n\n\nAdvantages of Multi Threading\nImprove application responsiveness\nUse multiprocessors more efficiently\nImprove program structure\nuse fewer system resources\nSpecific applications in uniprocessor machines\nApplications\n A file server on a LAN\n Graphical User Interfaces (GUIs)\n  web applications\n\n<h>\n*Parent synchronization with other Thread\n</h>\n\nParent wait on join() system call to let children join them\nHello Thread Example\n<c>\n#include <pthread.h>\nvoid thread_function (void) {\nprintf (" Hello POSIX Thread\n");\nprintf ("Thread id: %d\n", pthread_self());\n}\nmain ( ) {\npthread_t mythread;\npthread_create ( &mythread, NULL, thread_function, NULL);\npthread_join (mythread, NULL);\n}\n</c>\n$cc thread.c -lpthread\n\n<h>\n*System calls\n</h>\n\n<b>1. pthread_create</b>\n\n<c>\n#include <pthread.h>\n</c>\n\nint pthread_create(pthread_t *restrict thread,  const pthread_attr_t *restrict attr, void *(*start_routine)(void*), void *restrict arg);\n\nThe pthread_create() function shall create a new thread, with attributes specified by attr, within a process. If attr is NULL, the default attributes shall be used. If the attributes specified by attr are modified later, the thread\'s attributes shall not be affected. Upon  successful completion, pthread_create() shall store the ID of the created thread in the location referenced by thread.\n\n<cc>\n#include<stdio.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<pthread.h>\n#include<string.h>\n\nvoid *thread_fun(void *arg);\n\nchar message[]="hello world";\n\nint main()\n{\nint res;\npthread_t a_thread;\nvoid *thread_result;\n\nres=pthread_create(&a_thread,NULL,thread_fun,(void *)message);\nif(res !=0){\n perror("unable to create thread\n");\n exit(1);\n}\nprintf("waiting for thread to finish\n");\n//Thread joining, catch exit value from the thread\t\nres=pthread_join(a_thread,&thread_result);\n\nif(res !=0){\n perror("unable to join thread\n");\n exit(1);\n}\n\nprintf("thread joined , it returned %s\n",(char *)thread_result);\nprintf("Message is now %s\n",message);\nexit(0);\n}\n\nvoid *thread_fun(void *arg)\n{\nprintf("thread fun ,arg is %s\n",(char *)arg);\nsleep(3);\nstrcpy(message,"bye");\n//exit with return value\npthread_exit("thank you");\n}\n</cc>\n\n<b>2. pthread_key_create</b>\n<c>\n#include <pthread.h>\n\nint pthread_key_create(pthread_key_t *key, void (*destructor)(void*));\n pthread_key_create - thread-specific data key creation\n</c>\n\nThe pthread_key_create() function shall create a thread-specific data key visible to all threads in the process. Key values provided by pthread_key_create() are opaque objects used to locate thread-specific data. Although the same key value may be used by different threads, the values bound to the key by pthread_setspecific() are maintained on a per-thread basis and persist for the life of the calling thread.\n\nUpon key creation, the value NULL shall be associated with the new key in all active threads. Upon thread creation, the value NULL shall be associated with all defined keys in the new thread.\n\n<cc>\n#include <malloc.h>\n#include <pthread.h>\n#include <stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n\n/* The key used to associate a log file pointer with each thread. */\nstatic pthread_key_t thread_log_key;\n\n/* Write MESSAGE to the log file for the current thread. */\n\nvoid write_to_thread_log (const char* message)\n{\nFILE* thread_log = (FILE*) pthread_getspecific (thread_log_key);\nfprintf (thread_log, "%s\n", message);\n}\n\n/* Close the log file pointer THREAD_LOG. */\nvoid close_thread_log (void* thread_log)\n{\nfclose ((FILE*) thread_log);\n}\n\n\nvoid* thread_function (void* args)\n{\nchar thread_log_filename[20];\nFILE* thread_log;\n/* Generate the filename for this thread\'s log file. */\nsprintf (thread_log_filename, "thread%d.log", (int) pthread_self ());\n/* Open the log file. */\nthread_log = fopen (thread_log_filename, "w");\n/* Store the file pointer in thread-specific data under thread_log_key. */\npthread_setspecific (thread_log_key, thread_log);\nwrite_to_thread_log ("Thread starting.");\n/* Do work here... */\nreturn NULL;\n}\nmain ()\n{\nint i;\npthread_t threads[5];\n\n/* Create a key to associate thread log file pointers in\nthread-specific data. Use close_thread_log to clean up the file\npointers. */\n\npthread_key_create (&thread_log_key, close_thread_log);\n\n/* Create threads to do the work. */\nfor (i = 0; i < 5; ++i)\npthread_create (&(threads[i]), NULL, thread_function, NULL);\n\n/* Wait for all threads to finish. */\n\nfor (i = 0; i < 5; ++i)\npthread_join (threads[i], NULL);\nreturn 0;\n}\n</cc>\n\n<b>3. pthread_mutex_init</b>\n<c>\n#include <pthread.h>\n\nint pthread_mutex_destroy(pthread_mutex_t *mutex);\nint pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n</c>\n\nThe pthread_mutex_destroy() function shall destroy the mutex object referenced by mutex; the mutex object becomes, in effect, uninitialized. An implementation may cause pthread_mutex_destroy() to set the object referenced by mutex to an invalid value. A destroyed mutex object can be reinitialized using pthread_mutex_init(); the results of oth erwise referencing the object after it has been destroyed are undefined.\nIt shall be safe to destroy an initialized mutex that is unlocked. Attempting to destroy a locked mutex results in undefined behavior.\n\nThe pthread_mutex_init() function shall initialize the mutex referenced by mutex with attributes specified by attr. If attr is NULL, the default mutex attributes are used; the effect shall be the same as passing the address of a default mutex attributes object. Upon successful initialization, the state of the mutex becomes initialized and unlocked.\n\n<cc>\n#include<stdio.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<string.h>\n#include<pthread.h>\n#include<semaphore.h>\n\nvoid *thread_fun(void *arg);\n\npthread_mutex_t work_mutex;\n\nchar work_area[1024];\nint time_to_exit=0;\nint main()\n{\nint res;\npthread_t a_thread;\nvoid *thread_result;\n\t\nres=pthread_mutex_init(&work_mutex,NULL);//initialize mutex  default attr\nres=pthread_create(&a_thread,NULL,thread_fun,NULL);\npthread_mutex_lock(&work_mutex); //put a lock to the main thread, then enjoy\n\t\nprintf("input some text enter end to finish\n");\nwhile(!time_to_exit)\t{\n fgets(work_area,1024,stdin);\n\n //unlock the main thread,your subordinate is waiting\n pthread_mutex_unlock(&work_mutex);\n while(1){\n  pthread_mutex_lock(&work_mutex);//lock it is your turn\n  if(work_area[0] != \'\\0\') {\n   pthread_mutex_unlock(&work_mutex);\n   sleep(1);\n  }\n  else\n  break;\n\n }\n}\n\npthread_mutex_unlock(&work_mutex);\nprintf("waiting for thread to finish\n");\nres=pthread_join(a_thread,&thread_result);\nprintf("thread joined , it returned %s\n",(char *)thread_result);\npthread_mutex_destroy(&work_mutex);\nexit(0);\n}\n\n\nvoid *thread_fun(void *arg)\n{\nsleep(1);//Sleep well Let main thread send some data\npthread_mutex_lock(&work_mutex);//lock the curr thread\nwhile(strncmp("end",work_area,3) !=0)\n{\n printf("you entered %d characters\n",strlen(work_area) -1);\t\n work_area[0]=\'\\0\';\n pthread_mutex_unlock(&work_mutex);//unlock the current thread\n sleep(1);//Sleep well , Let main thread do it\'s job\n pthread_mutex_lock(&work_mutex);\n while(work_area[0] == \'\\0\')\n {\n  pthread_mutex_unlock(&work_mutex);\n  sleep(1);\n  pthread_mutex_lock(&work_mutex);\n }\n}\ntime_to_exit=1;\nwork_area[0]=\'\\0\';\t\npthread_mutex_unlock(&work_mutex);\n\npthread_exit("thank you");\n\n}//End of the function\n</cc>'
'10!ABS SBA!Inter process communication!ABS SBA!!ABS SBA!<h>\n*Pipes\n</h>\n\nPersistence of various ipcs\n<m>http://minhinc.42web.io/image/li-slide-ipc.png</m>\n\nUnnamed Pipe or Pipe\n\nOn command line pipe is represented as "|"\n* It can be used in the shell to link two or more commands\n- For example ls <c>-Rl | wc</c>\n* Two ends of a pipe is represented as a set of two descriptors.\n* A pipe is used to communicate between related Processes (common ancestor). Normally, a pipe is created by a process, that process calls fork, and the pipe is used between the parent and the child.\n\n* Half duplex\n* Data is passed in order.\n* Pipe uses circular buffer and it has zero buffering capacity\n* The read and write system calls are blocking calls.\n\n<c>\n#include <unistd.h>\nint fd[2];\n</c>\n\n<m>http://minhinc.42web.io/image/li-slide-pipesimplex.png</m>\n\n<c>\nint pipe(int fd[2]);\n</c>\n\n<m>http://minhinc.42web.io/image/li-slide-pipekernelsimplex.png</m>\n\nOne Way Communication between parent and child\n\nCreate a pipe.\n* Call fork.\n* Parent can send data and child can read the data or vice versa.\n* Unused ends (descriptors) should be closed.\n\n<m>http://minhinc.42web.io/image/li-slide-pipefork.png</m>\n\nparent closes the read end of the pipe (fd[0]), and the child closes the write end (fd[1]).\n\n<m>http://minhinc.42web.io/image/li-slide-pipeforksimplex.png</m>\n\nTwo way Communication\n* Create two pipes say fd1, fd2.\n* Four descriptors for each process (<c>fd1[0],fd1[1],fd2[0],fd2[1]</c>)\n* Parent closes read end of fd1 and write end of fd2\n<c>\n- close(fd1[0], fd2[1]);\n</c>\n* child closes read end of fd2 and write end of fd1\n<c>\n- close(fd2[0], fd1[1]);\n</c>\n\n<m>http://minhinc.42web.io/image/li-slide-pipetwowaycommunication.png</m>\n\nPipe : Advantages & Disadvantages\nAdvantages:\n* Simplest form of IPC\n* Persistence in process level\n* Can be used in shell\n\nDisadvantages:\n* Cannot be used to communicate between unrelated processes\n\n<b>popen</b> and <b>pclose</b> Functions\n\nThe function popen does a fork and exec to execute the cmdstring and returns a standard I/O file pointer. If type is "r", the file pointer is connected to the standard output of cmdstring.\nIf type is "w", the file pointer is connected to the standard input of cmdstring.\n\n<c>\n#include <stdio.h>\nFILE *popen(const char *cmdstring, const char *type);\n          Returns: file pointer if OK, NULL on error\nint pclose(FILE *fp);\n          Returns: termination status of cmdstring, or -1 on error\n</c>\n\n<m>http://minhinc.42web.io/image/li-slide-pipepopen.png</m>\n\nResult of <c>fp = popen(cmdstring, "r")</c>\n<m>http://minhinc.42web.io/image/li-slide-pipepopenresult.png</m>\n\nSIMPLEX PIPE\n\n<c>\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\nmain() {\nint pipefd[2],n;\nchar buff[100];\n\nif(pipe(pipefd) < 0) //create a pipe with two descriptors\n perror("filed in openning pipe\n");\nprintf("read fd = %d, write fd = %d\n",pipefd[0],pipefd[1]);\n\n//write into the pipe\'s write decriptor\nif(write(pipefd[1],"hello world.....!",18)!= 18)\n perror("filed in writing pipe\n");\n\n//read from the pipe\'s read decriptor\nif((n = read(pipefd[0],buff,sizeof(buff))) < 0)\n perror("filed in writing pipe\n");\n\nwrite(1 , buff, n);     //write to the stdout\nexit(0);\n}\n</c>\n\nDUPLEX PIPE\n\n<cc>\n#include <stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include <string.h>\n# define MAXBUF 1024\nvoid client(int  readfd,  int writefd) {\nchar buff[MAXBUF];\nint n;\nputs("Enter file name\n");\nscanf("%s",buff);\nn = strlen(buff);\nif(buff[n-1] == \'\\n\') n--;\nif(write(writefd,buff, n) !=n) perror("client: write error\n");\nwhile((n = read(readfd,buff,MAXBUF)) > 0){\n if(write(1,buff,n)!= n)\n  perror("client: error\n");\n}\nif(n < 0)\n perror("Client: write error\n");\n}\n\nvoid server(int readfd,int  writefd) {\nchar    buff[MAXBUF];\nint     n, fd;\nif((n = read(readfd, buff, MAXBUF)) <= 0) perror("server: read error\n");\nbuff[n] = \'\\0\';\nif((fd = open(buff,0)) < 0) perror("server:open error\n");\nwhile((n = read(fd,buff,MAXBUF)) > 0) if(write(writefd,buff,n)!= n) perror("server: write error\n");\n if(n < 0) perror("server : read error\n");\n}\n\nmain() {\nint     pipefd1[2], pipefd2[2], childfd, n;\nchar    buff[100];\nif(pipe(pipefd1) < 0 || pipe(pipefd2) < 0) perror("filed in openning pipes\n");\nif((childfd = fork()) < 0){\nperror("can\'t fork");\nclose(pipefd1[0]);\nclose(pipefd1[1]);\nclose(pipefd2[0]);\nclose(pipefd2[1]);\n}\nelse if(childfd > 0){           //Parent process\nclose(pipefd1[0]);      //read1\nclose(pipefd2[1]);      //write2\nclient(pipefd2[0],pipefd1[1]);\nwhile(wait(( int *) 0)!= childfd);\nclose(pipefd1[1]);\nclose(pipefd2[0]);\n} else {                        // child process\nclose(pipefd1[1]);      // write1\nclose(pipefd2[0]);      // read2\nserver(pipefd1[0],pipefd2[1]);\nclose(pipefd1[0]);\nclose(pipefd2[1]);\n}\nexit(0);\n}\n</cc>\n\n<h>\n*Fifo\'s\n</h>\n\nFIFO: Introduction\n* FIFO works much like a pipe\n -Half duplex, data passed in FIFO order, circular buffer\nand zero buffering capacity.\n* FIFO is created on a file system as a device\nspecial file\n* It can be used to communicate between unrelated\nprocesses\n* It can be reused.\n* Persist till the file is deleted.\n\n\nFIFO Creation\n* FIFO can be created in a shell by using mknod or\nmkfifo command.\n - mknod myfifo p\n - mkfifo a=rw myfifo\n* In a C program mknod system call or mkfifo library function can be used.\n - int mkfifo ( char *file_name, mode_t mode);\n - int mknod (char *file_name, mode_t mode, dev_t dev);\n* mknod("./MYFIFO", S_IFIFO|0666, 0);\n\nUsing FIFO\n* Once a FIFO is created either from a shell or through a program, file\'s related system calls (open, read, write, select, close etc., ) are used to access the FIFO.\n* For example: Process 1 may open a FIFO in write only mode and write some data.\n* Process 2 may open the FIFO in read only mode, read the data and display on the monitor.\n\nFIFO: Disadvantages\n* Data cannot be broadcast to multiple receivers.\n* If there are multiple receivers, there is no way to direct to a specific reader or vice versa.\n* Cannot be used across network\n* Less secure than a pipe, since any process with valid access permission can access data.\n* Cannot store data\n* No message boundaries. Data is treated as a stream of Bytes.\n\n<cc>\n#include <stdio.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include <string.h>\n\n# define FIFO1  "/tmp/fifo1" //fifos can be created in users home\n# define FIFO2  "/tmp/fifo2" //directory also.\n\n# define MAXBUF 1024\n\nvoid client(int  readfd,  int writefd) {\nchar buff[MAXBUF];\nint n;\nputs("Enter file name\n");\nscanf("%s",buff);       //reading file name\nn = strlen(buff);\nif(buff[n-1] == \'\\n\') n--;\nif(write(writefd,buff, n) !=n) //writing file name into fifo\nperror("client: write error\n");\nwhile((n = read(readfd,buff,MAXBUF)) > 0) if(write(1,buff,n)!= n) perror("client: error\n");\nif(n < 0) perror("Client: write error\n");\n}\n\nvoid server(int readfd,int  writefd) {\nchar buff[MAXBUF];\nint n, fd;\nif((n = read(readfd, buff, MAXBUF)) <= 0) perror("server: read error\n");\nbuff[n] = \'\\0\';\nif((fd = open(buff,0)) < 0) perror("server:open error\n");\nwhile((n = read(fd,buff,MAXBUF)) > 0) if(write(writefd,buff,n)!= n) perror("server: write error\n");\nif(n < 0) perror("server : read error\n");\n}\n\nmain() {\nint     readfd, writefd ,pid;\n//fifo is created with user read and write //permission.\nif((mkfifo(FIFO1, 0666)) < 0){\nperror("Fifo1 failed\n");\nexit(1);\n}\nif((mkfifo(FIFO2, 0666)) < 0){\nperror("Fifo1 failed\n");\nexit(2);\n}\nif((pid = fork()) == 0){\nreadfd = open(FIFO1, 0, 0);//child opens fifo1 for read\nwritefd = open(FIFO2, 1, 0);//child opens fifo2 for write\n//child process calls server function\nserver(readfd, writefd);\nexit(3);\n}\nwritefd = open(FIFO1, 1, 0);\nreadfd = open(FIFO2, 0, 0);\n//Parent becomes client process\nclient(readfd, writefd);\n\n//parent wait till exit status returned is equal to pid(current child)\nwaitpid(pid,NULL,0);\nclose(readfd);\nclose(writefd);\n\nunlink(FIFO1);  //removing fifo from /tmp\nunlink(FIFO2);\nexit(0);\n}\n</cc>\n\n<h>\n*Signals\n</h>\n\nThe common communication channel between user space program and kernel is given by the system calls.\nBut there is a different channel, that of the signals, used both between user processes and from kernel to user process.\n\nSending Signals\nA program can signal a different program using the kill() system call with prototype\n<c>\nint kill(pid_t pid, int sig);\n</c>\nThis will send the signal with number sig to the process with process ID pid . Signal numbers are small positive integers.\n\nReceiving signals\n<c>\ntypedef void (*sighandler_t)(int);\nsighandler_t signal(int sig, sighandler_t handler);\n\nSignal     Value     Action   Comment\n-------------------------------------------------\nSIGHUP        1       Term    Hangup detected on controlling terminal or death of controlling process\nSIGINT        2       Term    Interrupt from keyboard\nSIGQUIT       3       Core    Quit from keyboard\nSIGILL        4       Core    Illegal Instruction\nSIGABRT       6       Core    Abort signal from abort(3)\nSIGFPE        8       Core    Floating point exception\nSIGKILL       9       Term    Kill signal\nSIGSEGV      11       Core    Invalid memory reference\nSIGPIPE      13       Term    Broken pipe: write to pipe with no\nreaders\nSIGALRM      14       Term    Timer signal from alarm(2)\nSIGTERM      15       Term    Termination signal\nSIGUSR1   30,10,16    Term    User-defined signal 1\nSIGUSR2   31,12,17    Term    User-defined signal 2\nSIGCHLD   20,17,18    Ign     Child stopped or terminated\nSIGCONT   19,18,25    Cont    Continue if stopped\nSIGSTOP   17,19,23    Stop    Stop process\nSIGTSTP   18,20,24    Stop    Stop typed at terminal\nSIGTTIN   21,21,26    Stop    Terminal input for background process\nSIGTTOU   22,22,27    Stop    Terminal output for background process\n</c>\n\nThe signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.\n\nSignals not in the POSIX.1-1990 standard but described in SUSv2 and POSIX.1-2001.\n<c>\nSignal       Value     Action   Comment\n--------------------------------------------------------------\nSIGBUS      10,7,10     Core    Bus error (bad memory access)\nSIGPOLL                 Term    Pollable event (Sys V).\nSynonym for SIGIO\nSIGPROF     27,27,29    Term    Profiling timer expired\nSIGSYS      12,31,12    Core    Bad argument to routine (SVr4)\nSIGTRAP        5        Core    Trace/breakpoint trap\nSIGURG      16,23,21    Ign     Urgent condition on socket (4.2BSD)\nSIGVTALRM   26,26,28    Term    Virtual alarm clock (4.2BSD)\nSIGXCPU     24,24,30    Core    CPU time limit exceeded (4.2BSD)\nSIGXFSZ     25,25,31    Core    File size limit exceeded (4.2BSD)\n</c>\n\nvarious other signals.\n<c>\nSignal       Value     Action   Comment\n-------------------------------------------------\nSIGIOT         6        Core    IOT trap. A synonym for SIGABRT\nSIGEMT       7,-,7      Term\nSIGSTKFLT    -,16,-     Term    Stack fault on coprocessor (unused)\nSIGIO       23,29,22    Term    I/O now possible (4.2BSD)\nSIGCLD       -,-,18     Ign     A synonym for SIGCHLD\nSIGPWR      29,30,19    Term    Power failure (System V)\nSIGINFO      29,-,-             A synonym for SIGPWR\nSIGLOST      -,-,-      Term    File lock lost (unused)\nSIGWINCH    28,28,20    Ign     Window resize signal (4.3BSD, Sun)\nSIGUNUSED    -,31,-     Core    Synonymous with SIGSYS\n</c>\n\nBlocking signals\nEach process has a list (bitmask) of currently blocked signals. When a signal is blocked, it is not delivered (that is, no signal handling routine is called), but remains pending.\n<c>\nThe sigprocmask() system call serves to change the list of blocked signals. See sigprocmask(2).\nThe sigpending() system call reveals what signals are (blocked and) pending.\nThe sigsuspend() system call suspends the calling process until a specified signal is received.\n</c>\nWhen a signal is blocked, it remains pending, even when otherwise the process would ignore it.\n\nwait and SIGCHLD\nWhenever the child (it exits, crashes, traps, stops, continues), and in particular\nwhen it dies, the parent is sent a SIGCHLD signal. If parent handles it then\n\nThe parent can use the system call wait() or waitpid() or so, there are a few variations, to learn about the status of its stopped or deceased children. In the case of a deceased child, as soon as a status has been reported, the zombie vanishes.\n\nIf the parent is not interested it can say so explicitly (before the fork) using\n\n<c>\nsignal(SIGCHLD, SIG_IGN);\nor\nstruct sigaction act;\nact.sa_handler = something;\nact.sa_flags = SA_NOCLDWAIT;\nsigaction (SIGCHLD, &act, NULL);\n</c>\n\nand as a result it will not hear about deceased children, and children will not be transformed into zombies. Default action for SIGCHLD is to ignore the signal but it would create zombie child process.\n\nReturning from a signal handler\nWhen the program was interrupted by a signal, its status (including all integer and floating point registers) was saved, to be restored just before execution continues at the point of interruption.\nThis means that the return from the signal handler is more complicated than an arbitrary procedure return - the saved state must be restored.\nTo this end, the kernel arranges that the return from the signal handler causes a jump\n\n<c>\n# include <stdio.h>\n# include <signal.h>\n# include <unistd.h>\nvoid    sig_fun(int);\nmain() {\nstruct sigaction  signalact;\nsignalact.sa_handler = sig_fun;\nsigemptyset(&signalact.sa_mask);\nsignalact.sa_flags =0;\nsigaction(SIGINT, &signalact, 0);\nwhile(1){\n printf("hello world\n");\n sleep(1);\n}\n}\nvoid    sig_fun(int signal) {\n printf("Hi, I got signal: %d\n",signal);\n}\n</c>\n\nSIGCHLD\n<c>\n# include <signal.h>\nvoid sig_init(void);\nmain() {\n unsigned int pid, i;\n if((pid = fork()) == 0) sleep(1);\n else {\n  signal(SIGCHLD,sig_init);\n  for(i=0;i < 1000000000;i++) ;\n  printf("parent exiting\n");\n }\n}\nvoid sig_init(void)\n{\n printf("child terminated\n");\n}\n</c>\n\nSIGUSER\n\n<cc>\n#include<stdio.h>\n#include<signal.h>\nstatic void sighandler(int);\nint main(void) {\nint i,parentpid,childpid,status;\n/*prepare the sighandler routine to catch SIGUSR1 and SIGUSR2 */\nif(signal(SIGUSR1,sighandler)==SIG_ERR) printf("Parent:Unable to create handler for SIGUSR1\n");\nparentpid=getpid();\nif((childpid=fork())==0) {\n kill(parentpid,SIGUSR1);/* raise the SIGUSR1 signal*/\n printf("\nHi,child, I am here .............!\n\n");\n if(signal(SIGUSR2,sighandler)==SIG_ERR) printf("Child:Unable to create handler for SIGUSR2\n");\n /*Child Process begins busy-wait for a signal*/\n printf("child,waiting for singnal\n");\n pause();\n //sleep(4);\n printf("child done %d\n",getpid());\n}\nelse {\n kill(childpid,SIGUSR2);/* raise the SIGUSR2 signal*/\n printf("Parent:waiting for child to terminate.....\n");\n //sleep(1);\n wait(&status);/*Parent waiting for the child termination*/\n //kill(parentpid,SIGTERM);/*Parent  raising the SIGTERM signal*/\n printf("parent done %d\n",getpid());\n}\n}\nstatic void sighandler(int signo) {\nswitch(signo)\n{\n case SIGUSR1:/* Incoming SIGUSR1 signal*/\n  printf("Parent:Recieved SIGUSR1\n");\n  break;\n case SIGUSR2:/*Incoming SIGUSR2 signal*/\n  printf("Recieved SIGUSR2\n");\n  break;\n default:\n  printf("This should not be printed\n");\n}\n return;\n}\n</cc>\n\n<h>\n*System-V IPC\'s\n - Message queues\n</h>\n\nIntroduction\n* Sys V IPC is implemented as a single unit.\n* System V IPC Provides three mechanisms namely:\n - Message Queues\n - Shared Memory\n - Semaphores\n* Persist till explicitly delete or reboot the system.\n\nCommon Attributes\nEach IPC objects has the following attributes.\n key\n id\n Owner\n Permission\n Size\n    - Message queue - used-bytes, number of messages\n    - Shared memory - size, number of attach, status\n    - Semaphore - number of semaphores in a set\n    - The ipc_perm structure holds the common attributes of the resources.\n\nSystem Limitations\n$ ipcs -l\n<c>\n------ Shared Memory Limits --------\nmax number of segments = 4096\nmax seg size (kbytes) = 32768\nmax total shared memory (kbytes) = 8388608\nmin seg size (bytes) = 1\n------ Semaphore Limits --------\nmax number of arrays = 128\nmax semaphores per array = 250\nmax semaphores system wide = 32000\nmax ops per semop call = 32\nsemaphore max value = 32767\n------ Messages: Limits --------\nmax queues system wide = 16\nmax size of message (bytes) = 8192\ndefault max size of queue (bytes) = 16384\n</c>\n\nGet a Key\n* If we wish to communicate between different processes using an IPC resource, the first step is to create a shared unique identifier.\n* The simplest form of the identifier is a number - the system generates this number dynamically for a given mechanism by using the ftok library function.\n* But apart from the creator, other processes that want to communicate with the creator process should agree to the key value.\n* Syntax: key_t ftok (const char *filename, int id);\n\n\nGet an id\nThe syntax for a get function is:\n<c>\n  int xxxget (key_t key, int xxxflg);\n</c>\n  (xxx may be msg or shm or sem)\nIf successful, returns to an identifier; otherwise -1 for error.\nThe key can be generated in three different ways\n  - from the ftok library function\n  - by choosing some static positive integer value\n  - by using the IPC_PRIVATE macro\nflags commonly used with this function are IPC_CREAT and IPC_EXCL.\n\n\nControl an Object\nThe syntax for the control function is:\n<c>\n   int xxxctl (int xxxid, int cmd, struct xxxid_ds *buffer);\n</c>\n   (xxx may be msg or shm or sem);\nIf successful, the xxxctl function returns zero, otherwise it returns -1.\nThe command argument may be\n <c>IPC_STAT</c>\n <c>IPC_SET</c>\n <c>IPC_RMID</c>\n\nMessage Queues\n* Message queue overcomes FIFO limitation like storing data and setting message boundaries.\n* Create a message queue\n* Send message (s) to the queue\n* Any process who has permission to access the queue can retrieve message (s).\n* Remove the message queue.\n\nEach queue has the following msqid_ds structure associated with it:\n\n<c>\nstruct msqid_ds {\nstruct ipc_perm msg_perm;\nmsgqnum_t msg_qnum; /*# of messages on queue */\nmsglen_t msg_qbytes; /*max # of bytes on queue */\npid_t msg_lspid; /*pid of last msgsnd() */\npid_t msg_lrpid; /*pid of last msgrcv() */\ntime_t msg_stime; /*last-msgsnd() time */\ntime_t msg_rtime; /*last-msgrcv() time */\nime_t msg_ctime; /*last-change time */\n..\n..\n};\n</c>\n\nmsgget\n<c>\n* int msgget (key_t key, int msgflg);\n* The first argument key can be passed from the return value of the ftok function or made IPC_PRIVATE.\n* To create a message queue, IPC_CREAT ORed with access permission is set for the msgflg argument.\n* Ex: msgid = msgget (key, IPC_CREAT | 0744);\nmsgid = msgget (key, 0);\n</c>\n\nmsgsnd\n<c>\n* The syntax of the function is:\n* int msgsnd (int msqid, structu msgbuf *msgp, size_t msgsz, int msgflg);\n* Arguments:\n- message queue ID\n- address of the structure.\n- size of the message text\n- message flag\n* 0 or IPC_NOWAIT\nstruct mymesg {\nlong mtype;\n/* positive message type */\nchar mtext[512]; /* message data, of length nbytes */\n};\n</c>\n\nmsgrcv\n Syntax of the function is:\n<c>\nssize_t msgrcv (int msqid, struct msgbuf *msgp, size_t msgsz, long msgtype, int msgflg);\n</c>\n\nmsgtype argument is used to retrieve a particular\nmessage.\n 0 -retrieve in FIFO order\n +ve - retrieve the the exact value of the message type\n -ve - first message or <= to the absolute value. on success, msgrcv returns with the number of bytes actually copied into the message text\n\nDestroying a Message Queue\nThere are many ways:\n* From command line, using one of the ways\n- $ ipcrm msg msqid\n- $ ipcrm -q msqid\n- $ ipcrm -Q msgkey\n* Using system call\n- msgctl (msgid, IPC_RMID, 0);\n\n\nMessage Queue: Pseudo Code\n<c>\nkey = ftok (".", \'a\');\nmsqid = msgget (key, IPC_CREAT|0666);\nmsgsnd (msqid, &struct, sizeof (struct), 0);\nmsgrcv (msqid, &struct, sizeof (struct), mtype, 0);\nmsgctl (msqid, IPC_RMID, NULL);\n</c>\n$ipcrm msg msqid\n\nLimitations\n* Message queues are effective if a small amount of data is transferred.\n* Very expensive for large transfers.\n* During message sending and receiving, the message is copied from user buffer into kernel buffer and vice versa\n* So each message transfer involves two data copy operations, which results in poor performance of a system.\n* A message in a queue can not be reused\nMessage send tests.c\n<cs>\n#include<sys/ipc.h>\n#include<sys/types.h>\n#include<sys/msg.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<stdio.h>\nstruct message\n{\nlong mtype;\nchar mtext[50];\n};\nmain()\n{\nstruct message m1;\nint msgid;\nif((msgid=msgget(1,0666|IPC_CREAT))==-1) {\n perror("msgget");\n exit(1);\n}\nm1.mtype=getpid();\nprintf("Process id of the current process is:%ld\n",getpid());\nprintf("Enter the message you want to send to the queue\n");\nfgets(m1.mtext,50,stdin);\nif((n=msgsnd(msgid,&m1,50,0))==-1) {\n perror("msgsnd");\n exit(1);\n}\nprintf("Message successfully sent\n");\n}\n\n<c>Message receive testr.c</c>\n\n#include<sys/ipc.h>\n#include<sys/types.h>\n#include<sys/msg.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<stdio.h>\nstruct message {\n long mtype;\n char mtext[50];\n};\n\nmain() {\nstruct message m1;\nint msgid;\nif((msgid=msgget(1,0666|IPC_CREAT))==-1) {\n perror("msgget");\n exit(1);\n}\nif(msgrcv(msgid,&m1,10,0,MSG_NOERROR)==-1) {\n perror("msgsnd");\n exit(1);\n}\nprintf("Message received from the process whose pid is:%ld\n",m1.mtype);\nprintf("And the message is:%s\n",m1.mtext);\n}\n\n<c>Message control testc.c</c>\n\n#include<sys/ipc.h>\n#include<sys/types.h>\n#include<sys/msg.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<stdio.h>\nmain(){\nint msgid;\nif((msgid=msgget(1,0))==-1) {\n perror("msgget");\n exit(1);\n}\nif(msgctl(msgid,IPC_RMID,0)==-1) {\n perror("msgctl");\n exit(1);\n}\nprintf("Message queue successfully deleted\n");\n}\n</cs>\n\n<h>\n* - Shared memory\n</h>\n\nShared Memory\n* Very flexible and ease of use.\n* Fastest IPC mechanisms\n* shared memory is used to provide access to\n  Global variable\n  Shared libraries\n  Word processors\n  Multi-player gaming environment\n  Http daemons\n  Other programs written in languages like Perl, C etc.,\n\n<m>http://minhinc.42web.io/image/li-slide-sharedmemory.png</m>\n\nShared Memory: Data Structures\nThe data structures used in shared memory are\n  * shmid_ds\n  * ipc_perm\n  * Shminfo\n  * shm_info\n  * shmid_kernel\n\nipc_perm Structure\n<cc>\nstruct ipc_perm {\n__key_t __key;  - Key\n__uid_t uid     - Owner\'s user ID\n__gid_t gid;    - Owner\'s group ID\n__uid_t cuid;   - Creator\'s user ID\n__gid_t cgid;   - Creator\'s group ID\nunsigned short int mode; - r/w permission unsigned short int\n__seq;                  - Sequence number\n};\n</cc>\n\n\nshmid_ds\n<cc>\nstruct shmid_ds\n{\nstruct ipc_perm shm_perm;\nsize_t shm_segsz;\n__time_t shm_atime;\n__time_t shm_dtime;\n__time_t shm_ctime;\n__pid_t shm_cpid;\n__pid_t shm_lpid;\nshmatt_t shm_nattch;\n};\n</cc>\n\nSteps to Access Shared Memory\nThe steps involved are:\n* Creating shared memory\n* Connecting to the memory & obtaining a pointer to the memory\n* Reading/Writing & changing access mode to the memory\n* Detaching from memory\n* Deleting the shared segment\nshmat\n* Used to attach the created shared memory segment onto a process address space.\n* void *shmat(int shmid,void *shmaddr,int shmflg)\n* Example: data=shmat(shmid,(void *)0,0);\n* A pointer is returned on the successful execution of the system call and the process can read or write to the segment using the pointer.\n\n\nReading / Writing to Shared Memory\n* Reading or writing to a shared memory is the easiest\npart.\n* The data is written on to the shared memory as we do it\nwith normal memory using the pointers\n* Eg. Read:\nprintf("SHM contents : %s\n", data);\n* Eg. Write:\nprinf("Enter a String : ");\nscanf(" %[^\n]",data);\n\n\nshmdt and shmctl\n* The detachment of an attached shared memory segment is done by shmdt to pass the address of the pointer as an argument.\n* Syntax: int shmdt(void *shmaddr);\n* To remove shared memory call:\nint shmctl(shmid,IPC_RMID,NULL);\n* These functions return -1 on error and 0 on successful execution.\n\nShared Memory: Pseudo Code\n* shmid = shmget (key, 1024, IPC_CREAT|0744);\n* void *shmat (int shmid, void *shmaddr, int shmflg);\n      if the shm is read only pass SHM_RDONLY else 0\n* (void *)data = shmat (shmid, (void *)0, 0);\n* int shmdt (void *shmaddr);\n* int shmctl (shmid, IPC_RMID, NULL);\n\nLimitations\n* Data can either be read or written only. Append is not allowed.\n* Race condition\n- Since many processes can access the shared memory, any modification done by one process in the address space is visible to all other processes. Since the address space is a shared resource, the developer should implement a proper locking mechanism to prevent the race condition in the shared memory.\n\nShared memory create\n<cs>\n#include<sys/ipc.h>\n#include<sys/shm.h>\n#include<stdio.h>\n#include <stdlib.h>\n#include <string.h>\nmain()\n{\nint shmid,pos;\nchar *msg;\n\nif((shmid=shmget(110,1024,IPC_CREAT|0666))==-1) {\n perror("shmget");\n exit(1);\n}\n\nmsg=shmat(shmid,0,0);\n\nprintf("Enter the data you want to write into shared memory\n");\nfgets(msg,1024,stdin);\npos = strlen(msg);\nstrcpy(msg+pos-1,"World");\nprintf("Data successfully written\n");\n\nshmdt(msg);\n}\n\n<c>Shared memory read</c>\n#include<sys/ipc.h>\n#include<sys/shm.h>\n#include<stdio.h>\n#include <stdlib.h>\n#include <string.h>\nmain()\n{\nint shmid;\nchar *msg;\n\nif((shmid=shmget(110,1024,0666|IPC_CREAT))==-1) {\n perror("shmget"); //get shrdmry id\n exit(1);\n}\n\nmsg=shmat(shmid,0,0);\nprintf("Data written in the shared memory is:%s\n",msg);\n\nshmdt(msg); //to detach the memory location for further use\n}\n\n<c>Shared memory control</c>\n#include<sys/ipc.h>\n#include<sys/shm.h>\n#include<stdio.h>\n#include <stdlib.h>\n\nmain()\n{\nint shmid;\n\nif((shmid=shmget(110,0,0))==-1)  //110 is key\n{\n perror("shmid");\n exit(1);\n}\n\nif(shmctl(shmid,IPC_RMID,0)==-1) {\n perror("shmctl");\n exit(1);\n}\nprintf("Shared memory successfully removed\n");\n}\n</cs>\n\n<h>\n* - Semaphore\n</h>\n\nSemaphores\n* If a process wants to use the shared object, it will "lock" it by asking the semaphore to decrement the counter\n* Depending upon the current value of the counter, the semaphore will either be able to carry out this operation, or will have to wait until the operation becomes possible\n* The current value of counter is >0, the decrement operation will be possible. Otherwise, the process will have to wait\n\nSystem V IPC: Semaphores\n* System V semaphore provides a semaphore set\n- that can include a number of semaphores. It is up to user to decide the number of semaphores in the set.\n* Each semaphore in the set can be a binary or a counting semaphore. Each semaphore can be used to control access to one resource - by changing the value of semaphore count.\n\nSemaphore: Initialization\n<cc>\nunion semun {\nint val;\n// value for SETVAL\nstruct semid_ds *buf; // buffer for IPC_STAT, IPC_SET\nunsigned short int *array; // array for GETALL, SETALL\n};\nunion semun arg;\nsemid = semget (key, 1, IPC_CREAT | 0644);\narg.val = 1; /* 1 for binary else > 1 for Counting Semaphore */\nsemctl (semid, 0, SETVAL, arg);\n</cc>\n\nSemaphore: Implementation\n<cc>\nstruct sembuf {\nshort sem_num; /* semaphore number: 0 means first */\nshort sem_op; /* semaphore operation: lock or unlock */\nshort sem_flg; /* operation flags : 0, SEM_UNDO, IPC_NOWAIT */\n};\nstruct sembuf buf = {0, -1, 0}; /* (-1 + previous value) */\nsemid = semget (key, 1, 0);\nsemop (semid, &buf, 1); /* locked */\n-----Critical section--------\nbuf.sem_op = 1;\nsemop (semid, &buf, 1); /* unlocked */\n\n# include <sys/types.h>\n# include <sys/sem.h>\n# include <sys/ipc.h>\n# include <stdio.h>\n# include<pthread.h>\n# include<unistd.h>\nunion semun{\n\tint val;\n\tstruct semid_ds   *buf;\n\tunsigned short  array;\n\n\tstruct seminfo    *__buff;\n};\n\nvoid * th_fun(void *);\n\nunion semun  u;\nint    sid;\nkey_t  key;\nint    pid,   sid;\nstruct sembuf su, sl;\n\n\nmain()\n{\npthread_t\tt1, t2, t3, t4;\n\nunsigned short int  key;\nkey = ftok("semaphore.c",100);\nsid = semget(key,1,IPC_CREAT | 0666);\nprintf("semaphore created by %d\n",getpid());\nu.val = 2;\nsemctl(sid,0,SETVAL,u);\nprintf("Semaphore initialized to %d\n",u.val);\n\npid = getpid();\n\nsl.sem_num = 0;\nsl.sem_op = -1;\nsl.sem_flg = SEM_UNDO ;\nsu = sl;\nsu.sem_op = 1;\n\npthread_create(&t1, NULL, th_fun,"Thread One");\npthread_create(&t2, NULL, th_fun,"Thread two");\npthread_create(&t3, NULL, th_fun,"Thread three");\npthread_create(&t4, NULL, th_fun,"Thread four");\n\npthread_join(t1,NULL);\npthread_join(t2,NULL);\npthread_join(t3,NULL);\npthread_join(t4,NULL);\n\n//semctl(sid,0,IPC_RMID);\nprintf("Semaphore removed\n");\n}\nvoid * th_fun(void *p)\n{\nchar   *str;\nint i = 0;\n\nstr = (char * )p;\nprintf("%s is Trying to lock semaphore  %d\n\n",str, pid);\nif(semop(sid,&sl,1) == 0)\n printf("%s   Succedd in LOck   %d\n\n",str,pid);\n\nwhile(++i < 3)\t{\n printf("%s   Resourec use here %d\n\n",str,pid);\n sleep(6);\n}\nsemop(sid,&su,1);\nprintf("%s  Unlock and Bye   %d\n\n",str,pid);\n}\n</cc>'
'11!ABS SBA!Sockets!ABS SBA!!ABS SBA!<h>\n*An Overview\n</h>\n\nA socket is an abstraction of a communication endpoint. Just as they would use file descriptors to access files, applications use socket descriptors to access sockets. Socket descriptors are implemented as file descriptors in the UNIX System. Indeed, many of the functions that deal with file descriptors, such as read and write, will work with a socket descriptor.\n\nTo create a socket, we call the socket function.\n\n<c>\n#include <sys/socket.h>\nint socket(int domain, int type, int protocol);\n</c>\n\nReturns: file (socket) descriptor if OK, -1 on error\n\nDomain\n\n<m>http://minhinc.42web.io/image/li-slide-socketdomain.png</m>\n\nType\n\n<m>http://minhinc.42web.io/image/li-slide-sockettype.png</m>\n\nProtocol\n\n<m>http://minhinc.42web.io/image/li-slide-socketprotocol.png</m>\n<m>http://minhinc.42web.io/image/li-slide-socketprotocol1.png</m>\n\n<cc>\nsocket() call is similar to open() system call.\nslose - deallocates the socket\ndup, dup2 - duplicates the file descriptor as normal\nfchdir - fails with errno set to ENOTDIR\nfchmod - unspecified\nfchown - implementation defined\nfcntl  -some commands supported, including F_DUPFD, F_DUPFD_CLOEXEC,          F_GETFD, F_GETFL, F_GETOWN, F_SETFD, F_SETFL, and F_SETOWN\nfdatasync, fsync  - implementation defined\nfstat - some stat structure members supported, but how left up to the implementation\nftruncate - unspecified\nioctl - some commands work, depending on underlying device driver\nlseek - implementation defined (usually fails with errno set to ESPIPE)\nmmap - unspecified\npoll  - works as expected\npread and pwrite  - fails with errno set to ESPIPE\nread and readv - equivalent to recv without any flags\nselect  - works as expected\nwrite  and writev - equivalent to send without any flags\n</cc>\n\n<c>\n#include <sys/socket.h>\nint shutdown(int sockfd, int how);\n</c>\n\nIf how is SHUT_RD, then reading from the socket is disabled. If how is SHUT_WR, then we can\'t use the socket for transmitting data. We can use SHUT_RDWR to disable both data transmission and reception.\n\nGiven that we can close a socket, why is shutdown needed? There are several reasons. First, close will deallocate the network endpoint only when the last active reference is closed. If we duplicate the socket (with dup, for example), the socket won\'t be deallocated until we close the last file descriptor referring to it. The shutdown function allows us to deactivate a socket independently of the number of active file descriptors referencing it. Second, it is sometimes convenient to shut a socket down in one direction only. For example, we can shut a socket down for writing if we want the process we are communicating with to be able to tell when we are done transmitting data, while still allowing us to use the socket to receive data sent to us by the process.\n\nByte Ordering\nThe TCP/IP protocol suite uses big-endian byte order.\n\n<m>http://minhinc.42web.io/image/li-slide-endian.png</m>\n\n<c>\n#include <arpa/inet.h>\nuint32_t htonl(uint32_t hostint32);\n                     Returns: 32-bit integer in network byte order\nuint16_t htons(uint16_t hostint16);\n                     Returns: 16-bit integer in network byte order\nuint32_t ntohl(uint32_t netint32);\n                     Returns: 32-bit integer in host byte order\nuint16_t ntohs(uint16_t netint16);\n                     Returns: 16-bit integer in host byte order\n\nstruct sockaddr_in {\nsa_family_t sin_family;  /* address family */\nin_port_t sin_port; /* port number */\nstruct in_addr sin_addr;  /* IPv4 address */\n};\n</c>\n\ninet_ntop - network to presentation\n\n<c>\n#include <arpa/inet.h>\nconst char *inet_ntop(int domain, const void *restrict addr,\nchar *restrict str, socklen_t size);\nReturns: pointer to address string on success, NULL on error\nint inet_pton(int domain, const char *restrict str,\nvoid *restrict addr);\nReturns: 1 on success, 0 if the format is invalid, or -1 on error\n</c>\n\nAddress Look Up\nTo iterate or set the network configuration on the machine\n\n<c>\n#include <netdb.h>\nstruct hostent *gethostent(void);\n                Returns: pointer if OK, NULL on error\nvoid sethostent(int stayopen);\nvoid endhostent(void);\n\nstruct hostent {\nchar *h_name;\nchar **h_aliases;\nint  h_addrtype;\nint h_length;\nchar **h_addr_list;\n.\n};\n</c>\n\nDNS\ngethostbyname and gethostbyaddr() are obselete against following api\n\n<c>\n#include <netdb.h>\nstruct netent *getnetbyaddr(uint32_t net, int type);\nstruct netent *getnetbyname(const char *name);\nstruct netent *getnetent(void);\n</c>\n\nAll return: pointer if OK, NULL on error\n\n<c>\nvoid setnetent(int stayopen);\nvoid endnetent(void);\n</c>\n\nThe netent structure contains at least the following fields:\n\n<c>\nstruct netent {\nchar n_name; /*network name */\nchar **n_aliases; /*alternate network name array pointer */\nint n_addrtype; /*address type */\nuint32_t n_net; /*network number */\n..\n};\n</c>\n\nWe can map between protocol names and numbers with the following functions.\n\n<c>\n#include <netdb.h>\nstruct protoent *getprotobyname(const char *name);\nstruct protoent *getprotobynumber(int proto);\nstruct protoent *getprotoent(void);\n</c>\n\nAll return: pointer if OK, NULL on error\n\n<c>\nvoid setprotoent(int stayopen);\nvoid endprotoent(void);\n</c>\n\nThe protoent structure as defined by POSIX.1 has at least the following members:\n\n<c>\nstruct protoent {\nchar *p_name; /* protocol name */\nchar **p_aliases; /* pointer to alternate protocol name array */\nint p_proto;/* protocol number */\n..\n};\n</c>\n\nServices are represented by the port number portion of the address. Each service is offered on a unique, well-known port number. We can map a service name to a port number with getservbyname, map a port number to a service name with getservbyport, or scan the services database sequentially with getservent.\n\n<c>\n#include <netdb.h>\nstruct servent *getservbyname(const char *name, const char *proto);\nstruct servent *getservbyport(int port, const char *proto);\nstruct servent *getservent(void);\n</c>\n\nAll return: pointer if OK, NULL on error\n\n<c>\nvoid setservent(int stayopen);\nvoid endservent(void);\n</c>\n\nThe servent structure is defined to have at least the following members:\n\n<c>\nstruct servent {\nchar *s_name;\nchar **s_aliases;\nint s_port;\nchar *s_proto;\n..\n};\n</c>\n\n<h>\n*System calls related to\n - TCP\n</h>\n\n<m>http://minhinc.42web.io/image/li-slide-tcpcommunication.png</m>\n<c>\n#include <sys/socket.h>\nint bind(int sockfd, const struct sockaddr *addr, socklen_t len);\n\nReturns: 0 if OK, -1 on error\n</c>\n\n* sockfd - the socket file descriptor returned by socket().\n* addr - a pointer to a struct sockaddr that contains information about IP address and port number.\n* len - set to sizeof (struct sockaddr)\n\n<c>\nint connect (int sockfd, struct sockaddr *serv_addr, int addrlen);\n</c>\n* sockfd - the socket file descriptor returned by socket().\n* serv_addr - is a struct sockaddr containing the destination port and IP address.\n* addrlen - set to sizeof (struct sockaddr).\n\n<c>\nint listen (int sockfd,int backlog);\n</c>\n* sockfd - the socket file descriptor returned by socket().\n* backlog - the number of connections allowed on the incoming queue.\n* Backlog should never be zero as servers always expect connection from client.\n* The listen function converts an unconnected socket into a passive socket.\n* On successful execution of listen is indicating that the kernel should accept incoming connection requests directed to this socket.\n\n<c>\nint accept (int sockfd, void *addr, int *addrlen);\n</c>\n\nsockfd -  the socket file descriptor returned by socket().\naddr -  a pointer to a struct sockaddr_in. The information about the incoming connection like IP address and port number are stored.\naddrlen - a local integer variable that should be set to sizeof (struct\nsockaddr_in) before its address is passed to accept().\n\n<c>\nclose (sockfd);\n</c>\n* Close system call prevents any more reads and writes to the socket. For attempting to read or write the socket on the remote end will receive an error.\n\n\n<c>\nint shutdown (int sockfd, int how);\n</c>\nsockfd - socket file descriptor of the socket to be shutdown.\nhow - if it is\n 0 - Further receives are disallowed\n 1 - Further sends are disallowed\n 2 - Further sends and receives are disallowed.\nThe shutdown system call gives more control (than close (sockfd) over how the socket descriptor can be closed.\n\nTypical server code\n\n<c>\nstruct sockaddr_in serv, cli;\nsd = socket (AF_INET, SOCK_STREAM, 0);\nserv.sin_family = AF_INET;\nserv.sin_addr.s_addr = INADDR_ANY;\nserv.sin_port = htons (portno);\nbind (sd, &serv, sizeof (serv));\nlisten (sd, 5);\nnsd = accept (sd, &cli, &sizeof (cli));\nread / write (nsd, ....);\n</c>\n\nTypical Client code\n<c>\nstruct sockaddr_in serv;\nsd =socket(AF_INET,SOCK_STREM, 0);\nserv.sin_family = AF_INET;\nserv.sin_addr.s_addr = inet_addr("ser ip");\nserv.sin_port = htons (portno);\nconnect (sd, &server, sizeof (server));\nread / write (sd, ....);\n</c>\n\nIterative Server\nOne client request at a time.\n<c>\nnsd = accept (sd, &cli,...);\nwhile (1) {\nread/write(nsd, ...);\n}\n</c>\n\nConcurrent Server\nMany clients requests can be serviced concurrently\n<c>\nwhile (1) {\nnsd =(accept (sd, &cli, ....);\nif (!fork( )) {\nclose(sd);\nread/write(nsd, .....);\nexit();\n} else\nclose(nsd);\n}\n</c>\n\n/* This is a program which illustrates the concurrent server by creating a child process */\n<cs>\n#include<stdio.h>\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<netinet/in.h>\n#include<arpa/inet.h>\n#define MYPORT 1034\nmain()\n{\nint pid,sd,nsd,dat,yes=1;\nchar message[40];\nsocklen_t length;\nstruct sockaddr_in server,client;\n\nif((sd=socket(PF_INET,SOCK_STREAM,0))==-1) {\n perror("socket");\n exit(1);\n}\nserver.sin_port=htons(MYPORT);\nserver.sin_family=PF_INET;\nserver.sin_addr.s_addr=inet_addr("192.168.2.20");\n\t\nif(bind(sd,(struct sockaddr  *)&server,sizeof(server))==-1) {\n perror("bind");\n exit(1);\n}\nif(listen(sd,1)==-1) {\n perror("listen");\n exit(1);\n}\n\n/*A child process is created for accepting connections*/\nprintf("Waiting for connection.............\n");\npid=fork();\nwhile(1)\n{\n if(pid==0)\n {\n  if((nsd=accept(sd,(struct sockaddr *)&client,&length))==-1) {\n   perror("accept");\n   exit(1);\n  }\n  printf("Got connection from client:%s\n",inet_ntoa(client.sin_addr));\n  /*else fragment is the parent process taking care of send and receive to clients*/\n  if((dat=recv(nsd,message,40,0))==-1) {\n   perror("recv");\n   exit(1);\n  }\n  message[dat]=\'\\0\';\n  printf("Data received is : %s\n",message);\n  printf("Enter the data you want to send to client\n");\n  fgets(message,40,stdin);\n  send(nsd,message,40,0);\n }\t\n}\n//close(sd);\n}\n</cs>\n\n<h>\n*-UDP\n</h>\n\nClient and Server both has to use\n<c>\ninclude <sys/socket.h>\nssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags, const struct sockaddr *destaddr, socklen_t destlen);\nReturns: number of bytes sent if OK, -1 on error\n\n#include <sys/socket.h>\nssize_t recvfrom(int sockfd, void *restrict buf, size_t len, int flags, struct sockaddr *restrict addr, socklen_t *restrict addrlen);\n\nReturns: length of message in bytes, 0 if no messages are available and peer has done an orderly shutdown, or -1 on error\n</c>'
'12!ABS SBA!Network Programming!ABS SBA!!ABS SBA!<h>\n*TCP Server Client Programming\n</h>\n\nTcpclient\n\n<cc>\n#include<sys/socket.h>\n#include<sys/types.h>\n#include<netinet/in.h>\n#include<arpa/inet.h>\n#include<stdio.h>\n\n#define PORT 1034\n\nstruct sockaddr_in server;\nmain()\n{\nint n,sd,length;\nchar msg[40];\n//length=sizeof(client);\nif((sd=socket(PF_INET,SOCK_STREAM,0))==-1) {\n perror("socket");\n exit(1);\n}\nserver.sin_family=PF_INET;\nserver.sin_port=htons(PORT);\n//server.sin_addr.s_addr=inet_addr("192.168.1.2");\nserver.sin_addr.s_addr=inet_addr("127.0.0.1");\nif(connect(sd,(struct sockaddr *)&server,sizeof(server))==-1) {\n perror("connect");\n exit(1);\n}\n\nprintf("Enter the message you want to send to server\n");\nfgets(msg,40,stdin);\nsend(sd,msg,40,0);\nprintf("Waiting for message from server..............\n");\nn=recv(sd,msg,40,0);\nmsg[n]=\'\\0\';\n\nprintf("Message received from server is:%s\n",msg);\nclose(sd);\t\n}\n</cc>\nTcpserver\n\n<cc>\n#include<stdio.h>\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<netinet/in.h>\n#include<arpa/inet.h>\n#define MYPORT 1034\nmain()\n{\nint sd,pid,nsd,dat,yes=1;\nchar message[40];\nstruct sockaddr_in server,client;\nsocklen_t length;\nif((sd=socket(PF_INET,SOCK_STREAM,0))==-1) {\n perror("socket");\n exit(1);\n}\nserver.sin_port=htons(MYPORT);\nserver.sin_family=PF_INET;\n//server.sin_addr.s_addr=inet_addr("192.168.1.2");\nserver.sin_addr.s_addr=inet_addr("127.0.0.1");\n\n/*if(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int))==-1) {\n perror("setsockopt");\n exit(1);\n}*/\n\t\nif(bind(sd,(struct sockaddr  *)&server,sizeof(server))==-1) {\n perror("bind");\n exit(1);\n}\n\nif(listen(sd,5)==-1) {\n perror("listen");\n exit(1);\n}\nprintf("Waiting for connection.............\n");\nif((nsd=accept(sd,(struct sockaddr *)&client,&length))==-1) {\n perror("accept");\n exit(1);\n}\nprintf("Got connection from client:%s\n",inet_ntoa(client.sin_addr));\n\nif((dat=recv(nsd,message,40,0))==-1) {\n perror("recv");\n exit(1);\n}\nmessage[dat]=\'\\0\';\nprintf("Data received is : %s\n",message);\nprintf("Enter the data you want to send to client\n");\nfgets(message,40,stdin);\nsend(nsd,message,40,0);\n\t\t\nclose(sd);\n}\n</cc>\n\n\n<h>\n*UDP Server Client Programming\n</h>\n\nudpclient\n<cc>\n#include<sys/socket.h>\n#include<sys/types.h>\n#include<netinet/in.h>\n#include<arpa/inet.h>\n#include<stdio.h>\n#include <stdlib.h>\n#define PORT 1034\n\nmain()\n{\nint n,sd,length;\nchar msg[40];\nstruct sockaddr_in server,client;\nif((sd=socket(PF_INET,SOCK_DGRAM,0))==-1) {\n perror("socket");\n exit(1);\n}\n\nclient.sin_family=PF_INET;\nclient.sin_port=htons(PORT);\n//client.sin_addr.s_addr=inet_addr("192.168.1.2");\nclient.sin_addr.s_addr=inet_addr("127.0.0.1");\n\nprintf("Enter the message you want to send to server\n");\nfgets(msg,40,stdin);\nif(sendto(sd,msg,40,0,(struct sockaddr *)&client,sizeof(server))==-1) {\n perror("sendto");\n exit(1);\n}\nprintf("Waiting for message from server..............\n");\nlength=sizeof(client);\nn=recvfrom(sd,msg,40,0,(struct sockaddr *)&server,&length);\nmsg[n]=\'\\0\';\n\nprintf("Message received from server is:%s\n",msg);\n}\n</cc>\n\nudpserver\n<cc>\n#include<stdio.h>\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<netinet/in.h>\n#include<arpa/inet.h>\n#include<stdlib.h>\n#define MYPORT 1034\n\n\nmain()\n{\nint sd,nsd,dat,length,yes=1;\nchar message[40];\nstruct sockaddr_in server,client;\n\nif((sd=socket(PF_INET,SOCK_DGRAM,0))==-1) {\n perror("socket");\n exit(1);\n}\nserver.sin_port=htons(MYPORT);\nserver.sin_family=PF_INET;\n//server.sin_addr.s_addr=inet_addr("192.168.1.2");\nserver.sin_addr.s_addr=inet_addr("127.0.0.1");\n\n/*if(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int))==-1) {\n perror("setsockopt");\n exit(1);\n}*/\n\nif(bind(sd,(struct sockaddr  *)&server,sizeof(server))==-1) {\n perror("bind");\n exit(1);\n}\n\nlength=sizeof(client);\nif((dat=recvfrom(sd,message,40,0,(struct sockaddr *)&client,&length))==-1) {\n perror("recvfrom");\n exit(1);\n}\n\nprintf("Got connection from client:%s\n",inet_ntoa(client.sin_addr));\n\nmessage[dat]=\'\\0\';\n\nprintf("Data received is : %s\n",message);\nprintf("Enter the data you want to send to client\n");\nfgets(message,40,stdin);\nsendto(sd,message,40,0,(struct sockaddr *)&client,length);\n}\n</cc>\n\n\n<h>\n*UDP Server Cient Programming\n</h>\n\nnetlink - Communication between kernel and userspace (PF_NETLINK)\n\n<c>\n#include <asm/types.h>\n#include <sys/socket.h>\n#include <linux/netlink.h>\n\nnetlink_socket = socket(PF_NETLINK, socket_type, netlink_family);\n</c>\n\nNetlink is used to transfer information between kernel and userspace processes. It consists of a standard sockets-based interface for userspace processes and an internal kernel API for kernel modules.\n\nNetlink is a datagram-oriented service. Both SOCK_RAW and SOCK_DGRAM are valid values for socket_type. However, the netlink protocol does not distinguish between datagram and raw sockets.\n\nnetlink_family selects the kernel module or netlink group to communicate with. The currently assigned netlink families are:\n\n<c>NETLINK_ROUTE</c>\n Receives routing and link updates and may be used to modify the routing tables (both IPv4 and IPv6), IP addresses, link parameters, neighbour setups, queueing disciplines, traffic classes and packet classifiers\n\n<c>NETLINK_W1</c>\n Messages from 1-wire subsystem.\n\nExample creates a NETLINK_ROUTE netlink socket which will listen to the RTM-GRP_LINK (network interface create/delete/up/down events) and RTMGRP_IPV4_IFADDR (IPv4 addresses add/delete events) multicast groups.\n\n<c>\nstruct sockaddr_nl sa;\n\nmemset (&sa, 0, sizeof(sa));\nsnl.nl_family = AF_NETLINK;\nsnl.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;\n\nfd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\nbind(fd, (struct sockaddr*)&sa, sizeof(sa));\n</c>\n\nExample demonstrates how to send a netlink message to the kernel (pid 0). Note\nthat application must take care of message sequence numbers in order to reliably track acknowledgements.\n\n<c>\nstruct nlmsghdr *nh;    /* The nlmsghdr with payload to send. */\nstruct sockaddr_nl sa;\nstruct iovec iov = { (void *) nh, nh->nlmsg_len };\nstruct msghdr msg;\n\nmsg = { (void *)&sa, sizeof(sa), &iov, 1, NULL, 0, 0 };\nmemset (&sa, 0, sizeof(sa));\nsa.nl_family = AF_NETLINK;\nnh->nlmsg_pid = 0;\nnh->nlmsg_seq = ++sequence_number;\n/* Request an ack from kernel by setting NLM_F_ACK. */\nnh->nlmsg_flags |= NLM_F_ACK;\n\nsendmsg (fd, &msg, 0);\n</c>\n\nAnd the last example is about reading netlink message.\n\n<c>\nint len;\nchar buf[4096];\nstruct iovec iov = { buf, sizeof(buf) };\nstruct sockaddr_nl sa;\nstruct msghdr msg;\nstruct nlmsghdr *nh;\n\nmsg = { (void *)&sa, sizeof(sa), &iov, 1, NULL, 0, 0 };\nlen = recvmsg (fd, &msg, 0);\n\nfor (nh = (struct nlmsghdr *) buf; NLMSG_OK (nh, len);\nnh = NLMSG_NEXT (nh, len)) {\n/* The end of multipart message. */\nif (nh->nlmsg_type == NLMSG_DONE)\n return;\n\nif (nh->nlmsg_type == NLMSG_ERROR)\n/* Do some error handling. */\n...\n\n/* Continue with parsing payload. */\n...\n}\n</c>'
'13!ABS SBA!Programming and Debugging tools!ABS SBA!!ABS SBA!<h>\n*strace - Tracing system calls\n</h>\n\nTracing Processes\n* strace command\n - trace system calls and signals\n - strace runs until the given command exits\n - It is a useful tool for diagnostic, instructional and debugging\n* ptrace system call\n - Process trace\n\nStrace\n\n#strace -c -e trace=file mkfifo -m 0744 myfifo\n<c>\nexecve("/usr/bin/mkfifo", ["mkfifo", "-m", "0744", "myfifo"]) = 0\n\n\n% time seconds us/call calls syscall\n------ ----------- ----------- --------- --------- ----------------\n 47.62 0.000020               20        1         mknod\n 33.33 0.000014                4        4         open\n 11.90 0.000005                5        1         chmod\n  7.14 0.000003                1        3         fstat\n------ ----------- ----------- --------- --------- ----------------\n100.00 0.000042                          9\n</c>\n\n1. Trace the Execution of an Executable\n$  strace ls\n<c>\nexecve("/bin/ls", ["ls"], [/* 21 vars */]) = 0\nbrk(0)\naccess("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)\nmmap2(NULL, 8192, PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb78c7000\naccess("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)\nopen("/etc/ld.so.cache", O_RDONLY)      = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=65354, ...}) = 0\n...\n...\n</c>\n2. Trace a Specific System Calls in an Executable Using Option -e\n$ strace -e open ls\n<c>\nopen("/etc/ld.so.cache", O_RDONLY)      = 3\nopen("/lib/libselinux.so.1", O_RDONLY)  = 3\nopen("/lib/librt.so.1", O_RDONLY)       = 3\n\n\nopen("/lib/libacl.so.1", O_RDONLY)      = 3\nopen("/lib/libc.so.6", O_RDONLY)        = 3\nopen("/lib/libdl.so.2", O_RDONLY)       = 3\nopen("/lib/libpthread.so.0", O_RDONLY)  = 3\nopen("/lib/libattr.so.1", O_RDONLY)     = 3\nopen("/proc/filesystems", O_RDONLY|O_LARGEFILE) = 3\nopen("/usr/lib/locale/locale-archive", O_RDONLY|O_LARGEFILE) = 3\nopen(".", O_RDONLY|O_NONBLOCK|O_LARGEFILE|O_DIRECTORY|O_CLOEXEC) = 3\n</c>\n\n3. Execute Strace on a Running Linux Process Using Option -p\n$  strace -p 1725 -o output.txt\n<c>\nattach: ptrace(PTRACE_ATTACH, ...): Operation not permitted\nCould not attach to process.  If your uid matches the uid of the target\nprocess, check the setting of /proc/sys/kernel/yama/ptrace_scope, or try\nagain as the root user.  For more details, see /etc/sysctl.d/10-ptrace.conf\n</c>\n\n4. Print Relative Time for System Calls Using Option -r\n\nStrace also has the option to print the execution time for each system calls as shown below.\n\n$ strace -r ls\n<cc>\n0.000000 execve("/bin/ls", ["ls"], [/* 37 vars */]) = 0\n0.000846 brk(0)                    = 0x8418000\n0.000143 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)\n0.000163 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb787b000\n0.000119 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)\n0.000123 open("/etc/ld.so.cache", O_RDONLY) = 3\n0.000099 fstat64(3, {st_mode=S_IFREG|0644, st_size=67188, ...}) = 0\n0.000155 mmap2(NULL, 67188, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb786a000\n...\n</cc>\n\n<h>\n*ltrace - Tracing library calls\n</h>\n\nltrace\' is another Linux Utility similar to \'strace\'. However, ltrace lists all the library calls being called in an executable or a running process.\n\nThis tool is very useful for debugging user-space applications to determine which library call is failing.\n\nIt is also capable of receiving signals for segmentation faults, etc.\n\nAssume the code\n<c>\n1. #include <stdio.h>\n2.  #include <unistd.h>\n3..\n4.  int main()\n5.  {\n6.     FILE *fp = fopen("rfile.txt", "w+");\n7.     fprintf(fp+1, "Invalid Write\n");\n8.     fclose(fp);\n9.     return 0;\n10. }\n</c>\n\nLets compile and run it.\nCode:\n\nx@ubuntu:~/source$ gcc file.c -Wall -o file\nx@ubuntu:~/source$./file\n<c>\nSegmentation fault (core dumped)\n\nThat is a segmentation fault. Lets use ltrace to debug and see what is happening.\nCode:\n\nx@ubuntu:~/source$ltrace ./file\n __libc_start_main(0x8048454, 1, 0xbfc19db4, 0x80484c0, 0x8048530 <unfinished ...>\n fopen("rfile.txt", "w+")                          = 0x9160008\n fwrite("Invalid Write\n", 1, 14, 0x916009c <unfinished ...>\n --- SIGSEGV (Segmentation fault) ---\n +++ killed by SIGSEGV +++\n</c>\n\n<h>\n*Tools used to detect memory access\nerror; and memory leakage in linux\nmtrace\n</h>\n\nMtrace, memory trace. Follow the steps to use it\n\n1. Call mtrace() When Your Program Starts\n<c>\n#include <stdio.h>\n#include <stdlib.h>\n#include <mcheck.h>\nint main() {\n char *string;\n mtrace();\n string = malloc(100 * sizeof(char));\n return 0;\n}\n</c>\n\n2. Compile Program with Debugging Options\n$gcc -g -o mtrace_test mtrace_test.c\n\n3. Set MALLOC_TRACE\nFor bash\n<c>\nexport MALLOC_TRACE="mtrace.out"\n</c>\n\nFor C shell, it would be:\n<c>\nsetenv MALLOC_TRACE mtrace.out\n</c>\n4. Run The Program Once\n5. View The Data\nmtrace <prog name> <output log file name>\nmtrace mtrace_test mtrace.out\nAssuming the C code at the beginning was the code in mtrace_test.c, the following output would be produced:\n\n<c>\nMemory not freed:\n-----------------\n   Address     Size     Caller\n0x0000000000501460     0x64  at /array/home/dcurrie/test/mtrace/mtrace_test.c:11\n</c>\n\nValgrind\nFinding Memory Leaks With Valgrind\n\neample.c\n<c>\ninclude <stdlib.h>\nint main()\n{\n    char *x = malloc(100); /* or, in C++, "char *x = new char[100] */\n    x[10] = \'a\';\n    return 0;\n}\n</c>\n$gcc example.c -o example\n\n<c>\n$valgrind --tool=memcheck --leak-check=yes example\n==2116== 100 bytes in 1 blocks are definitely lost in loss record 1 of 1\n==2116==    at 0x1B900DD0: malloc (vg_replace_malloc.c:131)\n==2116==    by 0x804840F: main (in /home/cprogram/example1)\n</c>\n\nFinding Invalid Pointer Use With Valgrind\nvalgrind --tool=memcheck --leak-check=yes example\n\nresults in the following warning\n\n<c>\n==9814==  Invalid write of size 1\n==9814==    at 0x804841E: main (example2.c:6)\n==9814==  Address 0x1BA3607A is 0 bytes after a block of size 10 alloc\'d\n==9814==    at 0x1B900DD0: malloc (vg_replace_malloc.c:131)\n==9814==    by 0x804840F: main (example2.c:5)\n</c>'
'14!ABS SBA!Device Driver Introduction!ABS SBA!!ABS SBA!<h>\n*Introduction\n</h>\n\n<h>\n*Kernel modules\n</h>\n\n<h>\n*Character device drivers\n</h>\n\n<h>\n*Block device drivers\n</h>\n\n<h>\n*Hardware and Interrupt Handling\n</h>'
'31!ABS SBA!title!ABS SBA!None!ABS SBA!Linux Internals Training'
'32!ABS SBA!subtitle!ABS SBA!None!ABS SBA!5-day session'
'33!ABS SBA!h_Overview!ABS SBA!None!ABS SBA!Understanding Virtual memory, Process concepts, IPC, File Systems EXT2\nUnderstanding Shell programming\nUnderstanding Boot process\nUnderstanding cross compilation and installing Linux installation on\nembedded hardware\nUnderstanding developing application for embedded systems'
'34!ABS SBA!h_Duration!ABS SBA!None!ABS SBA!Five days - 40 hours (8hours a day)\n50% of lecture, 50% of practical labs.'
'35!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'36!ABS SBA!h_Trainer!ABS SBA!None!ABS SBA!<a href="https://www.linkedin.com/in/pravinkumarsinha">http://www.linkedin.com/in/pravinkumarsinha</a>'
'37!ABS SBA!h_Audience!ABS SBA!None!ABS SBA!Professional Software developers\nPeople supporting embedded and medium scale products.'
'38!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'39!ABS SBA!h_Prerequisite!ABS SBA!None!ABS SBA!<b>Knowledge of c programming</b>\nAll examples are provided through c programming language.\nKnowledge of c programming is required.\nC training slides can browsed at\n<a href=http://minhinc.42web.io/training/c/advance-c-slides.php>http://minhinc.42web.io/training/c/advance-c-slides.php</a>\n\nPdf document can be downloaded from\n<a href=http://minhinc.42web.io/training/advance-c-slides.pdf>http://minhinc.42web.io/training/advance-c-slides.pdf</a>'
'40!ABS SBA!h_Setup!ABS SBA!None!ABS SBA!Ubuntu 16.0x LTS\nRaspberry Pi3'
'41!ABS SBA!h2_Lecture!ABS SBA!None!ABS SBA!Lecture session will be course content presentation through the trainer.\nAny source code example related to the topic will be demonstrated, it would\ninclude executing the binaries. Complete lecture material can be downloaded from\n<a href="http://minhinc.42web.io/training/advance-li-slides.pdf">http://minhinc.42web.io/training/advance-li-slides.pdf</a>'
'42!ABS SBA!h2_Labs!ABS SBA!None!ABS SBA!Lecture session will be course content presentation through the trainer.\nAny source code example related to the topic will be demonstrated, it would\ninclude executing the binaries.'
      linkvisited      
      message      
'1!ABS SBA!email added without sign up:'
'2!ABS SBA!emails not personalized and customized:'
'3!ABS SBA!emails too frequent:'
'4!ABS SBA!others...:too may email and often and irrelevant.'
'5!ABS SBA!others...:'
'6!ABS SBA!others...:junk'
'7!ABS SBA!None'
'8!ABS SBA!None'
'9!ABS SBA!None'
'10!ABS SBA!None'
'11!ABS SBA!None'
'12!ABS SBA!None'
'13!ABS SBA!None'
'14!ABS SBA!None'
'15!ABS SBA!None'
'16!ABS SBA!None'
'17!ABS SBA!None'
'18!ABS SBA!None'
'19!ABS SBA!None'
'20!ABS SBA!None'
'21!ABS SBA!None'
'22!ABS SBA!None'
'23!ABS SBA!None'
'24!ABS SBA!None'
'25!ABS SBA!None'
'26!ABS SBA!None'
'27!ABS SBA!None'
'28!ABS SBA!None'
'29!ABS SBA!None'
'30!ABS SBA!None'
'31!ABS SBA!None'
'32!ABS SBA!None'
'33!ABS SBA!None'
'34!ABS SBA!None'
'35!ABS SBA!None'
'36!ABS SBA!None'
'37!ABS SBA!None'
'38!ABS SBA!None'
'39!ABS SBA!None'
'40!ABS SBA!None'
'41!ABS SBA!None'
'42!ABS SBA!None'
'43!ABS SBA!None'
      py      
'1!ABS SBA!Basic structure of Python program!ABS SBA!*Installing Python\n*Writing simple python program\n*Executing program on command shell\n*Executing program through interpreter!ABS SBA!<h>\n*Python Interpreter\n</h>\nPython is an interperative language. Python scripts are interpreted through python interpreter binary. On linux, path of python interpreter is /usr/bin/python<version>. For python3.8 it would be /usr/bin/python3.8\n\n<c>\nminhinc@minhinc:~/tmp$ ls -la /usr/bin | grep -i python3\nlrwxrwxrwx  1 root root          56 Jan  5 10:52 apt-changelog -> ../lib/python3/dist-packages/mintcommon/apt_changelog.py\n-rwxr-xr-x  1 root root        2336 Jun 20  2017 dh_python3-ply\nlrwxrwxrwx  1 root root          23 Jan 27 21:11 pdb3.8 -> ../lib/python3.8/pdb.py\nlrwxrwxrwx  1 root root          31 Jan  5 10:53 py3versions -> ../share/python3/py3versions.py\nlrwxrwxrwx  1 root root           9 Jan  5 10:53 python3 -> python3.8\n-rwxr-xr-x  1 root root     5486384 Jan 27 21:11 python3.8\nlrwxrwxrwx  1 root root          33 Jan 27 21:11 python3.8-config -> x86_64-linux-gnu-python3.8-config\nlrwxrwxrwx  1 root root          16 Mar 13  2020 python3-config -> python3.8-config\n-rwxr-xr-x  1 root root        3240 Jan 27 21:11 x86_64-linux-gnu-python3.8-config\nlrwxrwxrwx  1 root root          33 Mar 13  2020 x86_64-linux-gnu-python3-config -> x86_64-linux-gnu-python3.8-config\n</c>\n\n<h>\n*Interactive Mode\n</h>\nPython interpreter can run in interactive mode. It provides command prompt <c>>>></c> and <c>...</c>. <c>>>></c> prompts for python command where as three dots <c>...</c> is for multiline statements.\n\n<c>\nminhinc@minhinc:~/tmp/$ python3\nPython 3.8.5 (default, Jan 27 2021, 15:41:15) \n[GCC 9.3.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>> class A:\n...  pass\n... \n>>> a=b=A()\n>>> print(a is b)\nTrue\n>>> quit()\n</c>\nWhen multiline statements are over, \'Enter\' key needs to be pressed.\n\nCommands can be entered through \'-c\' option on python interpretor. <c>python3 -c \'print(<r>"hello world"</r>)\'</c> would print <r>"hello world"</r>. Above code can be written as\n<c>\nminhinc@minhinc:~/tmp$ python3 -c "exec(\'class A:\\n pass\\na=b=A()\\nprint(a is b)\')"\nTrue\n</c>\n\n<h>\n*Scripting mode\n</h>\nPython programs can be written in a module. Module can be called as <c>python3 -m <modulename></c>. If module name is helloworld.py then it can be called as <c>python3 -m helloworld</c>. <G>helloworld.py</g> module must be in PYTHONPATH or sys.path. \n\nmodule can also be executed as script <c>python3 <scriptname></c>. Here it would be <c>python3 helloworld.py</c>. In this case full path must be given.\n\n<c>\nminhinc@minhinc:~/tmp$ cat helloworld.py \ndef func():\n print(\'hello world\')\n\nfunc()\nminhinc@minhinc:~/tmp$ python3 -m helloworld\nhello world\nminhinc@minhinc:~/tmp$ cd ..\nminhinc@minhinc:~$ export PYTHONPATH=~/tmp:$PYTHONPATH\nminhinc@minhinc:~$ python3 -m helloworld\nhello world\nminhinc@minhinc:~$ python3 tmp/helloworld.py \nhello world\n</c>\n\nPython3 interpretor can also be invoked through argument \'-i\', interactive mode. This would execute the module or script and enter into interactive mode. More commands can be executed against the module/script afterwards.\n\n<c>\nminhinc@minhinc:~/tmp$ cat helloworld.py \ndef func():\n print(\'hello world\')\n\nfunc()\nminhinc@minhinc:~$ python3 -i tmp/helloworld.py \nhello world\n>>> func()\nhello world\nminhinc@minhinc:~/tmp$ python3 -i -m helloworld\nhello world\n>>> func()\nhello world\n>>> quit()\n</c>\n\n<h>\n*Main module\n</h>\nIn interactive mode python3 executes main module. All code written belongs to main module. Module namespace contains \'__name__\' key which has value of \'__main__\'\n\n<c>\nminhinc@minhinc:~/tmp$ python3\nPython 3.8.5 (default, Jan 27 2021, 15:41:15) \n[GCC 9.3.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>> dir()\n[\'__annotations__\', \'__builtins__\', \'__doc__\', \'__loader__\', \'__name__\', \'__package__\', \'__spec__\']\n>>> __name__\n\'__main__\'\n>>> quit()\nminhinc@minhinc:~/tmp$ python3 -c \'print(__name__)\'\n__main__\nminhinc@minhinc:~/tmp$ python3 -i -c \'print(__name__)\'\n__main__\n>>> dir()\n[\'__annotations__\', \'__builtins__\', \'__doc__\', \'__loader__\', \'__name__\', \'__package__\', \'__spec__\']\n</c>\n\nModule or script that runs directly through python3 interpreter in scripting mode is main module. when interpreter runs with argument <c>-i</c> then module or script runs as main module.\n\n<c>\nminhinc@minhinc:~/tmp$ cat helloworld.py \ndef func():\n print(\'hello world\')\n\nfunc()\nprint(\'__name__ is\',__name__)\nminhinc@minhinc:~/tmp$ python3 -i -m helloworld\nhello world\n__name__ is __main__\n>>> dir()\n[\'__annotations__\', \'__builtins__\', \'__cached__\', \'__doc__\', \'__file__\', \'__loader__\', \'__name__\', \'__package__\', \'__spec__\', \'func\']\n>>> __name__\n\'__main__\'\n>>> quit()\nminhinc@minhinc:~/tmp$ python3 -i helloworld.py\nhello world\n__name__ is __main__\n>>> dir()\n[\'__annotations__\', \'__builtins__\', \'__doc__\', \'__loader__\', \'__name__\', \'__package__\', \'__spec__\', \'func\']\n>>> __name__\n\'__main__\'\n</c>\n\n<h>\n*Library modules\n</h>\npython interpreter import \'builtins\' module when \'main\' module loads.\n<c>\nfrom builtins import *\n</c>\nbuilt types are imported in this fashion,i.e exceptions, string, int, tuple, list, dict, bool,classmethod,staticmethodl etc.\n<c>\nminhinc@minhinc:~/tmp/MISC/gc$ python3\nPython 3.8.5 (default, May 27 2021, 13:30:53) \n[GCC 9.3.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>> import builtins\n>>> dir(builtins)\n</c>\n<cc>\n[\'ArithmeticError\', \'AssertionError\', \'AttributeError\', \'BaseException\', \'BlockingIOError\', \'BrokenPipeError\', \'BufferError\', \'BytesWarning\', \'ChildProcessError\', \'ConnectionAbortedError\', \'ConnectionError\', \'ConnectionRefusedError\', \'ConnectionResetError\', \'DeprecationWarning\', \'EOFError\', \'Ellipsis\', \'EnvironmentError\', \'Exception\', \'False\', \'FileExistsError\', \'FileNotFoundError\', \'FloatingPointError\', \'FutureWarning\', \'GeneratorExit\', \'IOError\', \'ImportError\', \'ImportWarning\', \'IndentationError\', \'IndexError\', \'InterruptedError\', \'IsADirectoryError\', \'KeyError\', \'KeyboardInterrupt\', \'LookupError\', \'MemoryError\', \'ModuleNotFoundError\', \'NameError\', \'None\', \'NotADirectoryError\', \'NotImplemented\', \'NotImplementedError\', \'OSError\', \'OverflowError\', \'PendingDeprecationWarning\', \'PermissionError\', \'ProcessLookupError\', \'RecursionError\', \'ReferenceError\', \'ResourceWarning\', \'RuntimeError\', \'RuntimeWarning\', \'StopAsyncIteration\', \'StopIteration\', \'SyntaxError\', \'SyntaxWarning\', \'SystemError\', \'SystemExit\', \'TabError\', \'TimeoutError\', \'True\', \'TypeError\', \'UnboundLocalError\', \'UnicodeDecodeError\', \'UnicodeEncodeError\', \'UnicodeError\', \'UnicodeTranslateError\', \'UnicodeWarning\', \'UserWarning\', \'ValueError\', \'Warning\', \'ZeroDivisionError\', \'__build_class__\', \'__debug__\', \'__doc__\', \'__import__\', \'__loader__\', \'__name__\', \'__package__\', \'__spec__\', \'abs\', \'all\', \'any\', \'ascii\', \'bin\', \'bool\', \'breakpoint\', \'bytearray\', \'bytes\', \'callable\', \'chr\', \'classmethod\', \'compile\', \'complex\', \'copyright\', \'credits\', \'delattr\', \'dict\', \'dir\', \'divmod\', \'enumerate\', \'eval\', \'exec\', \'exit\', \'filter\', \'float\', \'format\', \'frozenset\', \'getattr\', \'globals\', \'hasattr\', \'hash\', \'help\', \'hex\', \'id\', \'input\', \'int\', \'isinstance\', \'issubclass\', \'iter\', \'len\', \'license\', \'list\', \'locals\', \'map\', \'max\', \'memoryview\', \'min\', \'next\', \'object\', \'oct\', \'open\', \'ord\', \'pow\', \'print\', \'property\', \'quit\', \'range\', \'repr\', \'reversed\', \'round\', \'set\', \'setattr\', \'slice\', \'sorted\', \'staticmethod\', \'str\', \'sum\', \'super\', \'tuple\', \'type\', \'vars\', \'zip\']\n</cc>\nmodule package information like package installation path are provided through __spec__ key in the namespace\n<c>\nimport PySide6\n>>> PySide6.__spec__\nModuleSpec(name=\'PySide6\', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7f3d524955b0>, origin=\'/usr/local/lib/python3.8/dist-packages/PySide6/__init__.py\', submodule_search_locations=[\'/usr/local/lib/python3.8/dist-packages/PySide6\'])\n</c>\npython interpreter provide help service where list of library modules, keywords, symbols and topics can be listed.\n<c>\nminhinc@minhinc:~/tmp/MISC/gc$ python3\nPython 3.8.5 (default, May 27 2021, 13:30:53) \n[GCC 9.3.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>> help()\n\nWelcome to Python 3.8\'s help utility!\n\nIf this is your first time using Python, you should definitely check out\nthe tutorial on the Internet at https://docs.python.org/3.8/tutorial/.\n\nEnter the name of any module, keyword, or topic to get help on writing\nPython programs and using Python modules.  To quit this help utility and\nreturn to the interpreter, just type "quit".\n\nTo get a list of available modules, keywords, symbols, or topics, type\n"modules", "keywords", "symbols", or "topics".  Each module also comes\nwith a one-line summary of what it does; to list the modules whose name\nor summary contain a given string such as "spam", type "modules spam".\n\nhelp> modules\n\nPlease wait a moment while I gather a list of all available modules...\n</c>\n<cc>\nAppearance          _version            enum                pylab\nAptUrl              _warnings           errno               pylint\nAtspiStateTracker   _weakref            fasteners           pymacaroons\nAutoHide            _weakrefset         faulthandler        pyparsing\nAutoShow            _xxsubinterpreters  fcntl               pyphen\nClickSimulator      _xxtestfuzz         fetchm              pypredict\nCommandNotFound     _yaml               filecmp             pyrfc3339\nConfig              abc                 fileinput           pytz\nConfigUtils         agenda              fnmatch             queue\nCrypto              aifc                formatter           quopri\nDBusUtils           antigravity         fractions           random\nExceptions          apiclient           ftplib              re\nGlobalKeyListener   apport              functools           read\nHardwareSensorTracker apport_python_hook  gc                  readline\nIconPalette         apt                 genericpath         redshift_gtk\nIndicator           apt_clone           getconsole          reportlab\nKbdWindow           apt_inst            getcontactm         reprlib\nKeyCommon           apt_pkg             getopt              requests\nKeyGtk              aptdaemon           getpass             requests_unixsocket\nKeyboard            aptsources          gettext             resource\nKeyboardPopups      argparse            gi                  rlcompleter\nKeyboardWidget      array               glob                rsa\nLanguageSupport     ast                 google_auth_httplib2 runpy\nLayout              astroid             googleapiclient     samba\nLayoutLoaderSVG     asynchat            grp                 scanext\nLayoutView          asyncio             grpc                sched\nMySQLdb             asyncore            gzip                secrets\nNvidiaDetector      atexit              hashlib             secretstorage\nOnboard             audioop             heapq               seed\nOnboardGtk          base64              hmac                select\nOpenSSL             bdb                 hpmudext            selectors\nPAM                 binascii            html                selenium\nPIL                 binhex              html5lib            sendmailm\nPyICU               bisect              http                setproctitle\nPyQt5               blinker             httplib2            settings\nPySide6             brain_argparse      icu                 setuptools\nQuirks              brain_attrs         idna                shelve\nScanner             brain_builtin_inference ifaddr              shiboken6\nSnippetView         brain_collections   imaplib             shlex\nSound               brain_crypt         imghdr              shutil\nSpellChecker        brain_curses        imp                 signal\nTextChanges         brain_dataclasses   importlib           simplejson\nTextContext         brain_dateutil      inspect             sip\nTextDomain          brain_fstrings      io                  sipconfig\nTimer               brain_functools     ipaddr              sipconfig_nd8\nTouchHandles        brain_gi            ipaddress           site\nTouchInput          brain_hashlib       isort               sitecustomize\nUDevTracker         brain_http          itertools           six\nUbuntuDrivers       brain_io            json                smtpd\nVersion             brain_mechanize     jwt                 smtplib\nWPEngine            brain_multiprocessing kazam               sndhdr\nWindowUtils         brain_namedtuple_enum keyring             socket\nWordSuggestions     brain_nose          keyword             socketserver\nXInput              brain_numpy_core_fromnumeric kiwisolver          soupsieve\nXlib                brain_numpy_core_function_base launchpadlib        speechd\n__future__          brain_numpy_core_multiarray lazy_object_proxy   speechd_config\n_abc                brain_numpy_core_numeric ldb                 spwd\n_ast                brain_numpy_core_numerictypes lib2to3             sqlalchemy\n_asyncio            brain_numpy_core_umath linecache           sqlite3\n_bisect             brain_numpy_ndarray listwidgetm         sre_compile\n_blake2             brain_numpy_random_mtrand locale              sre_constants\n_bootlocale         brain_numpy_utils   lockfile            sre_parse\n_bz2                brain_pkg_resources logging             ssl\n_cffi_backend       brain_pytest        louis               stat\n_codecs             brain_qt            lsb_release         statistics\n_codecs_cn          brain_random        lxml                string\n_codecs_hk          brain_re            lzma                stringprep\n_codecs_iso2022     brain_six           macaroonbakery      struct\n_codecs_jp          brain_ssl           mailbox             subprocess\n_codecs_kr          brain_subprocess    mailcap             sunau\n_codecs_tw          brain_threading     mako                symbol\n_collections        brain_typing        markupsafe          symtable\n_collections_abc    brain_uuid          marshal             sys\n_compat_pickle      brlapi              math                sysconfig\n_compression        bs4                 matplotlib          syslog\n_contextvars        builtins            mccabe              systemd\n_crypt              bz2                 mimetypes           t\n_csv                cProfile            mintcommon          t1\n_ctypes             cachecontrol        mintreport          tabnanny\n_ctypes_test        cachetools          mmap                talloc\n_curses             cairo               modulefinder        tarfile\n_curses_panel       cairocffi           monotonic           tdb\n_datetime           cairosvg            mpl_toolkits        telnetlib\n_dbm                calendar            msgpack             tempfile\n_dbus_bindings      canonical_equivalents multiprocessing     termios\n_dbus_glib_bindings caribou             nacl                test\n_decimal            certifi             netifaces           textwrap\n_dummy_thread       cffi                netrc               this\n_elementtree        cgi                 nis                 threading\n_functools          cgitb               nntplib             time\n_gdbm               chainm              nose                timeit\n_hashlib            chardet             ntpath              tinycss2\n_heapq              chunk               nturl2path          tkinter\n_icu                click               numbers             token\n_imp                cmath               numpy               tokenize\n_io                 cmd                 oauth2client        toml\n_json               code                oauthlib            trace\n_ldb_text           codecs              opcode              traceback\n_locale             codeop              operator            tracemalloc\n_lsprof             collections         optparse            tt\n_lzma               colorama            orca                tty\n_markupbase         colorsys            os                  turtle\n_md5                compileall          osk                 tw\n_multibytecodec     concurrent          ossaudiodev         types\n_multiprocessing    configobj           packaging           typing\n_opcode             configparser        parser              uaclient\n_operator           contextlib          parted              ufw\n_osx_support        contextvars         pathlib             unicodedata\n_ped                copy                pcardext            unidecode\n_pickle             copyreg             pdb                 unittest\n_posixshmem         crypt               pdfkit              uno\n_posixsubprocess    cryptography        pep517              unohelper\n_py_abc             cssselect2          pexpect             uritemplate\n_pydecimal          csv                 pickle              urllib\n_pyio               ctypes              pickletools         urllib3\n_queue              cups                pip                 utils\n_random             cupsext             pipes               uu\n_sha1               cupshelpers         pkg_resources       uuid\n_sha256             curl                pkgutil             validate\n_sha3               curses              platform            venv\n_sha512             cycler              plistlib            wadllib\n_signal             databasem           ply                 warnings\n_sitebuiltins       dataclasses         poplib              wave\n_socket             datetime            posix               weakref\n_sqlite3            dateutil            posixpath           weasyprint\n_sre                dbm                 pprint              webbrowser\n_ssl                dbpushpullm         problem_report      webencodings\n_stat               dbus                profile             wheel\n_statistics         deb822              progress            widgetm\n_string             debian              pstats              wrapt\n_strptime           debian_bundle       psutil              wsgiref\n_struct             decimal             pty                 xapp\n_symtable           defer               ptyprocess          xcffib\n_sysconfigdata__linux_x86_64-linux-gnu definitions         pwd                 xdg\n_sysconfigdata__x86_64-linux-gnu defusedxml          py_compile          xdrlib\n_tdb_text           difflib             pyasn1              xkit\n_testbuffer         dis                 pyasn1_modules      xml\n_testcapi           distlib             pyatspi             xmlrpc\n_testimportmultiple distro              pyclbr              xxlimited\n_testinternalcapi   distutils           pycparser           xxsubtype\n_testmultiphase     doctest             pycurl              yaml\n_thread             dummy_threading     pydoc               zeroconf\n_threading_local    easy_install        pydoc_data          zipapp\n_tkinter            email               pyexpat             zipfile\n_tracemalloc        encodings           pygtkcompat         zipimport\n_uuid               entrypoints         pyinotify           zlib\n</cc>\n<c>\nEnter any module name to get more help.  Or, type "modules spam" to search\nfor modules whose name or summary contain the string "spam".\n\nhelp> keywords\n\nHere is a list of the Python keywords.  Enter any keyword to get more help.\n\nFalse               class               from                or\nNone                continue            global              pass\nTrue                def                 if                  raise\nand                 del                 import              return\nas                  elif                in                  try\nassert              else                is                  while\nasync               except              lambda              with\nawait               finally             nonlocal            yield\nbreak               for                 not                 \n\nhelp> symbols\n\nHere is a list of the punctuation symbols which Python assigns special meaning\nto. Enter any symbol to get more help.\n\n!=                  +                   <=                  __\n"                   +=                  <>                  `\n"""                 ,                   ==                  b"\n%                   -                   >                   b\'\n%=                  -=                  >=                  f"\n&                   .                   >>                  f\'\n&=                  ...                 >>=                 j\n\'                   /                   @                   r"\n\'\'\'                 //                  J                   r\'\n(                   //=                 [                   u"\n)                   /=                  \\                   u\'\n*                   :                   ]                   |\n**                  <                   ^                   |=\n**=                 <<                  ^=                  ~\n*=                  <<=                 _                   \n\nhelp> topics\n\nHere is a list of available topics.  Enter any topic name to get more help.\n</c>\n<cc>\nASSERTION           DELETION            LOOPING             SHIFTING\nASSIGNMENT          DICTIONARIES        MAPPINGMETHODS      SLICINGS\nATTRIBUTEMETHODS    DICTIONARYLITERALS  MAPPINGS            SPECIALATTRIBUTES\nATTRIBUTES          DYNAMICFEATURES     METHODS             SPECIALIDENTIFIERS\nAUGMENTEDASSIGNMENT ELLIPSIS            MODULES             SPECIALMETHODS\nBASICMETHODS        EXCEPTIONS          NAMESPACES          STRINGMETHODS\nBINARY              EXECUTION           NONE                STRINGS\nBITWISE             EXPRESSIONS         NUMBERMETHODS       SUBSCRIPTS\nBOOLEAN             FLOAT               NUMBERS             TRACEBACKS\nCALLABLEMETHODS     FORMATTING          OBJECTS             TRUTHVALUE\nCALLS               FRAMEOBJECTS        OPERATORS           TUPLELITERALS\nCLASSES             FRAMES              PACKAGES            TUPLES\nCODEOBJECTS         FUNCTIONS           POWER               TYPEOBJECTS\nCOMPARISON          IDENTIFIERS         PRECEDENCE          TYPES\nCOMPLEX             IMPORTING           PRIVATENAMES        UNARY\nCONDITIONAL         INTEGER             RETURNING           UNICODE\nCONTEXTMANAGERS     LISTLITERALS        SCOPING             \nCONVERSIONS         LISTS               SEQUENCEMETHODS     \nDEBUGGING           LITERALS            SEQUENCES           \n</cc>\n\n<h>\n*Various namespaces scope\n</h>\n<d> namespace\nPython runs only main script/module. All modules initialized recursively is based on modules imported in main script. One module gets initialized/loaded only once. Everything in python is object which leads to formation of namespace/dictionary. each name/variable defined, belongs to a certain namespace. it can be module, class or function namespace.\n<cb>\nfrom tkinter import Widget\ni=10\nj=10\nclass A:\n ca=20\n def func(arg1):\n  global i;\n  la=j\n  def func1(arg2):\n   nonlocal la\n   print(\'nested function,globals -> {} locals -> {}\'.format(globals(),locals()))\n  func1(40)\n  print(\'globals -> {} locals -> {}\'.format(globals(),locals()))\n</cb>\n<c>\n>>> A.func(20)  <l><--- func is name in A namespace</l>\nnested function,globals -> {\'__name__\': \'__main__\', \'__doc__\': None, \'__package__\': None, \'__loader__\': <class \'_frozen_importlib.BuiltinImporter\'>, \'__spec__\': None, \'__annotations__\': {}, \'__builtins__\': <module \'builtins\' (built-in)>, \'Widget\': <class \'tkinter.Widget\'>, \'i\': 10, \'j\': 10, \'A\': <class \'__main__.A\'>} locals -> {\'arg2\': 40, \'la\': 10}\nglobals -> {\'__name__\': \'__main__\', \'__doc__\': None, \'__package__\': None, \'__loader__\': <class \'_frozen_importlib.BuiltinImporter\'>, \'__spec__\': None, \'__annotations__\': {}, \'__builtins__\': <module \'builtins\' (built-in)>, \'Widget\': <class \'tkinter.Widget\'>, \'i\': 10, \'j\': 10, \'A\': <class \'__main__.A\'>} locals -> {\'arg1\': 20, \'func1\': <function A.func.<locals>.func1 at 0x7f114d5cb3a0>, \'la\': 10}\n>>> A.__dict__  <l><---- ca,func is name in A namespace</l>\nmappingproxy({\'__module__\': \'__main__\', \'ca\': 20, \'func\': <function A.func at 0x7f114cdeca60>, \'__dict__\': <attribute \'__dict__\' of \'A\' objects>, \'__weakref__\': <attribute \'__weakref__\' of \'A\' objects>, \'__doc__\': None})\n\n>>> A.func.__dict__  <l><--- A.func namespace is empty</l>\n{}\n>>> globals()   <l><--- Widget,i,j,A names in global namespace </l>\n{\'__name__\': \'__main__\', \'__doc__\': None, \'__package__\': None, \'__loader__\': <class \'_frozen_importlib.BuiltinImporter\'>, \'__spec__\': None, \'__annotations__\': {}, \'<r>__builtins__</r>\': <module \'builtins\' (built-in)>, \'<r>Widget</r>\': <class \'tkinter.Widget\'>, \'<r>i</r>\': 10, \'<r>j</r>\': 10, \'<r>A</r>\': <class \'__main__.A\'>}\n\n>>> globals()[\'A\'].__dict__  # <l><---- A is name in global namespace </l>\nmappingproxy({\'__module__\': \'__main__\', \'ca\': 20, \'func\': <function A.func at 0x7f114cdeca60>, \'__dict__\': <attribute \'__dict__\' of \'A\' objects>, \'__weakref__\': <attribute \'__weakref__\' of \'A\' objects>, \'__doc__\': None})\n</c>\n\n\nmodule namespace is also known as global namespace. global variable and imported modules are names in global/module namespace. \n\n<d> scope\n a variable/name is defined and bind to a namespace where as non bound variables which are non explictly scoped are indentified in a block or scope. a variable that is not bind to a namesapce is searched in a local block (if it is not explicitly namescoped by global,nonlocal) if not found then it is searched in global namespace and then in builtins namespace.\n<c>\ni=10\nj=20\nclass A:\n c=10\n def func():\n  global j #<l><-- explictly global namespace binding is mentioned</l>\n  x=10 \n  print(x,i,j,A.c) #<l><--- A.c is class namespace scoped </l>\n        ^ ^ ^ ^\n        | | | |\n        | | | +----- c is expicitly  declared bound to class A namespace\n        | | +---- j is explicitly delclared bound to global namespace\n        | +----- \'free variable\' as not found in local block/scope\n        +----- x found in local block\n</c>\n if a name not found at all then \'NameError\' is raises. if a variable is assigned in a scope inside a local scope of a function namespace and variable accessed in local scoped when variable couldnot be defined in scope inside local scope of function then UnboundLocalError (subclass of NameError) is raised.\n<c>\nminhinc@minhinc:~/tmp/MISC/ffmpeg$ python3\nPython 3.8.5 (default, May 27 2021, 13:30:53) \n[GCC 9.3.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>> def func():\n...  return i\n... \n>>> func()\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\n  File "<stdin>", line 2, in func\nNameError: name \'i\' is not defined\n>>> def func(j):\n...  if j:\n...   i=10\n...  return i\n... \n>>> func(0)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\n  File "<stdin>", line 4, in func\nUnboundLocalError: local variable \'i\' referenced before assignment\n</c>\n<c>\n\n\'x\' and \'i\' name in function block/scope \'func()\' is searched in local function scope as name binding is not specified. \'j\' and A.c are namescoped so they would not be searched in function local scope. names not explicitly namescoped and not found in local block is declared \'free variables\'. here \'i\' is free name. if name is not found in local block it is then searched in global scope (not in class scope) and then in builtin module namespace.\n\n<h>\n*Python Identifiers\n</h>\nIdentifiers are variables names, it can be class name, function name or any other variable names. It is generally in ASCII range (U+0001..U+007F). Identifiers can include uppercase lowercase letters, decimal numbers and underscrores. \n\n<c>\n      +--------- class identifier\n      |\n      v\nclass A:\n pass\na=A()\n^\n|\n+---- instance object identifier\n</c>\n\nFollowing keywords can not be used as identifiers\n<c>\n   False      await      else       import     pass\n   None       break      except     in         raise\n   True       class      finally    is         return\n   and        continue   for        lambda     try\n   as         def        from       nonlocal   while\n   assert     del        global     not        with\n   async      elif       if         or         yield\n</c>\n\nFollowing letter(s) have special meanings\n <d2> "_*" \n "_" stores the previous arithmetic calculation results when script runs in interactive mode. "_" is available in builtins module. If not in interactive mode this identifier has no special meaning. There are chances when script runs both in scripting mode and interactive mode together,i.e. debugging the script \'python3 -i <scriptname>\')\n<c>\nminhinc@minhinc:~/tmp$ python3\nPython 3.8.5 (default, May 27 2021, 13:30:53) \n[GCC 9.3.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>> i=10;j=20\n>>> i*j\n200\n>>> 100+_\n300\n</c>\n <d2> "__*__"\n System-defined names and also known by \'dunder\' names. These names should be avoided and if used then should be proper documented.\n<c>\nminhinc@minhinc:~/tmp$ python3\nPython 3.8.5 (default, May 27 2021, 13:30:53) \n[GCC 9.3.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>> dir()\n[\'__annotations__\', \'__builtins__\', \'__doc__\', \'__loader__\', \'__name__\', \'__package__\', \'__spec__\']\n</c>\n\n <d2> "__*"\n class private names. Compiler modifies the identifiers by prepending \'_<classname>\' tag.\n<c>\nclass A:\n __ca_=10\n def __init__(self):\n  self.__ma_=20\n  self.__ca_=40\n</c>\n<cb>\n>>> A._A__ca_\n10\n>>> a=A()\n>>> a._A__ca_\n40\n>>> a._A__ma_\n20\n</cb>\n\n<R>See also</R> <n><a href="http://minhinc.42web.io/training/py/advance-py-slides.php?chap=9#chap9_2"><L>public private attributes</L></a></n>\n\n<h>\n*Lines and indentation\n</h>\nLine indentation in python is mandatory. Every statement code block must be atleast one space right to its expression.\n\n<c>\ndef func(number):\n for i in range(number):\n  if i%2 == 0:\n   print(\'i is even\')\n  else:\n   print(\'i is odd\')\n</c>\n\n<h>\n*Quotation\n</h>\n\n<h>\n*Comments\n</h>\ncomment in python starts from letter \'#\'. any thing following \'#\' is comment when \'#\' does not appear in any string.\n<c>\nclass A: # A is subclass of object and of type \'type\'\n # def __init__ is class function with \'self\' as \n# first argument when called as method\n def __init__(self):\n  self.ma #ma is an attribute\n</c>\ntriple single quote and double quote can also be used as comment\n<c>\n\'\'\'\nclass widget subclass QWidget and creates\na window. qapplication needs to get\ninstantiated first\n\'\'\'\nclass widget(QWidget):\n def __init__(self):\n  self.__init__()\n\'\'\'\n</c>\n\n<h>\n*Multi Line statements\n</h>'
'2!ABS SBA!Python execution model!ABS SBA!!ABS SBA!<h>\n*Self-Organizing Maps\n</h>\n<h>\n*Boltzmann Machine\n</h>\n<h>\n*Auto Encoders\n</h>'
'3!ABS SBA!Variable types!ABS SBA!*Converting various data types to other\ntypes\n*Practicing built in functions.!ABS SBA!<h>\n*Number (integer, long, float, complex)\n</h>\nIn Python every variable data is an object. <b>integer</b>, <b>bool</b>, <b>string</b> and <b>tuple</b> are immutable variables, their memory is read only.\n<cb>\n     name1        name2                name2\n    --------     --------   modifying --------\n    | A.a  |     | aint |  -------->  | aint |\n    --------     --------   aint      --------\n       |              |                  |\n       |              |                  |\n       +-----+--------+                  |\n             |                           |\n             |                           |\n          ------                      ------\n  object1 | 10 |                      | 20 |object2\n          ------                      ------\n</cb>\n<cc>\nminhinc@minhinc:~/tmp$ python3\nPython 3.6.9 (default, Jul 17 2020, 12:50:27) \n[GCC 8.4.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>> class A:\n...  a=10\n...  def func(aPar):\n...   print("aPar {}".format(aPar))\n...\n>>> A.__dict__\nmappingproxy({\'__module__\': \'__main__\', \'a\': 10, \'func\': <function A.func at 0x7fdee58afc80>, \'__dict__\': <attribute \'__dict__\' of \'A\' objects>, \'__weakref__\': <attribute \'__weakref__\' of \'A\' objects>, \'__doc__\': None})\n>>> aint=A.a\n>>> id(aint)\n10914784\n>>> id(A.a)\n10914784\n>>> id(10)\n10914784\n>>> aint=20\n>>> id(aint)\n10915104\n>>> id(20)\n10915104\n>>> id(A.func)\n140595310558336\n</cc>\n<h>\n*String\n</h>\n<h>\n*Declaring and initializing variable\n</h>\n<h>\n*Performing arithmetic calculation\n</h>\n<h>\n*Mutable types\n -List\n -Dictionary\n</h>\n<h>\n*Non mutable types\n -Tuple\n</h>\n<h>\n*meta class\n</h>'
'4!ABS SBA!Defining and Calling functions!ABS SBA!*Write sample application with a function\ndefined.\n*Pass arguments as\n -Keyword arguments\n -Default arguments\n -Variable length arguments!ABS SBA!<h>\n*Function definition\n</h>\n<h>\n*Function arguments\n -Pass by reference and value\n -Required arguments\n -Keyword arguments\n -Default arguments\n -Variable length arguments\n</h>\n<h>\n*Function local, non local and global\nvariable.\n</h>\n<h>\n*Function object\n*Method object\n</h>\n<h>\n*runtime function object creation\n</h>\nA function object can be defined with keyword <g>def</g>. a function object can be defined global to module or inside a class. function object defined inside a function object is its local variable rather than its attribute. function object can be defined inside a class, then it becomes class attribute.\na function object can be created at runtime by following measures\na)<G>exec()</g> functions\n<c>\n>>> exec("def func2(x):\n print(\'x\',x)\n")\n>>> func2(10)\nx 10\n</c>\nb) lambda function\n<c>\na=lambda x:x+1\n>>> a(2)\n3\n</c>\nc)factory method\n<c>\ndef get_a_function(*a,**kw):\n def func_t(*a,**kw):\n  pass\n return func_t\nfunc=get_a_function()\nfunc2=get_a_function(20,30)\n</c>\n\nd)class with function operator overloaded\n<c>\nclass A:\n def __init__(self,a,b):\n  self.a,self.b=a,b\n def f(self,x):\n  return (x*self.a+self.b)\na=A(4,5)\na(6)\n</c>\n\n<h>\n*decorator\n</h>\ndecorator is structural design pattern in 23 design patterns from GoF. decorator class comes as wrapper class of decoratee and adds extra functionality\n<r>See also</r> <n><a href="http://minhinc.42web.io/training/dp/advance-dp-slides.php?chap=5#chap5_2">decorator design pattern</a></n>\nin python a decoratee class function can be decorated by placing \'@<classname|function>\' before the function delclaration.\'@<classname|function>\' is decorator wrapper which returns actual decorator function. \'@<classname|function>\' is intialized once class object is created.\n<r>See Also</r> <n><a href="http://minhinc.42web.io/training/py/advance-py-slides.php?chap=11#chap11_1">Meta Class Object</a></n>\n<c>\ndef decoratorfunc(f):\n print(\'decorator wrapper\')\n def func():\n  print(\'><decorator func\')\n  f()\n  print(\'<>decorator func\')\n return func\n\nclass A:\n @decoratorfunc\n def func():\n  print(\'decoratee func\')\n\n\ndecorator wrapper\n>>> A.func()\n><decorator func\ndecoratee func\n<>decorator func\n>>> A.func()\n><decorator func\ndecoratee func\n<>decorator func\nhere A.func is decoratee where as func as local to decoratorfunc is decorator, decoratorfunc is wrapper and gets intialized at the time of class object creation.\n <d2> class decorator is actually function call operator. so it also a function decorator wrapper'
'5!ABS SBA!Control statement!ABS SBA!!ABS SBA!<h>\n*if else elif statement\n</h>\n<h>\n*for in statement\n</h>\n<h>\n*while statement\n</h>\n<h>\n*break, continue and pass\n</h>\n<h>\n*Iterator\n</h>\n<h>\n*Generator\n</h>'
'6!ABS SBA!Regular Expression!ABS SBA!*Write regular expression to search and\nmodify a string.!ABS SBA!<h>\n*Module re\n</h>\n<h>\n*match(), search(), sub()\n</h>\n<h>\n*Modifiers\n</h>'
'7!ABS SBA!Basic Operators!ABS SBA!!ABS SBA!<h>\n*Arithmetic operator\n</h>\n<h>\n*Relation operator\n</h>\n<h>\n*Assignment operator\n</h>\n<h>\n*Bitwise operator\n</h>\n<h>\n*Membership operator\n</h>\n<h>\n*Identity operator\n</h>'
'8!ABS SBA!Module!ABS SBA!\'*List module namespace dictionary\\n*Import a module in main module and call\\nmodule functions\\n*Import external modules symbols in\\ncurrent module\' namespace\\n*Reload a module\\n*Write package and sub packages!ABS SBA!<h>\n*Package and Module\n*Importing namespace to other\n*Loading a module and accessing symbols\n</h>\nA module is the biggest namespace which contains other namespace like class and function. A module can not contain another module. A package contain modules. A package can contain other packages and modules. Package provide separate namespace similar to module, where code blocks can be written in __init__.py file making a code block belong to package namespace. In file system, module is a file where as package is a directory. Package hierarchy is referenced through dot operator. Since module can not contain another module, module is a leaf node in package heirarchy. Referring to subpackages and modules through a package does not need presence of any __init__.py in package directory.\n<c>\npackageA-----\n            |---- packageB\n            |---- packageC-------|\n            |---- moduleA        |------ packageD\n            |                    |------ moduleB\n         __init__.py             |\n                              __init__.py\n</c>\nmoduleB can be referenced as packageA.packageC.moduleB . when a codeblock that is in package.__int__.py or in a module is rerenced in __main__ module or in a particlar module then the referenced codeblock must be visible to the referencing codeblock.\n\n<c>\nimport packageA\n</c>\n\n\'import packageA\' would make its __init__.py visible to the referencing module. if packageA.__init__.py imports moduleA then only moduleA is visible to refrencing module.\n\n<c>\nminhinc@minhinc:~/tmp$ cat packageA/__init__.py \nclass A:\n ca=10\nminhinc@minhinc:~/tmp$ cat packageA/moduleA.py \nclass A:\n ca=20\nminhinc@minhinc:~/tmp$ python3\nPython 3.8.5 (default, May 27 2021, 13:30:53) \n[GCC 9.3.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>> import packageA\n>>> packageA.A.ca\n10\n>>> packageA.moduleA.A.ca\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nAttributeError: module \'packageA\' has no attribute \'moduleA\'\n</c>\n\nSo moduleA is not visible to __main__ module when only packageA is imported. two solutions to it\n\n <d2> moduleA would be imported directly into main module making moduleA bind to __main__ module namespace\n<cb>\nminhinc@minhinc:~/tmp$ python3\nPython 3.8.5 (default, May 27 2021, 13:30:53) \n[GCC 9.3.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>> from packageA import moduleA  <l><--- moduleA is bind to __main__ module namespace</l>\n>>> packageA.moduleA.A.ca      <l><--- packageA.moduleA is not bind to __main__ module namespace</l>\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nNameError: name \'packageA\' is not defined\n>>> moduleA.A.ca\n20\n>>> import packageA.moduleA  <l><--- packageA.moduleA is bind to __main__ module namespace</l>\n>>> packageA.moduleA.A.ca\n20\n>>> packageA.A.ca\n10\n</cb>\n\n <d2> moduleA would be imported to packageA\n<c>\nminhinc@minhinc:~/tmp$ cat packageA/__init__.py \nimport packageA.moduleA   <l><--- moduleA is imported to packageA namdespace</l>\nclass A:\n ca=10\nminhinc@minhinc:~/tmp$ python3\nPython 3.8.5 (default, May 27 2021, 13:30:53) \n[GCC 9.3.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>> import packageA\n>>> packageA.moduleA.A.ca\n20\n</c>\n\n<h>\n*Locating module\n</h>\nPython module when imported must be visible to the importing module. modules is searched in sys.path.\n<cb>\nminhinc@minhinc:~/tmp$ python3 -c \'import sys;print(sys.path)\'\n[\'\', \'/usr/lib/python38.zip\', \'/usr/lib/python3.8\', \'/usr/lib/python3.8/lib-dynload\', \'/home/minhinc/.local/lib/python3.8/site-packages\', \'/usr/local/lib/python3.8/dist-packages\', \'/usr/lib/python3/dist-packages\', \'/usr/lib/python3.8/dist-packages\']\nminhinc@minhinc:~/tmp$ export PYTHONPATH=/home/minhinc/tmp/MISC:$PYTHONPATH\nminhinc@minhinc:~/tmp$ python3 -c \'import sys;print(sys.path)\'\n[\'\', \'/home/minhinc/tmp/MISC\', \'/home/minhinc/tmp/MISC/gc\', \'/usr/lib/python38.zip\', \'/usr/lib/python3.8\', \'/usr/lib/python3.8/lib-dynload\', \'/home/minhinc/.local/lib/python3.8/site-packages\', \'/usr/local/lib/python3.8/dist-packages\', \'/usr/lib/python3/dist-packages\', \'/usr/lib/python3.8/dist-packages\']\n</cb>\n\nPython modules or packages are searched in current directory and in other directories mentioned in sys.path. Module searching path list can be appended by adding path to sys.path list or adding to PYTHONPATH environment variable.\n\n<h>\n*Namespaces in dictionary\n</h>\n<h>\n*dir function listing dictionary\n</h>\n<h>\n*globals(), locals() function\n</h>\n<h>\n*Reloading a module\n</h>\n<h>\n*Python Interpreter\n</h>'
'9!ABS SBA!Class and Object!ABS SBA!*Write a small class with class variable and\n*function object\n*Add object variable and method objects.\n*Call methods from other method\n*Inherit from the class and override!ABS SBA!<h>\n*class\n*class object\n*function object\n</h>\n<a>Class is a template or a Pattern which is used to create similar type class instances/values</a>\nClass is a template or a pattern that can be used to create many instances of it. In programming terms it is a user defined <i>type</i> for many value/instance objects.\nClass definition leads to creation of class namespace which is represented by data structure <i>class object</i>. Class namespace contains attributes. Attributes can be data type or function objects. Since every value has a type, a class object is of type <i>type</i> class. <G>type</G> is also known as meta class.\n<c>                            \n         <g>class</g> A:   <----- class definition\n          ca=<r>10</r>\n          <g>def</g> cfunc(self):\n           pass\n     \n            |               type <g>type</g> meta class\n            |               ^ \n            | class object /\n            v             /\n     -------------------  |     +------  A <g>namespace</g>\n     | <g>class</g> object \'A\'|---     |\n     -------------------        V\n+----->| ca       |             A.ca=10\n| +--->| cfunc()  |             A.cfunc\n| |    ------------\n| |\n| <g>attribute, function object</g>\n<g>attribute, data type</g>\n</c>\namong attributes <i>A.ca</i> is an int object whereas <i>A.cfunc</i> is function object.\n<cb>\n>>> A\n<class \'__main__.A\'>\n>>> A.cfunc\n<function A.cfunc at 0x7f9600a27dc0>\n>>> type(A)\n<class \'type\'>\n>>> type(A.cfunc)\n<class \'function\'>\n</cb>\nA class object and function object can have attributes added at run time.\n <d2> Through <i>dot</i> operator\n  A.cb=\'hello world\'\n  A.cfunc.fa=40\n <d2> Through <i>setattr</i> inbuilt function\n  setattr(A,\'cb\',\'the earth\')\n  setattr(A.cfunc,\'fa\',40)\nIt can be accessed through\n <d2> <G>dot</G> operator\n  print(A.cfunc.fa)\n <d2> <G>getattr</g> inbuilt function\n  print(getattr(A.cfunc,\'fa\')\nAttributes in a class object can be queried through inbuilt function <i>hasattr</i>\n<cb>\n>>> A.cfunc.fa=40\n>>> <g>setattr</g>(A.cfunc,\'fa\',60)\n>>> A.cfunc.fa\n60\n>>> <g>getattr</g>(A.cfunc,\'fa\')\n60\n>>> <g>hasattr</g>(A.cfunc,\'fa\')\nTrue\n</cb>\n<h>\n*class instance object\n*method object\n</h>\nA class object can be instatiated to numbers of <i>empty instances</i>. Emtpy instances has no attribute(s). Instance data structure are also known as <i>class instance objects</i>. <G>class instance objects</G> are replica of <G>class objects</G> in a sense that all attributes in <G>class object</g> can be accessed through <G>instance object</G> with same name, through internal reference.\n<c>\n            ------------------                 ------------\n            |<g>class</g> A:        |  1           *  | <g>class</g>    |\n            | ca=10          | --------------> | <g>instance</g> |<------\n            | def cfunc(self):|   A()  +------ | <g>object</g>   |      |\n  type      |  pass          |        |        ------------      |\n    ^       ------------------        |       a.ca| |a.cfunc()   |\n    |           |                     |           | |            |\n    |           |                     |           | |            |\n    +---+  |    |         +-----------+           | |            |\n<<type>>|  |    | A       |  <<type>>             | |            /\n        |  |    |         |                       | |           /\n        |  |    v         v                       | |          /\n       -------------------                        | |     empty object at\n       | class object \'A\'|                        | |     the time of \n       -------------------                        / |     creation\n ----->| A.ca=10         | <---------------------+ /\n |+--->| A.cfunc()       | <---------------------+\n ||    -------------------\n ||\n |class function object\n class attributes\n</c>\nClass object attributes can be overriden in class instance object. Calls to class function object called through class instance object pointer first creates an abstract method object which then calls class function object.\nMethod object is created after binding instance object (pointer) with class function object (pointer). So a method object has two attributes, instance object and class function object. Argument list is modified and instance object (pointer) is add at the begining, making a change in argument list. So class function objects when called through instance object must contain one argument which will finally carry instance object reference.\n\nInstance object is created through function operator called \'(\') on class object.\n<c>\na=A()\n</c>\nInstance object \'a\' is empty at the time of creation. Attributes can be added at run time.\n<cb>\n>>> class A:\n...  ca=10\n...  def cfunc():\n...   pass\n... \n>>> a=A()\n>>> a\n<__main__.A object at 0x7f1409029880>\n>>> A\n<class \'__main__.A\'>\n>>> A.__dict__\nmappingproxy({\'__module__\': \'__main__\', \'ca\': 10, \'cfunc\': <function A.cfunc at 0x7f1408f9f430>, \'__dict__\': <attribute \'__dict__\' of \'A\' objects>, \'__weakref__\': <attribute \'__weakref__\' of \'A\' objects>, \'__doc__\': None})\n>>> a.__dict__   <l><-- empty objects</l>\n{}\n>>> a.ma=<r>100</r>  <l><-- attributes added at run time</l>\n</cb>\nFunction object called through instance object leads to creation of intermeditiary method object and it does not refer to class function object directly.\n<c>\n     ------------\n     |  class A |                         instance object\n     |----------|                         -------------\n+--->|ca=10     | <-----------            |   a=A()   | <-- empty objects\n| +->|cfunc()   | <----+     |            -------------\n| |  ------------      |     -------------| a.ca      |\n| |                   -------------   ----| a.cfunc() |\n| |                   | a,A.cfunc |<--|   -------------\n| |                   -------------\n| |                  bound method object\n| |\n| |              bound method object    instance object\n| |  A.cfunc(b)   -------------         -------------\n| +---------------| b,A.cfunc |<-----+  |   b=A()   | <-- empty objects\n|                 -------------      |  -------------\n+--------------------------------+   |  | b.ca      |---+\n                                 |   +--| b.cfunc() |   |\n                                 |      -------------   |\n                                 +----------------------+\n</c>\n<cb>\n>>> hex(id(a))\n\'0x7fa8035d4880\'\n>>> hex(id(A))\n\'0xd890e0\'\n>>> A.cfunc\n<function A.cfunc at 0x7fa803549430>\n>>> a.cfunc\n<bound method A.cfunc of <__main__.A object at 0x7fa8035d4880>> <l><--- method object </l>\n>>> A.cfunc.fa=\'hello\'\n>>> a.cfunc.ma=\'hello\'       <l><-------- can not add attribute</l>\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nAttributeError: \'method\' object has no attribute \'ma\'\n>>> dir(a.cfunc)\n[\'__call__\', \'__class__\', \'__delattr__\', \'__dir__\', \'__doc__\', \'__eq__\', \'__format__\', \'<r>__func__</r>\', \'__ge__\', \'__get__\', \'__getattribute__\', \'__gt__\', \'__hash__\', \'__init__\', \'__init_subclass__\', \'__le__\', \'__lt__\', \'__ne__\', \'__new__\', \'__reduce__\', \'__reduce_ex__\', \'__repr__\', \'<r>__self__</r>\', \'__setattr__\', \'__sizeof__\', \'__str__\', \'__subclasshook__\', \'fa\']\n>>> a.cfunc.__self__   <l><---- refer to instance object</l>\n<__main__.A object at 0x7fa8035d4880>\n>>> a.cfunc.__func__          <l><---- refer to class function object </l>\n<function A.cfunc at 0x7fa803549430>\n>>> A.cfunc()\n>>> a.cfunc()   <l><--- A.cfunc() must have one argument</l>\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nTypeError: afunc() takes 0 positional arguments but 1 was given\n</cb>\nSince bound method object passes extra instance object as first parameter to the class function object, here in this case it pops error\n<cb>\nA.cfunc(A()) is similar to A().cfunc()\n</cb>\n\n<n><d> Class object, class function object and class instance object\nAmong user defined functions <G>class object</G>, <G>class function object</g> and <G>class instance object</g> <i>first class objects</i>. Being first class object they can be created at run time, passed as an argument to function and returned from the function definition, can be assigned to variable and can be stored in a list.</n>\n\n<h>\n*public private variable\n*virtual methods\n</h>\nAll attributes in class are public. Inheritance is public. all methods are virtual. Class attributes or class instance attributes with atleast two leading underscores and atmost one trailing underscores are prepended (name mangling) with _<classname> when code is complied by python.\n\n<c>\nclass B:\n def Upper(self):\n  print(\'B.Upper\')\n# __Upper=Upper\n def __init__(self):\n  B.__Upper=B.Upper\n  self.__Upper()\n\nclass A(B):\n def Upper(self):\n  print(\'A.upper\')\n</c>\n\ncompiled into\n\n<c>\nclass B:\n def Upper():\n  print(\'B.Upper\')\n# _B__Upper=Upper\n def __init__(self):\n  B._B__Upper=B.Upper\n  self._B__Upper()\n\nclass A(B):\n def Upper(self):\n  print(\'A.upper\')\n</c>\n\n<cb>\n>>> a=A()\nB.Upper\n</cb>\n\n\'a\'._B__Upper is search first then A.__B__Upper. not finding A._B__Upper it searches as B._B_Upper which is shunted as B.Upper.\n\nclass A function can be called in two cases\n - <c>B.__Upper=B.Upper</c> should be replace with <c>self.__Upper=self.Upper</c> which would be changed to <c>self._B__Upper=self.Upper</c>\n - <c>A._B__Upper</c> function introduced in class A'
'10!ABS SBA!Inheritance and Polymorphism!ABS SBA!*Inherit from the class and override\nmethods\n*Instantiate base and derived class\nseparately and check inheritance and\npolymorphism functionality.!ABS SBA!<h>\n*Reusing functionality through inheritance\n</h>\nA class is defined to provide service in a particular technical area. A class can extend/add to functionality provided through other class, by inheriting the class, avoiding chance of code duplicacy. This promotes code reusablility. Link layer in network stack provide same interface to all kind of data transfer. Ip layer where each interface is identified thorugh ip address. Tcp and udp are different algorithms to maintain timer and send/recieve buffer. It make sense to dedicate separate class at each layer.\n<c>\n                      ----------\n                      | link   |\n                      --------------\n                      |send(dest,buffer)|\n                      --------------\n                           / \\\n                            -\n                            |\n                       --------\n                       | ip   |\n                       --------------\n                       |send(dest,buffer)|\n                       --------------\n                            / \\\n                             -\n                             |\n                     +-----------------+\n                     |                 |\n               --------            ---------\n               | tcp  |            | udp   |\n               -----------------   ----------------\n               | send(dest,buf)|   |send(dest,buf)|\n               -----------------   ----------------\n</c>\nWhat if a new ip layer alogorithms introduced which uses same link layer algorithms, what about new protocol in addition to tcp and udp.\n\nA new \'ipsec\' algorithms introduced for security feature which may not use current \'ip\' class\n<c>\n                      ----------\n                      | link   |\n                      --------------\n                      |send(buffer)|\n                      --------------\n                           / \\  / \\\n                            -     -\n                            |     |\n                            |     +---------|\n                       --------          ----------\n                       | ip   |          | ipsec |    <l><-- independent ipsec class</l>\n                       --------------    --------------\n                       |send(buffer)|    |send(buffer)|\n                       --------------    --------------\n</c>\n\'ipsec\' algorithms extending current ip class\n<c>\n                      ----------\n                      | link   |\n                      --------------\n                      |send(buffer)|\n                      --------------\n                           / \\\n                            -\n                            |\n                       --------\n                       | ip   |\n                       --------------\n                       |send(buffer)|\n                       --------------\n                            / \\\n                             -\n                             |\n                         --------\n                         | ipsec|           <l><--- adding functinality to \'ip\'</l>\n                         --------------\n                         |send(buffer)|\n                         --------------\n</c>\n<d1> Features provided by inhertiance\n <d2> Distrubute responsibilities in separate reusable componenents\n <d2> Extend feature of base class.add more features in derive class\n\n<h>\n*class object inheritance\n*instance object inheritance\n</h>\n<d> Class object inheritance\nEach class carry a separate data structure (class object). When attribures cannot be searched in a class it is searched in immediate class.\n<cb>\nclass B:\n def func():\n  print(\'B.func()\')\nclass A(B):\n ca=10\n>>>A.func()\nB.func()\n</cb>\nWith class \'A\' derived from class \'B\' two data strucutres comes into picture. Search begins upward when attributes not found in a data structure.\n<cb>\n                         +--------- class object B data structure\n                         |\n                         v\n                     -----------\n                     |B.func() |\n                     -----------\n                            ^\nclass object A              |     \ndata structure              +----+ searchs upward\n                                |\n                                | \n                    ----------- +\n            -------> |   ca    | <---------- A.func() \n                     -----------\n</cb>\n<d> Class instance object inheritance\nWhat if a particular class in inheritance hierarchy is instanced and then its attribute (method or non method) is referenced? instancing a class is nothing more than bring a new instance object data structure which searches for attributes first in instance object data structure and then in its class object. Failing to get at either place, it starts \'class object\' inheritance hierarchy to lookup again.\n<cb>\nclass B:\n def func(self):\n  print(\'B.func()\')\nclass A(B):\n ca=10\n>>>a=A()\n>>>a.func()\nB.func\n</cb>\n<cb>\n                         +--------- class object B data structure\n                         |                           +----- instance object B()\n                         v                           |\n                     -----------       ---------- <--+\n                     |B.func() |       |        |\n                     -----------       ----------\n                            ^\nclass object A              |     \ndata structure          (3) ------ searchs upward  +------- instance object A()\n                                |                 |\n                                |                 v\n                    ----------- +  (2)   ----------    (1)\n            -------> |   ca    |<---------|        | <---------- a.func() \n                     -----------          ----------\n</cb>\nThere is no instance object inheritance hierarchy. <c>a=A()</c>, instantiating class A yeilds \'a\'. Calling a.func() searches in instance object \'a\' first then in class object \'A\' and then in class object \'B\'. It does not search in instance of class B.\n<cb>\nclass B:\n ca=10\n cb=20\n def __init__(self):\n  self.ma=40 # <l><--- self refer to instance object \'a\'</l>\nclass A(B):         <l>when called in a.__init__ context</l>\n pass\n>>a=A()\n>>a.ma\n40\n</cb>\nThis happens because B.__init__ is called when A.__init__ is missing and so \'ma\' attribute is added to the \'a\' instance object.\n\n<h>\n*Polymorphism\n*Overriding methods\n</h>\nA class is polymorphic when its methods called against it would be different at compile and runtime. If method func() is called against instance of class A in the code then there would be provision to replace the instance of class at runtime making different func() method called altogether. This is also known as interface programming.\n<c>\nclass A:\n def func(self):\n  pass\n def __init__(self):\n  self.func()\n</c>\nIn code it is expected that self.func() is actually A().func. It shows polymorphics behaviour when self.func() inside A.__init__ would be different than A(). Here it shows polymporphic behaviour as code is written keeping in mind that func() method is called against class A instance, A().func(), where as method func() can be called against any class instance which actually have method func defined. This depends upon which \'self\' is passed against A.__init__ as first argument. Typically these call would be from the derived classes. Drivie class method call finally resolves in inheritance heirarchy when it misses at the instance object. Method call typcially add instance object as first parameter in the argument list.\n\nUnlike c++, interface class need not delcare the function signature (as virtual). In this case the python class is pure virtual and methods must only be called aginst the concrete deriver classes.\n<c>\nclass A:\n def __init__(self):\n  self.func()\n</c>\nA.func() definition is not required when A need not be instantiated and it is considered as pure virtual class.\n\n<cb>          \n               +---- self is X() or A()\n               |\nclass A:       v\n def __init__(self):\n  self.func() <---- func() is polymorphic. \n                    Actual defintion depends on \'self\' instance object\n\nclass X:\n def __init__(self):\n  A.__init__(self) # <-- any class instance can be passed\n def func(self):\n  print(\'X.func\')\n\nclass D(A): # A.__init__ is called instead. \'self\' is D instance object\n def func(self):\n  print(\'D.func\')\n\n>>> x=X()\nX.func\n>>> d=D()\nD.func\n</cb>\n\nEvery method in class \'a\' is virtual and all its attributes are public. Inheritance type is only public. Class attributes and instance attributes can be added at run time (instance attributes can be added only at runtime). Referring to instance attribute searches in instance object data structure and then in class objects in heirarchy.\nPython has no concept for instance object inheritance, Its only about class (object) inheritance. Method object is mere binding class function object against instance object and calling again the same class function object after prepending instnace object reference the argument\'s list.\nPython has no concept of implicit attribute binding to an object. while binding an attribute to an object (class or instance), object name must be mentioned explicitly.\nfailing to mention object name makes the attribute variable belong to local namespace.\n<c>\nclass A:\n def __init__(self):\n  ma=10\n</c>\nma is local variable to function A.__init__. it neither belong to class object A nor instance object A().\n<c>\nclass A:\n def __init__(self):\n  A.ca=10\n  self.ca=10\n</c>\none \'ca\' goes to class object where as another one goes to instance object A().\nclass object attributes and instance object attributes can be added at runtime.\n<c>\nclass A:\n def __init__(self):\n  self.ma=10\n def func(self):\n  self.mb=20\n\nclass A(B):\n def __init__(self):\n  A.__init__(self)\n  self.mb=20\n</c>\n\na=A()\nb=B()\n\n\'a\' get two attributes ma and mb as B.__init__ argument \'self\' is \'a\' when it is called from A.__init__ --> B.__init__(self). \'b\' get only one attribute \'ma\'. similarly  class object can also be polymorphic\n\n<cb>\nclass B:\n def __init__(self,cls):\n  self.ma=10\n  cls.ca=10\n\nclass A(B):\n def __init__(self):\n  B.__init__(self,A)\n\n>>> a=A()\n>>> A.ca\n10\n>>> a.ca\n10\n>>> a.ma\n10\n</cb>\n\nso any class type value which can accept attributes at runtime are polymorphic.\nwhen methods are called against instance object in any class in class inheritance heirarcy search for method definition begins at instance object only and then takes path of class inheritance hierarchy.\n\n<cb>\nclass X:\n def __init__(self):\n  self.func()\n\nclass Y(X):\n def func():\n  print(\'Y.func\')\n\nclass A(Y):\n pass\n\na=A()\n</cb>\n\n<cb>\n             ---------\n             |  X    |<-- class object X data structure\n             ---------\n               ^         +--------- class object B data structure\n               |         |\n               |(4)      v\n               |     -----------\n               +-----|B.func() |\n                     -----------\n                            ^\nclass object A              |\ndata structure          (3) ------ searchs upward  +------- instance object A()\n                                |                 |\n                                |                 v\n                    ----------- +  (2)   ----------    (1)\n            -------> |   ca    |<---------|        | <---------- a.func() \n                     -----------          ----------\n</cb>\n\nX.__init__ is called from meta class system which inturn calls X.__init__ as per inheritance. calling self.func() in X.__init__ leads to call of func method against the actual instance object which is \'a\'. so search would be as follows\n\n<c>\nX.func\n  ^\n  |\nY.func\n  ^\n  |\nA.func <---- a.func\n</c>\n\nso finally it would call Y.func\n\n<h>\n*Multiple inheritance\n*super() function call\n</h>\nin multiple inheritance base classes are searched in depth first order where each class is search only once. this is also known a mro search algorithms\n<cb>\n              X\n             / \\\n              -\n              |\n      -----------------\n      |               |\n      B               C\n      .               .\n     / \\             / \\\n      -               -\n      |               |\n      +-------+-------+\n              |\n              A\n</cb>\n<c>\nclass B(X):\n pass\nclass C(X):\n pass\nclass A(B,C):\n pass\n</c>\n\nA.func(), order of search would be A.func, B.func, C.func and X.func.\nsuper is used to call base class function object. exact base class is decided by mro algorithms of python.\n\n<c>\nclass A(B,C):\n def __init__(self):\n  super(S,self).__func()\n\'self\' is class object or instance object. incase calling static method it can be called with class name in both parameter\nself(A,A)\n</c>\n\n<h>\n*Similarity and dissimilarity with C++\n</h>\n<d> Python is similar to c++ in\n <d2> Class object data structure - static attributes in c++ belongs to class object where as non static belongs to instance object\n <d2> Factory method is used to create instance object. <G>new</g> factory method creates instance object in c++ where as <G>object.__new</g> creates instance object in python\n\n<d> Dissimilarity\n <d2> Class object in c++ is created by compiler and there is no concept of meta class.\n <d2> Base class object data structure comes inside derive class data structure which means drive class object grows biggers with more number of base classes where base class object stays separate in python.\n <d2> Python also supports virtual and polymorphism. runtime attribute addition to object makes it polymorphic where as c++ maintains a vtable for each virtual method entry in class definition.\n <d2> Default attributes and inheritance in c++ is private where as it is public in python\n <d2> C++ has concept of pure virtual class that can not be instanciated. every class must declare a method when it access it in any method. every class can be instantiated and class my not define a method even if it is called against an object. object reference can be passed through arguments and that object class needs to have the defintion.\n <d2> Variable types must well defined and it cannot be changed in c++, every variable is polymorphic in python and it can change reference to any type of object at runtime."'
'11!ABS SBA!Meta Class!ABS SBA!!ABS SBA!<h>\n*meta class\n</h>\nEvery value has a type so a meta class is type of all class values. It is same as class is type of class instance object. <i>type</i> is meta class of all classes. <G>type</g> is available as class and <G>type</g> is available as built in operator.\nwhen a class is of type \'type\' meta class, \'type\' meta class provides <i>factory method</i> __new__() which creates the class object. when instance object is of type class, class provides factory method __new__() which creates instance object.\n<d> A class definition follows two heirarchy\n <d2> <G>object</g> class inheritance where <i>object</i> is base class of all classes\n <d2> <G>meta class</g> inhertiance where <i>type</i> is base class of all meta classes\n<cb>\n           <g>object</g>        <g>type</g>\n             ^             ^\n             |             |\n             ----+     +----\n   <<base class>>|     |<<meta class>>\n                 |     |\n               ----------- equivalent to -------------------------\n               |    <g>A</g>    | <-----------> |A(object,metaclass=type|\n               -----------               -------------------------\n</cb>\n<G>type</G> meta class takes care of class object creation, through factory method __new__, and initialization, through __init__ method, whereas <G>object</G> takes care of class instance object creation, through factory method __new__, and initialization, through __init__ method. By default a class is derivied from <G>object</g> class where as its default meta class is <G>type</g>. So a class is of type <G>type</g>\n<G>meta class</g> has four functions, three responsible for class object creation (and initialization) whereas one hooks into instance object creation (and initialization) by <G>object</g> class.\n\n<cb>\n    ----------\n    |  <G>type</g> |\n    ---------------\n    |<g>@classmethod</g>|\n    |__prepare__  | <l><-- class namespace creation</l>\n    |<g>@staticmethod</g>| \n    |__new__      | <l><-- factory method class object creation</l>\n    |__init__     | <l><-- class object initialization</l>\n    +-------------+\n    |__call__     | ----+\n    --------------+     |\n                        | <l> instance object creation </l>\n                        v\n                  ----------\n                  | <g>object</g> |\n                  ----------\n                  |<g>@staticmethod</g> |\n                  |__new__   | <l><--- factory method instance object creation </l>\n                  |__init__  | <l><--- instance object initialization </l>\n                  ------------\n</cb>\n<cb>\n>>> class A:\n...  pass\n... \n>>> issubclass(A,object)\nTrue\n>>> issubclass(A,type)\nFalse\n>>> dir(A)\n[\'__class__\', \'__delattr__\', \'__dict__\', \'__dir__\', \'__doc__\', \'__eq__\', \'__format__\', \'__ge__\', \'__getattribute__\', \'__gt__\', \'__hash__\', \'__init__\', \'__init_subclass__\', \'__le__\', \'__lt__\', \'__module__\', \'__ne__\', \'__new__\', \'__reduce__\', \'__reduce_ex__\', \'__repr__\', \'__setattr__\', \'__sizeof__\', \'__str__\', \'__subclasshook__\', \'__weakref__\']\n>>> A.__class__\n<class \'type\'>\n>>> type(A)\n<class \'type\'>\n</cb>\n\n<h>\n*class object\n - creation\n - initialization\n</h>\n<d> A class object can be created in two fashion\n  <d2> Class definition where metaclass is assigned\n<c>\n   class A(B) # defaults to metaclass \'type\'\n   or\n   class A(B,metaclass=Meta) # \'Meta\' derived from \'type\'\n</c>\n Here class object for class definition \'A\' would be created. Base class object is \'B\' and meta class is \'Meta\'.\n  <d2> Through built in <i>type</i> function\n<c>\n  A=type(\'A\',(B,),{})\n  A=Meta(\'A\',(B,),{})   # \'Meta\' a \'type\' derivative\n</c>\n<cb>\n               --------------\n               |<g>type</g> |\n               +-------------+                         +--------+\n               |@classmethod |                         |        |\n               |__prepare__  |(metacls,clsname,bases) -> dict   |\n                                                                |\n                                                      +---------+\n                                                      |namespace\n               |@staticmethod|                        v\n               |__new__      |(metacls,clsname,bases,dct,**kw) -> clsobj\n               |__init__     |(clsobj) -> None                       |\n               ---------------   ^                                   |\n                      ^          |                                   |\n                      |          +-----------------------------------+\n                      +------------------\n                                        |\n ---------------------------  metaclass |\n |class A(B,metaclass=type)| -----------+\n | pass                    |            |\n ---------------------------            |\n        or                              |\n ------------------------               |\n |A=type(\'A\',(B,),{}) | ----------------+\n ------------------------\n</cb>\n\nPython creates class object either from class definition or invocation of \'type\' inbuilt function. \n<d> Class object from class definition\n <d2> Python first calls type.__prepare__ classmethod to get the namespace for class object. type.__preapre__ returns dictionary or its derivative.\n <d2> Factory method type.__new__ is called with metaclass,class name,class bases and __prepare__ returned custom dictionary argumetns. __new__ return class object.\n <d2> <G>type.__init__</g> is called with classobject retruned from type.__new__ method. type.__init__ further intialize the class object. it return None.\n<d> Runtime class object creation through <i>type</i> built-in function\n <d2> \'type\' built in function is called with classname,bases,custom dictinary object carrying attributes.\n\n<c>\nclass mydict(dict):\n def __init__(self,**kw):\n  self.mykey=list(kw.keys())\n  super(mydict,self).__init__(kw)\n def __setitem__(self,key,value):\n  if key not in self:\n   self.mykey.append(key)\n  dict.__setitem__(self,key,value)\n\nclass Meta(type):\n @classmethod\n def __prepare__(metacls,name,bases):\n  return mydict(ma=10,mb=\'hello\')\n @staticmethod\n def __new__(*a,**kw):\n  return super(Meta,Meta).__new__(*a,**kw)\n def __init__(cls,*a,**kw):\n  super(Meta,cls).__init__(*a,**kw)\n\nclass B:\n pass\n</c>\n\n<d> Two types of class object creation\n <d2> Class definition\n<c>\n>>> class A(B,metaclass=Meta):\n...  ca=\'world\'\n... \n>>> dir(A)\n[\'__class__\', \'__delattr__\', \'__dict__\', \'__dir__\', \'__doc__\', \'__eq__\', \'__format__\', \'__ge__\', \'__getattribute__\', \'__gt__\', \'__hash__\', \'__init__\', \'__init_subclass__\', \'__le__\', \'__lt__\', \'__module__\', \'__ne__\', \'__new__\', \'__reduce__\', \'__reduce_ex__\', \'__repr__\', \'__setattr__\', \'__sizeof__\', \'__str__\', \'__subclasshook__\', \'__weakref__\', \'ca\', \'ma\', \'mb\']\n</c>\n <d2> <G>type</g> built in function\n<c>\n>>> A=Meta(\'A\',(B,),mydict(ma=10,mb=\'hello\',ca=\'world\'))\n>>> dir(A)\n[\'__class__\', \'__delattr__\', \'__dict__\', \'__dir__\', \'__doc__\', \'__eq__\', \'__format__\', \'__ge__\', \'__getattribute__\', \'__gt__\', \'__hash__\', \'__init__\', \'__init_subclass__\', \'__le__\', \'__lt__\', \'__module__\', \'__ne__\', \'__new__\', \'__reduce__\', \'__reduce_ex__\', \'__repr__\', \'__setattr__\', \'__sizeof__\', \'__str__\', \'__subclasshook__\', \'__weakref__\', \'ca\', \'ma\', \'mb\']\n</c>\n\n<h>\n*instance object\n - Creation\n - Initialization\n</h>\n<a>when a class object is called with function operator \'()\', it generates instances of class namespace called class instances which is referred by data structure class instance object</a>\nA <g>class instance object</g> is a data structure which comes into picture when its prototype/blueprint <G>class object</G> gets called with function operator \'()\' which leads to <c><i>__call__</i></c> function invocation in \'type\' (or its derivative) meta class. Further the data structure gets instantiated through static factory method <c><i>object.__new__</i></c> in class object and newly created instance object data structure is then initialized through method <c><i>object.__init__</i></c> in class <G>object</G>. A class object, simply called class, is blueprint for class instance object which is simply called object.\n<cb>\n            ----------\n            | object |\n            ---------------\n            |@staticmethod|  (2)\n            |__new__      |<-------+(clsobj) -> instanceobj ---\n            |__init__     |<----+  |(instanceobj)             |\n            --------------- (3) |  |        ^                 |\n                 ^              +--+        |                 |\n                / \\             |           +-----------------+\n                 -              +------------+\n                 |                           |\n           ---------  metaclass +---------   | (1)\n           |class A|  ------>   | type   |   +-----+\n           ---------      ^     +--------+         |\n                ^         |     |__call__|(cls)----+ \n                |         |     ---------- (A)\n                |         |\n                |a=A() or a=type(\'A\',(),{})()\n       ---------+\n       |        |<<instantiation>>\n   ------    ------\n   | a  |    |  b |\n   ------    ------\n</cb>\npseudo code for type.__call__ can be considered as\n<c>\nclass type:\ndef __call__(clsobj,*a,**kw):\n instanceobj=clsobj.__new__(clsobj,*a,**kw)\n instanceobj.__init__(*a,**kw)\n</c>\n<d> <G>class intantiated object</G> is created with following steps\n <d2> Function operator against class name appears\n<c>\nclass Meta(type):\n def __call__(clsobj,*a,**kw):\n  print(\'>< Meta.__call__\',clsobj,a,kw)\n  return super(Meta,clsobj).__call__(*a,**kw)\n\nclass B:\n pass\n\nclass A(B,metaclass=Meta):\n @staticmethod\n def __new__(clsobj,*a,**kw):\n  print(\'>< A.__new__\',clsobj,a,kw)\n  return super(A,A).__new__(clsobj,*a,**kw)\n def __init__(self,*a,**kw):\n  print(\'>< A.__init__\',self,a,kw)\n  super(A,self).__init__(*a,**kw)\n\na=A() # <----- function operator\n</c>\n\n<cb>\n>< Meta.__call__ <class \'__main__.A\'> () {}\n>< A.__new__ <class \'__main__.A\'> () {}\n>< A.__init__ <__main__.A object at 0x7faf79091460> () {}\n</cb>\n\n <d2> When <G>type</G> inbuilt function creates class object and function operator called against it\n<c>\n a=<g>type</g>(\'A\',(),{})() # <----- function operator\n</c>\n\n<h>\n*Modify class in meta class\n</h>\n<i>type.__new__</i> creates the class object. arguments in creating class object includes base class list and attributes dictionary. base class list or/and <G>dict</g> can be modified to get different class all together.\n<c>\nclass Meta(type):\n @staticmethod\n def __new__(metacls,clsname,bases,dct,**kw):\n  upperdct=dict()\n  for key in dct:\n   if not key.startswith(\'__\'):\n    upperdct[key.upper()]=dct[key]\n   else:\n    upperdct[key]=dct[key]\n  print(\'non-modified dct {} \\nmodified dct {}\'.format(dct,upperdct))\n  return super(Meta,Meta).__new__(metacls,clsname,bases,upperdct,**kw)\n\nclass A(metaclass=Meta):\n ca=10\n cb=\'hello world\'\n</c>\n\n<cb>\nnon-modified dct {\'__module__\': \'__main__\', \'__qualname__\': \'A\', \'ca\': 10, \'cb\': \'hello world\'} \nmodified dct {\'__module__\': \'__main__\', \'__qualname__\': \'A\', \'CA\': 10, \'CB\': \'hello world\'}\n>>> A.CA\n10\n>>> A.CB\n\'hello world\'\n>>> A.__dict__\nmappingproxy({\'__module__\': \'__main__\', \'CA\': 10, \'CB\': \'hello world\', \'__dict__\': <attribute \'__dict__\' of \'A\' objects>, \'__weakref__\': <attribute \'__weakref__\' of \'A\' objects>, \'__doc__\': None})\n>>> dir(A)\n[\'CA\', \'CB\', \'__class__\', \'__delattr__\', \'__dict__\', \'__dir__\', \'__doc__\', \'__eq__\', \'__format__\', \'__ge__\', \'__getattribute__\', \'__gt__\', \'__hash__\', \'__init__\', \'__init_subclass__\', \'__le__\', \'__lt__\', \'__module__\', \'__ne__\', \'__new__\', \'__reduce__\', \'__reduce_ex__\', \'__repr__\', \'__setattr__\', \'__sizeof__\', \'__str__\', \'__subclasshook__\', \'__weakref__\']\n>>> A.ca\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nAttributeError: type object \'A\' has no attribute \'ca\'\n</cb>\n\n<h>\n*Inheritance\n*Singleton\n</h>\nwhen a class is derives from another class,i.e A drives from B, metaclass of A also must be same or derivative of metaclass of B. by default meta class of class is \'type\'. if B\'s meta class is not defined then A\'s metaclass must be \'type\' or derivative of type.\n\n<c>\nclass Meta(type):\n pass\n\nclass B(metaclass=Meta):\n pass\n\nclass A(B,metaclass=Meta):\n pass\n\nclass A(B,metaclass=MetaA):\n pass\n</c>\nhere class A metaclass must be Meta or derivative of Meta.\n<c>\nclass MetaA(Meta):\n pass\n</c>\nmeta class can be used to create singleton class. singleton class can be instantiated only once. instantiating more time would return same (firstly created) instance object reference. instance object is created with function operator against class.\n<c>\na=A()\n</c>\ncreates instance object \'a\' when class A is called function operator \'()\'. in this case type.__call__ function is called which in turn class \'object.__new__\' and \'object.__init__\' to created the instance object and then initialize them.\ntype.__call__ operator can be overloaded and calling type.__new__ and type.__init__ can be barred from second time onwards returning first time created instance object.\n\n<c>\nclass Meta(type):\n def __call__(clsobj,*a,**kw):\n  if not hasattr(Meta.__call__,\'singleton\'):\n   setattr(Meta.__call__,\'singleton\',super(Meta,clsobj).__call__(*a,**kw))\n  return getattr(Meta.__call__,\'singleton\')\n</c>\n\n<cb>\n>>> a=A()\n>>> b=A()\n>>> c=A()\n>>> id(a)\n140452269326048\n>>> id(b)\n140452269326048\n>>> id(c)\n140452269326048\n>>> a is b\nTrue\n>>> a is c\nTrue\n</cb>\n\nclass attribute Meta.singleton can also be used\ninstead of class function object attribute Meta.__call__\n\n<c>\nclass Meta(type):\n singleton=None\n def __call__(clsobj,*a,**kw):\n  if not Meta.singleton:\n   Meta.singleton=super(Meta,clsobj).__call__(*a,**kw)\n  return Meta.singleton\n</c>\n\nit can also be achieved by barring call to object.__new__ when overriden <class>.__new__ is called from type.__call__. this approach tough does not support barring call to object.__init__ which leads to modification of instance attributes.\n<c>\nclass A:\n def __new__(clsobj,*a,**kw):\n  if not hasattr(A.__new__,\'singleton\'):\n   setattr(A.__new__,\'singleton\',super(A,clsobj).__new__(*a,**kw))\n  return getattr(A.__new__,\'singleton\')\n\n</c>\nthis does not stop modifying the instance in A.__init__ function\n<c>\nclass A:\n  def __init__(self,*a,**kw):\n   self.ma=random.randrange(0,20,1)\n</c>\n\n<d> Example - A singleton widget is created with QWidget from PySide6. creating three widget would create only one.\n\n<c>\nfrom PySide6 import QtWidgets\nimport random\n\nclass Meta(type(QtWidgets.QWidget)):\n def __call__(clsobj,*a,**kw):\n  if not hasattr(Meta.__call__,\'singleton\'):\n   setattr(Meta.__call__,\'singleton\',super(Meta,clsobj).__call__(*a,**kw))\n  return getattr(Meta.__call__,\'singleton\')\n\nclass widget(QtWidgets.QWidget,metaclass=Meta):\n#class widget(QtWidgets.QWidget):\n COLOR=[\'#ffff01\',\'#ff0d01\',\'#ffa303\',\'#ff00fe\',\'#6700cd\',\'#0140ff\',\'#00bff3\',\'#01b787\',\'#abe409\']\n def __init__(self,*a,**kw):\n  super(widget,self).__init__(*a,**kw)\n  self.setStyleSheet(\'background-color:\'+widget.COLOR[random.randrange(0,len(widget.COLOR))]+\';\')\n\nif __name__==\'__main__\':\n app=QtWidgets.QApplication()\n w=widget()\n w2=widget()\n w3=widget()\n w.setWindowTitle(str(hex(id(w))));\n w2.setWindowTitle(str(hex(id(w2))));\n w3.setWindowTitle(str(hex(id(w3))));\n print(\'id(w) {}, id(w2) {}, id(w3) {}\'.format(hex(id(w)),hex(id(w2)),hex(id(w3))))\n w.show();w2.show();w3.show()\n app.exec_()\n</c>\n\n<m>http://minhinc.42web.io/image/singleton_s.png</m>\nsingleton widget class, only one window\n\n<m>http://minhinc.42web.io/image/singleton3_s.png</m>\nwithout singleton, three window'
'12!ABS SBA!File I/O!ABS SBA!*Implement operator overloading methods!ABS SBA!<h>\n*Introduct operator overloading\n</h>\n<h>\n*__init__, __del__\n*__sub__\n*__add_\n*__or__\n</h>\n<h>\n*__repr__,__str__\n*__getattr_,__getattribute__,__setattr__,__delattr__\n*__getitem__,__setitem__,__delitem__\n*__len__,__bool__\n*__lt__,__gt__,__le__,__ge__,__eq__,__ne__\n</h>\n<h>\n*__radd__,__iadd__,__iter__,__next__\n*__contains__\n*__index__\n*__enter__,__exit__\n</h>\n<h>\n*__get__,__set__\n*__delete__\n*__new__\n</h>'
'13!ABS SBA!Operator overloading!ABS SBA!*Raise exception\n*Catch in except block\n*Implement finally!ABS SBA!<h>\n*Exception objects\n</h>\n<h>\n*Assertion\n</h>\n<h>\n*try, except, finally\n</h>\n<h>\n*Raising an exception\n</h>\n<h>\n*User defined exceptions\n</h>'
'14!ABS SBA!Exception!ABS SBA!None!ABS SBA!None'
'21!ABS SBA!Python for Data Science!ABS SBA!*Download and install Python SciPy\n*Load a dataset \n*Create machine learning models!ABS SBA!None'
'22!ABS SBA!Machine Learning fundamentals & Algorithms!ABS SBA!*Machine Learning Fundamentals - Case Study 2 pilot projects!ABS SBA!None'
'23!ABS SBA!Deep Learning!ABS SBA!*Deep Learning - Case Study 2 pilot projects!ABS SBA!None'
'24!ABS SBA!Convolution Neural Networks!ABS SBA!*Convolutional Neural Networks - Case Study 2 pilot projects!ABS SBA!None'
'25!ABS SBA!Tuning RNN!ABS SBA!*Tuning RNN - Case study 2 pilot projects!ABS SBA!None'
'26!ABS SBA!Tensorflow!ABS SBA!*Tensorflow - Case Study 2 pilot projects!ABS SBA!None'
'31!ABS SBA!title!ABS SBA!None!ABS SBA!Python Essentials Training'
'32!ABS SBA!subtitle!ABS SBA!None!ABS SBA!5-day session'
'33!ABS SBA!h_Overview!ABS SBA!None!ABS SBA!Understanding principles of Object Oriented Programming\nUnderstanding the structure of a Python program\nUnderstanding module, class and object\nUnderstanding Polymorphism and Inheritance\nPractical labs with Python 3.x Interprete'
'34!ABS SBA!h_Duration!ABS SBA!None!ABS SBA!Five days - 40 hours (8 hours a day)\n50% of lecture, 50% of practical labs.'
'35!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'36!ABS SBA!h_Trainer!ABS SBA!None!ABS SBA!<a href="https://www.linkedin.com/in/pravinkumarsinha">http://www.linkedin.com/in/pravinkumarsinha</a>'
'37!ABS SBA!h_Audience!ABS SBA!None!ABS SBA!Professional embedded Software developers\nEmbedded developers.\nPeople supporting large scale products.'
'38!ABS SBA!h_Prerequisite!ABS SBA!None!ABS SBA!<b>Knowledge of Shell Scripting programming</b>\nIn particular, participants should be familiar with writing scripts in Unix\nShell Programming. Basic syntax and execution flow knowledge is required.\nShell Programming training agenda is available at\n<a href="http://minhinc.42web.io/training/li/advance-li-agenda.php">http://minhinc.42web.io/training/li/advance-li-agenda.php</a>\n\nand can be downloaded from\n<a href="http://minhinc.42web.io/training/advance-li-agenda.pdf">http://minhinc.42web.io/training/advance-li-agenda.pdf</a>\n\n<b>Knowledge of Object Oriented Concepts</b>\nOops concept like Abstraction, Inheritance, Polymorphism would help.'
'39!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'40!ABS SBA!h_Setup!ABS SBA!None!ABS SBA!Machine with Python 3.x interpreter installed.'
'41!ABS SBA!h2_Lecture!ABS SBA!None!ABS SBA!Lecture session will be course content presentation through the trainer.\nAny source code example related to the topic will be demonstrated, it would\ninclude executing the binaries.\nComplete lecture material can be downloaded from\n<a href="http://minhinc.42web.io/training/advance-py-slides.pdf">http://minhinc.42web.io/training/advance-py-slides.pdf</a>'
'42!ABS SBA!h2_Labs!ABS SBA!None!ABS SBA!Labs session would be completely hands on session where each example\n(with example data and execution instruction) would be provided to the\nstudents. Students can verify their results with the results provided in\nthe material.'
      qml      
'1!ABS SBA!Introduction to Qt Quick and QML!ABS SBA!*Write a QML document!ABS SBA!<h>\n*QObject Meta Object System\n</h>\nQObject has two parts. One is QObject declared in class and another is meta object associated to the QObject. Meta Object is referred by QMetaObject. Methods in meta object is referred by QMetaProperty.\n\n<c>\nQMetaObject *mo=::QObject->metaObject();\n</c>\nMeta object property can be executed through QObject as\n<c>\n::QObject->setProperty("abc",20);\n                  +------------------+\n                  |                  |\n+-----------------|----+   +---------|-------------------+\n|                 |    |   |         |                   |\n|                 |                  |                   |\n|      QObject    |   QMetaObject    |  Qml Framework    |\n|                 |                  |                   |\n|                 |                  |                   |\n|                 |    |   |         |                   |\n|                 |    |   |         |                   |\n+-----------------|----+   +---------|-------------------+\n                  |                  |\n                  +------------------+\n                        ^\n                        |\n                        +--- QMetaObject shared by C++ and QML sides \n\n    -----------                  ---------------\n    | QObject | <>-------------> | QMetaObject |\n    -----------                  ---------------\n\nconst QMetaObject* metaObject=obj->MetaObject();\nQStringList properites;\nfor(int i = metaObject->propertyOffset();i<metaObject->propertyCount();++i)\nproperties<<QString::fromLatin1(metaObject->property(i).name());\n</c>\n\nA Property can be added to meta system through\n<cc>\n<g>Q_PROPERTY</g>(type name\n            (READ getFunction [WRITE setFunction] |\n             MEMBER memberName [(READ getFunction | WRITE setFunction)])\n            [RESET resetFunction]\n            [NOTIFY notifySignal]\n            [REVISION int]\n            [DESIGNABLE bool]\n            [SCRIPTABLE bool]\n            [STORED bool]\n            [USER bool]\n            [CONSTANT]\n            [FINAL])\n</cc>\n<c>\nclass Person : public QObject\n{\n Q_OBJECT\n Q_PROPERTY(QString name READ name WRITE setName)\n Q_PROPERTY(int shoeSize READ shoeSize WRITE setShoeSize)\n .\n .\n</c>\n\nA methods can be added to meta system by\n<c>\nQ_INVOKABLE\nclass Window:public QWidget{\nQ_OBJECT\npublic:\n Window();\n void normalMethod();\n Q_INVOKABLE void invokableMethod();\n};\n</c>\n\nMethods in Qml can be called from c++ side\nQml\n<cc>\n// MyItem.qml\nItem {\n function readValues(anArray, anObject) {\n  for (var i=0; i<anArray.length; i++)\n  console.log("Array item:", anArray[i])\n  for (var prop in anObject) {\n  console.log("Object item:", prop, "=", anObject[prop])\n  }\n }\n}\n</cc>\nC++\n<cc>\nQQuickView view(QUrl::fromLocalFile("MyItem.qml"));\nQVariantList list;\nlist << 10 << QColor(Qt::green) << "bottles";\nQVariantMap map;\nmap.insert("language", "QML");\nmap.insert("released", QDate(2010, 9, 21));\nQMetaObject::invokeMethod(view.rootObject(), "readValues",\n Q_ARG(QVariant, QVariant::fromValue(list)),\n Q_ARG(QVariant, QVariant::fromValue(map)));\n</cc>\n\nFor function returning object types\nQml\n<cc>\n// MyItem.qml\nItem {\n function readDate(dt) {\n console.log("The given date is:", dt.toUTCString());\n return new Date();\n }\n}\n</cc>\nC++\n<cc>\nQQuickView view(QUrl::fromLocalFile("MyItem.qml"));\nQDateTime dateTime = QDateTime::currentDateTime();\nQDateTime retValue;\nQMetaObject::invokeMethod(view.rootObject(), "readDate",\n Q_RETURN_ARG(QVariant, retValue),\n Q_ARG(QVariant, QVariant::fromValue(dateTime)));\nqDebug() << "Value returned from readDate():" << retValue;\n</cc>\n\n<h>\n*Defining Qml Component\n</h>\nA .qml file is a component which is similar to a c++ header file having single class declration. A Qml component can exist as a .qml file/document or can be embedded in a Qml document as a \'Component\' type. \n\nQml file contains \na) A import statement (not exatly same as c/c++ incude directive)\nb) A single root obect delcraton (Item or its deriviative)\n\n- import statement is to provides modules or type namespaces or javascript to enable the engine to load the QML Object types referenced within the doucment. Its not copy paste like #include in c/C++\n- Qml object describes the hierarchy of single object which can be inherited, extended and instantiated. So it can have single root object hierarchy only.  Once qml file in this fasion becomes a library object With new set of properties that can be resused in other component.\n\nSo one qml file creates one component or one new type that is resusable.  \nBase class of all qml type is "Item"\nItem instantiates C++ class QquickItem\n\n<cc>\n                      -------------------\n                      |Item : QQuickItem|\n                      -------------------\n                              .\n                             / \\\n                              -\n                              |\n  +--------+---------+--------------------+-------------+\n  |        |         |                    |             | \n  -------- --------- ----------- ----------- -------------\n  |Column| |Control| |Rectangle| |TextInput| |StackLayout| . . .\n  -------- --------- ----------- ----------- -------------\n              .\n             / \\\n              -\n              |\n  +------------+---------+--------------------+\n  |            |         |                    |\n  ---------- --------- ---------- ----------- ------\n  |Abstract| |BusyInd| |ComboBox| |Container| |Pane| . . .\n  |Button  | |icator | ---------- ----------- ------\n  ---------- ---------               .           .\n       .                            / \\        / \\ \n      / \\                           -           -\n       -\n       |                             |           |\n       |    +------------------------+  +-----------------------+\n       |    |           |            |  |           |           |\n       | --------- ----------- -------- ------- ------ ------------\n       | |MenuBar| |SwipeView| |TabBar| |Frame| |Page| |ScrollView|..\n       | --------- ----------- -------- ------- ------ ------------\n       |\n  +------------+---------+--------------------+\n  |            |         |                    |\n  -------- ---------- ------------- --------------\n  |Button| |CheckBox| |DelayButton| |ItemDelegate|..\n  -------- ---------- ------------- --------------\n</cc>\n\n// MyQmlFile.qml\n<c>\n import QtQuick 2.0\n Rectangle { width: 200; height: 200; color: "red" }\n Rectangle { width: 200; height: 200; color: "blue" } // invalid two root object\n</c>\n\nCreating new Button type\n  // Button.qml\n<c>\n import QtQuick 2.0\n Rectangle {\n  width: 100; height: 100\n  color: "red"\n  MouseArea {\n   anchors.fill: parent\n   onClicked: console.log("Button clicked!")\n  }\n }\n</c>\n\nThe Button type can then be used in an application:\n  // application.qml\n<c>\n import QtQuick 2.0\n Column {\n  Button { width: 50; height: 50 }\n  Button { x: 50; width: 100; height: 50; color: "blue" }\n  Button { width: 50; height: 50; radius: 8 }\n }\n\n          -------------------\n          |Item : QQuickItem|\n          -------------------\n                 .\n                / \\\n                 -\n                 |\n            -----------\n            |Rectangle|\n            -----------\n                 .\n                / \\\n                 -\n                 |\n            -----------\n            | : Button| // Button inherits Rectangle in Button.qml and\n            ----------- // gets instantiated in application.qml\n</c>\n\nA <g>Component</g> can exist in a qml document like \na)\n<c>\nimport QtQuick 2.0\nItem {\n width: 100; height: 100\n <g>Component</g> {\n  id: redSquare\n  Rectangle {\n   color: "red"\n   width: 10\n   height: 10\n  }\n }\n Loader { sourceComponent: redSquare }\n Loader { sourceComponent: redSquare; x: 20 }\n</c>\n\nwhere id is extra provided than file component \nb) \n<c>\nvar component = Qt.createComponent("Button.qml");\n if (component.status == Component.Ready)\n  component.createObject(parent, {"x": 100, "y": 100});\n</c>\n\nc)\n<c>\nItem {\n id: root\n width: 500; height: 500\n Component {\n  id: myComponent\n  Rectangle { width: 100; height: 100; color: "red" }\n }\n Component.onCompleted: {\n  myComponent.createObject(root)\n  myComponent.createObject(root, {"x": 200})\n }\n}\n</c>\n\n<h>\n*Tree of QML Objects\n</h>\n.qml file contains root Qml object (QQuickItem) where other sub objects aligned in parent child relationship making tree of objects. child objects are assigned to some property value of the parent object. Subobjects not assigned to parent\'s any property goes to parent default property.\nfor ex. xyz.qml\n<c>\n<Xyz.qml>\n       Rectangle <>----+\n                       |\n                       |\n                       |\n                       |--> Rectangle\n                       |--> TextArea \n                       |--> TextInput\n                       |--> QTimer\n                       |--> Text\n\n</c>\nIn this case Xyz is a new type that derived from Rectangle.\n<c>\n         Rectangle\n            .\n           / \\\n           ---\n            |\n           Xyz\n</c>\n\n<h>\n*Qml Types\n - Visual\n - Non Visual\n</h>\n\n<m>https://www.youtube.com/embed/uzL9BV_VWYc</m>\n<m>https://www.youtube.com/embed/OJBDk4VUzKk</m>\n\nQml has mainly two types\nBasic types-<c>bool, double, enumeration, int ,list, real, string, url, var</c>\nObject Types\n Non Gui Types-<c>QtObject, Connection, Component, Timer</c>\n QtQuick Gui Types-<c>Item, Rectangle, TextArea, Text, TextInput</c>\n\n<b>Basic types</b>\nBasic types does not need any module to be imported by \'import\' keyword.\nBasic type provided through QtQuick module\ndate point, rect and size\n\n\'Qt\' which is global variable  provides subroutines to manipulate the basic types\n\nFor basic type, property change signal handler is invalid whereas signal handler on basic type itself is valid\n<c>\nText {\n// invalid!\n onFont.pixelSizeChanged: doSomething()\n// also invalid!\n font {\n  onPixelSizeChanged: doSomething()\n }\n onFontChanged: console.log("font changed")\n\n id: otherText\n focus: true\n Keys.onDigit1Pressed: font.pixelSize += 1\n Keys.onDigit2Pressed: font.b = !font.b\n Keys.onDigit3Pressed: font = otherText.font\n}\n</c>\njavascript objects and arrays are also supported\nwith keyword <c>var</c>. <c>Date</c> and <c>Array</c> functors are available in Qml\n<c>\nimport QtQuick 2.0\nItem {\n property var theArray: new Array()\n property var theDate: new Date()\n Component.onCompleted: {\n  for (var i = 0; i < 10; i++)\n   theArray.push("Item " + i)\n  console.log("There are", theArray.length, "items in the array")\n  console.log("The time is", theDate.toUTCString())\n }\n}\n</c>\n\nTypes in Qml comes from three sources\na)Provided natively by qml compiler\nb)Registered via c++ by QML modules\nc)Provided as QML documents by QML module\n\n<b>Object type</b>\nAll object types are derived from <c>QtQObject</c>\n<c>\n      QObject\n        .\n       / \\\n        -\n        |\n   Qml Object Type\n</c>\n\ncustom types can be made trough qml document types\n\nNon gui Object types comes from QtQml module\n<c>\nComponent Date, Number, String, Component, Qt,QtObject, Locale, Binding, Connections, Instantiator, Timer\n</c>\nList, Model Qml object types from QtQml.Model module\n<c>\nDelegateModel, DelegateModelGroup, ListElement, ListModel, ObjectModel\n</c>\n\nWhereas GUI object types come from QtQuick module\n\n<h>\n*Qt Quick classes\n</h>\nQt Quick QML Types provided through QtQuick import\n-<c>XML List Model</c>\n-<c>Local Storage</c> - submodule containing javaScript interface for an SQLite database\n-<c>Particles</c> - provides a particle system for Qt Quick\n-<c>Layouts</c> - provides layout for arranging Qt Quick items\n-<c>Window</c> - top-level windows and accessing screen information\n-<c>Dialogs</c> - creating and interacting with system dialogs\n-<c>Tests</c> - unit test for a QML application\n-<c>Controls</c> - set of reusable UI componets\n\n<h>\n*Data Type Conversion Between QML and C++\n</h>\n\n<cc>\n<b>Qt Type</b>                                <b>QML Basic Type</b>\n<g>bool</g>\t                               bool\n<g>unsigned int</g>, <g>int</g>                      int\n<g>double</g>                                 double\n<g>float</g>, <g>qreal</g>                           real\n<g>QString</g>                                string\n<g>QUrl</g>                                   url\n<g>QColor</g>                                 color\n<g>QFont</g>                                  font\n<g>QDate</g>                                  date\n<g>QPoint</g>, <g>QPointF</g>                        point\n<g>QSize</g>, <g>QSizeF</g>                          size\n<g>QRect</g>, <g>QRectF</g>                          rect\n<g>QMatrix4x4</g>                             matrix4x4\n<g>QQuaternion</g>                            quaternion\n<g>QVector2D</g>, <g>QVector3D</g>, <g>QVector4D</g>        vector2d, vector3d, vector4d\n<g>Enums</g> declared with Q_ENUM()/Q_ENUMS() enumeration\n</cc>'
'2!ABS SBA!Qt Properties!ABS SBA!!ABS SBA!<h>\n*Combination of Get/Set/Notifiy\n</h>\n\nGet, Set and Notify are getter, setter and setter notification signal function addition to Meta Object System. A new property is introducted in Meta Object System which is visible on QML side. Same thing can be achieved on Qml side when a new property and assiciated functions gets added to Meta Object System. As per Qml design those property as visible on C++ side also and signal handler to signal added in Qml side can be introduced in C++ side.\n\n<c>\nclass Message : public QObject\n{\n Q_OBJECT\n Q_PROPERTY(QString author READ author WRITE setAuthor NOTIFY authorChanged)\npublic:\n void setAuthor(const QString &a) {\n  if (a != m_author) {\n   m_author = a;\n   emit authorChanged();\n  }\n }\n QString author() const {\n  return m_author;\n }\n signals:\n  void authorChanged();\n private:\n  QString m_author;\n};\n</c>\n\nHere whenever author is modified in QML side, authorChanged signal is emitted. Qml engine attache a empty signal handler for it, named \'onAuthorChanged\' in template on<propertyname>Changed.\n\nThis can be added to qml meta object system as object type or as instantiated object.\n\n<b>Instantiated object</b>\n<c>\nint main(int argc, char *argv[]) {\n QGuiApplication app(argc, argv);\n QQuickView view;\n Message msg;\n view.engine()->rootContext()->setContextProperty("msg", &msg);\n view.setSource(QUrl::fromLocalFile("MyItem.qml"));\n view.show();\n return app.exec();\n}\n</c>\n\n// MyItem.qml\n<c>\nimport QtQuick 2.0\nText {\n width: 100; height: 100\n text: msg.author    // invokes Message::author() to get this value\n Component.onCompleted: {\n  msg.author = "Jonah"  // invokes Message::setAuthor()\n}\n}\n</c>\n\n<b>Registrered type</b>\n<c>\nmain(.....){\n...\nqmlRegisterType<Message>("Messaging", 1, 1, "Message")\n...\n}\n</c>\n// MyItem.qml\n<c>\nimport QtQuick 2.0\nimport Messaging 1.1\nText {\n width: 100; height: 100\n Component.onCompleted: {\n  text: Message{\n   author="Jonah"\n  }\n }\n}\n</c>\n\n<h>\n*Declaration of a Qt property\n</h>\n\nAn object can have following attributes\na) The id attribute\nb) property attributes\nc) signal attributes\nd) signal handler attributes\ne) method attributes\nf) attached properties and attached signal handler attributes\n\n<b>a) The id attrubute</b> \nThe id attribute is unique for each instance of the class and it must start with lower case. Id is "component scoed". Id can be used to idenify the object as \nif it is object name.\n<c>\nimport QtQuick 2.0\n Column {\n  width: 200; height: 200\n  TextInput { id: myTextInput; text: "Hello World" }\n  Text { text: myTextInput.text }\n }\n</c>\n\n<b>b) property attributes</b>\nQml has baisc types and object types. Object types can have property value that is static in value or bound to dynamic expression.\n\n1) Defining property\n A proprty can be inserted in QML object type through adding Q_PROPERY on C++ couter part class.\n2) A property can be inserted in QML object through adding \n <c>\'[default] property <propertyType> <propertyName>\'</c>\nex. \n<c>\n Item {\n//Basic types\n  property int someNumber\n  property string someString\n  property url someUrl\n//Var is takes any kind\n  property var someNumber: 1.5\n  property var someString: "abc"\n  property var someBool: true\n  property var someList: [1, 2, "three", "four"]\n  property var someObject: Rectangle { width: 100; height: 100; color: "red" }\n//Object type\n  property Item someItem\n  property Rectangle someRectangle\n  property color nextColor: "blue" // declaration and initialization\n//Custom type\n  Property BasicButton bbtn // BasicButton.qml exists\n }\n</c>\n\nProperty binding does not work on staticvalue returned through Javascript statement\n<m>https://www.youtube.com/embed/nXfqFRJnk0s</m>\n<c>\nimport QtQuick 2.0\nRectangle {\n width: 100\n height: width * 2\n focus: true\n Keys.onSpacePressed: {\n  height = width * 3 // once come here height is frozen\n }\n}\n</c>\n\nQt.binding() should be used instead\n<c>\nimport QtQuick 2.0\nItem {\nwidth:500;height:500\nRectangle{\n id:rect\n width:100;  height:width*2\n focus:true\n Keys.onSpacePressed:{\n  rect.height=Qt.binding(function() {return this.width*3})//\'this\' is component \n                                                          // not rect\n }                                                // this must be in Qt binding\n}\n</c>\n3) property alias\n<m>https://www.youtube.com/embed/CJSdQBs9AxM</m>\nProperty alias is used to create alias to other property similar to reference in C++. It is mostly used in component property making alias to child items property. While creating object type only component level properties are visible outside.\n\n<c>\n       +------------------------+\n       | Rectangle {            |\n       |property alias bx x.text|-------o \n       +---------------|--------+       \\\n       |               |        |        .... component bx actually\n       |  Text {       |        |        referring to child Text.text\n       |   id x <------+        |\n       |  }                     |\n       | }                      |\n       +------------------------+\n           Button.qml\n</c>\n  [default] property alias <name>: <alias reference>\n\n// Button.qml\n<c>\nimport QtQuick 2.0\nRectangle {\nproperty alias buttonText: textItem.text\nwidth: 100; height: 30; color: "yellow"\nText { id: textItem }\n}\n</c>\n\nNow Button.qml can be used in other qml document as\n<c>\nButton { buttonText: "Click Me" }\n</c>\n\n4) List property\nList of valus can be declared as \n<c>\n[default] property list<<objectType>> propertyName: <value>\n<<MyRectangle.qml>>\nimport QtQuick 2.0\nRectangle {\n// declaration without initialization\n property list<Rectangle> siblingRects\n// declaration with initialization\nproperty list<Rectangle> childRects: [Rectangle { color: "red" },Rectangle { color: "blue"} ]\n}\n</c>\n\n5) Grouped property\nclass member of  object type can be field inititalized in curly braces\n<c>\nText {\n//dot notation\n font.pixelSize: 12;; font.b: true\n}\n</c>\n\nfont object properites can be grouped in curly braces\n<c>\nText {\n//group notation\nfont { pixelSize: 12; b: true }\n}\n</c>\n\n4) Default property\nDefault property come into the picture when a object type is getting instantiated in a parent object type without gettig assigned to any of the parent properties. In this fashon parent default property holds the children.\n\n<b>c) Signal property</b>\nSignal is function that gets rasied by hardware or just by calling the function. Like unix signal, qml signal has handler associated to it.\nsignal can be declared as \n<c>\n  signal <signalName>[([<type> <parameter name>[, -]])]\n</c>\n<MySignal.qml>\n<c>\nimport QtQuick 2.0\nItem {\n signal clicked // with no argument, braces are not required\n signal hovered()\n signal actionPerformed(string action, var actionResult)\n}\n</c>\n\n<b>d)signal handler property</b>\nQml also supports inbuilt handler for properites in the format "on<Property>Changed"\n<<MyTextInput.qml>>\n<c>\nimport QtQuick 2.0\nTextInput {\n text: "Change this!"\n onTextChanged: console.log("Text has changed to:", text)\n}\n</c>\n\nSignal handler must be in nomenculture on<SignalName> or any method can also be nominated as signal handler.\n<SquareButton.qml>\n<c>\nRectangle {\nid: root\nsignal activated(real xPosition, real yPosition)\nsignal deactivated\nproperty int side: 100\nidth: side; height: side\nMouseArea {\nanchors.fill: parent\nonPressed: root.activated(mouse.x, mouse.y)//handler has not arguments declaration explictly\nonReleased: root.deactivated()\n}\n}\n</c>\n\nclass method can also be used as signal hander\n<c>\nRectangle {\nid: relay\nsignal messageReceived(string person, string notice)\nComponent.onCompleted: {\nrelay.messageReceived.connect(sendToPost)\nrelay.messageReceived.connect(sendToTelegraph)\nrelay.messageReceived.connect(sendToEmail)\nrelay.messageReceived("Tom", "Happy Birthday")\n}\nfunction sendToPost(person, notice) {\nconsole.log("Sending to post: " + person + ", " + notice)\n}\nfunction sendToTelegraph(person, notice) {\nconsole.log("Sending to telegraph: " + person + ", " + notice)\n}\nfunction sendToEmail(person, notice) {\nconsole.log("Sending to email: " + person + ", " + notice)\n}\n}\n</c>\n\n<b>e) Mehtod property</b>\nIn c++ counterpart method can be declared through Q_PROPERTY() and Q_SLOT() for slots. In qml it through\n<c>\nfunction <functionName>([<parameterName>[, ...]]) { <body> }\n</c>\n<<MyText.qml>>\n<c>\nimport QtQuick 2.0\nItem {\nwidth: 200; height: 200\nMouseArea {\nanchors.fill: parent\nonClicked: label.moveTo(mouse.x, mouse.y)\n}\nText {\nid: label\nfunction moveTo(newX, newY) {\nlabel.x = newX;\nlabel.y = newY;\n}\ntext: "Move me!"\n}\n}\n</c>\n\n\n<b>f) Attached property</b>\nattached properties are kind of static member in C++ where attributes are accessed through class. Here it is accessed through object type rather than instantiated objects. attached properties can be accessed only in current level and not to its children.\n\nit is declared as \n<c>\n<AttachingType>.<propertyName>\n<AttachingType>.on<SignalName>\n<<MyListView.qml>>\nimport QtQuick 2.0\nListView {\nwidth: 240; height: 320\nmodel: 3\ndelegate: Rectangle {\nwidth: 100; height: 30\ncolor: ListView.isCurrentItem ? "red" : "yellow"\n}\n}\n</c>\n\n<h>\n*Qt Property with Enum\n</h>\n\nEnum from c++ side is availabe at qml side through Q_ENUMS() macro\nc++\n<c>\nclass Person:public QObject {\nQ_OBJECT\nQ_ENUMS(Height)\nQ_PROPERTY(Height height READ height WRITE setHeight)\npublic:\nPerson(QObject *p=0);\nenum Height{SHORT=0,MID,TALL};\nHeight height() const;\nvoid setHeight(Height);\nprivate:\nHeight _height;\n};\n#endif\n</c>\n\nqml\n<c>\nimport QtQuick 2.0\nimport Person 1.0\nItem{\nproperty list<Person> personmodel:[Person{height:Person.MID}, Person{height:Person.TALL} ]\nListView{\nwidth:200;height:400\nmodel:personmodel\ndelegate:Text{\ntext:height\n}\n}\n}\n</c>\n\n<h>\n*Getting & Setting Qt Properties\n</h>\nQt properties can be get as set through READ and WRITE keyword in Q_PROPERTY macro\n\n<c>\n<l><person.h></l>\nclass Person:public QObject {\nQ_OBJECT\nQ_PROPERTY(QString name READ name WRITE setName)\npublic:\nPerson(QObject *p=0);\nQString name() const;\nvoid setName(const QString&);\nprivate:\nQString name;\n};\n\n<l>person.cpp</l>\nQString Person::name() const{ return _name; }\nvoid Person::setName(const QString& name){\nif (name!=_name){\n_name=name;\n//emit nameChanged();\n}\n}\n</c>\n\n<h>\n*Dynamic Properties\n</h>\nProperies in QMetaObject of QObject can be added dynamically. It is less type safe though.\n<c>\nvoid func(QObject *obj){\nobj->setProperty("newintname",1);\nobj->setProperty("newstringname","anotherstring");\nobj->setProperty("newvariantname",QVariant::fromValue(25));\nint propint=obj->property("newintname").toInt();\nQString propstring=obj->property("newstringname").toString();\nQVariant propvariant=obj->property("newvariantname").toInt();\n</c>\n\n<h>\n*Signal and Slots\n</h>\nSignals are added through signals macro. A property provide binding when NOTIFY keyword is added in Q_PROPERTY'
'3!ABS SBA!Building Blocks of QML!ABS SBA!*Import QML document in another QML\ndocument as a package!ABS SBA!<h>\n*QuickItem\n</h>\nThe QQuickItem is c++ class for Object type \'Item\' in QtQuick. It provides most basic of all visual items. QQuickItem does not have any visual effect and it is item that is drawn on QQuickView.\nFor customised drawing\n<c>\n     QQuickItem\n        / \\\n         -\n         |\n    -----------\n    | MyItem  |\n    -----------------------------\n    |QQuickItem::ItemHasContents|\n    |QQuickItem::updatePainNode |\n    -----------------------------\n</c>\n\nUse QPaintedItem for custom drawing.\n<c>\n      QQuickPaintedItem\n         / \\\n          -\n          |\n      -----------------\n      | MyPaintedItem |\n      -------------------\n      | paint(QPainter*)|\n      -------------------\n</c>\n\n<c>\nimport QtQuick 2.0\nItem {\n Image {\n source: "tile.png"\n }\n Image {\n x: 80\n width: 100\n height: 100\n source: "tile.png"\n }\n Image {\n x: 190\n width: 100\n height: 100\n fillMode: Image.Tile\n source: "tile.png"\n }\n}\n</c>\n\n<h>\n*Variant\n - QVariant and QML\n</h>\nThe var type is a generic property type that can refer to any data type. It is equivalent to QVariant in C++ side. It is equivalent to a regular JavaScript variable. For example, var properties can store numbers, strings, objects, arrays and functions:\n\n<c>\nItem {\n  property var aNumber: 100\n  property var aBool: false\n  property var aString: "Hello world!"\n  property var anotherString: String("#FF008800")\n  property var aColor: Qt.rgba(0.2, 0.3, 0.4, 0.5)\n  property var aRect: Qt.rect(10, 10, 10, 10)\n  property var aPoint: Qt.point(10, 10)\n  property var aSize: Qt.size(10, 10)\n  property var aVector3d: Qt.vector3d(100, 100, 100)\n  property var anArray: [1, 2, 3, "four", "five", (function() { return "six"; })]\n  property var anObject: { "foo": 10, "bar": 20 }\n  property var aFunction: (function() { return "one"; })\n  property var car: new Object({wheels: 4})\n  property var car1: {\'wheels\':4}\n  property var car2: ({wheels:4})\n}\n</c>\n\n<h>\n*Variant Containers\n - QVariantList\n - QVariantMap\n - QList\n - QQmlListProperty\n</h>\n <b>-QVariantList</b>\n <b>-QVariantMap</b>\nQml\n<c>\n//*.qml\nItem {\n function readValues(anArray, anObject) {\n  for (var i=0; i<anArray.length; i++)\n  console.log("Array item:", anArray[i])\n  for (var prop in anObject) {\n  console.log("Object item:", prop, "=", anObject[prop])\n  }\n }\n}\n</c>\nC++\n<c>\nQQuickView view(QUrl::fromLocalFile("MyItem.qml"));\nQVariantList list;\nlist << 10 << QColor(Qt::green) << "bottles";\nQVariantMap map;\nmap.insert("language", "QML");\nmap.insert("released", QDate(2010, 9, 21));\nQMetaObject::invokeMethod(view.rootObject(), "readValues",\n Q_ARG(QVariant, QVariant::fromValue(list)),\n Q_ARG(QVariant, QVariant::fromValue(map)));\n</c>\n\n <b>-QQmlListProperty</b>\nThe QQmlListProperty class allows applications to expose list-like properties to QML.\nQML has many list properties, where more than one object value can be assigned. The use of a list property from QML looks like this:\n\n<c>\nFruitBasket {\n fruits: [\n Apple {},\n Orange{},\n Banana{}\n ]\n}\n</c>\n\nOn c++ side it can be added to class like\n<c>\nclass Fruit:public QObject{\n}\n\nclass FruitBasket{\n Q_PROPERTY(QQmlListProperty<Fruit> fruits READ fruits);\npublic:\nQQmlListProperty fruits()const;\nprivate:\nQList<Fruit*> _fruits;\n}\n</c>\nit can not read and write, only read.\n\n<h>\n*Import QML document in another QML\ndocument as a package\n</h>\n<c>\nmyapp\n    |- mycomponents\n        |- CheckBox.qml\n        |- DialogBox.qml\n        |- Slider.qml\n    |- main\n        |- application.qml\n</c>\n\n<application.qml>\n<c>\n<import "../mycomponents"\n\nDialogBox {\n    CheckBox {\n        // ...\n    }\n    Slider {\n        // ...\n    }\n}\n</c>\n\n<c>\nimport "../mycomponents" as MyComponents\n\nMyComponents.DialogBox {\n    // ...\n}\n</c>\n\nfor remotely located directory, directory must have a file \'qmldir\'\n\n<qmldir>\n<c>\nCheckBox CheckBox.qml\nDialogBox DialogBox.qml\nSlider Slider.qml\n</c>\n\ndirectory can be imported like\n<c>\nimport "http://www.my-example-server.com/myapp/mycomponents"\n\nDialogBox {\n    CheckBox {\n        // ...\n    }\n    Slider {\n        // ...\n    }\n}\n</c>'
'4!ABS SBA!Composing UIs!ABS SBA!*Use anchor layout to place current window\nwith imported window in some layout fashion.!ABS SBA!<h>\n*Nested Items\n</h>\n\n<c>\n                <<parent/child>>\n   QQuickItem <>---------------> QQuickItem\n</c>\n   \nOne QQuickItem is nested in other QQuickItem. Its like parent child relationship.\n<c>\nimport QtQuick 2.0\nRectangle {           <cc><l>//<---------- Parent</l></cc>\n width: 400; height: 400\n color: "lightblue"\n Rectangle {          <cc><l>//<---------- Child</l></cc>\n  x: 50; y: 50; width: 300; height: 300\n  color: "green"\n  Rectangle {\n   x: 200; y: 150; width: 50; height: 50\n   color: "white"\n  }\n }\n}\n</c>\n\n<h>\n*Graphical QML Types\n</h>\n\nColors\n<c>\nimport QtQuick 2.0\nItem {\nwidth: 300; height: 100\nRectangle {\nx: 0; y: 0; width: 100; height: 100; color: "#ff0000"\n}\nRectangle {\nx: 100; y: 0; width: 100; height: 100\ncolor: Qt.rgba(0,0.75,0,1)\n}\nRectangle {\nx: 200; y: 0; width: 100; height: 100; color: "blue"\n}\n}\n</c>\n\nImages\n<c>\nimport QtQuick 2.0\nRectangle {\n width: 400; height: 400\n color: "black"\n Image {\n  x: 150; y: 150\n  source: "../images/rocket.png"\n  scale:2.0\n  rotation:45.0\n }\n}\n</c>\n\nGradients\n<c>\nimport QtQuick 2.0\nRectangle {\n width: 400; height: 400\n gradient: Gradient {\n  GradientStop {\n   position: 0.0; color: "green"\n  }\n  GradientStop {\n   position: 1.0; color: "blue"\n  }\n }\n}\n</c>\nGradient Images\n<c>\nimport QtQuick 2.0\nRectangle {\n width: 425; height: 200\n Image {\n  x: 0; y: 0\n  source: "../images/vertical-gradient.png"\n }\n Image {\n  x: 225; y: 0\n  source: "../images/diagonal-gradient.png"\n }\n}\n</c>\n\nBorder Images\n<c>\nBorderImage {\n source: "content/colors.png"\n border { left: 30; top: 30; right: 30; bottom: 30; }\n horizontalMode: BorderImage.Stretch\n verticalMode: BorderImage.Repeat\n ...\n}\n</c>\n\n\n<h>\n*Text Type\n</h>\n\nText Elements\n<c>\nimport QtQuick 2.0\nRectangle {\n width: 400; height: 400\n color: "lightblue"\n Text {\n  x: 100; y: 100\n  text: "Qt Quick"\n  font.family: "Helvetica"\n  font.pixelSize: 32\n }\n}\n</c>\n\nText Input\n<c>\nimport QtQuick 2.0\nRectangle {\n width: 400; height: 400\n color: "lightblue"\n TextInput {\n  x: 50; y: 100; width: 300\n  text: "Editable text"\n  font.family: "Helvetica"; font.pixelSize: 32\n }\n}\n</c>\n\n<h>\n*Anchor Layouts\n</h>\n\nAnchor layout works only among parent and children.\n\n<m>http://minhinc.42web.io/image/qml-slide-composinguianchor.png</m>\n\nVarious anchors attributes\n<cc>\nanchors.top : AnchorLine\nanchors.bottom : AnchorLine\nanchors.left : AnchorLine\nanchors.right : AnchorLine\nanchors.horizontalCenter : AnchorLine\nanchors.verticalCenter : AnchorLine\nanchors.baseline : AnchorLine\nanchors.fill : Item\nanchors.centerIn : Item\nanchors.margins : real\nanchors.topMargin : real\nanchors.bottomMargin : real\nanchors.leftMargin : real\nanchors.rightMargin : real\nanchors.horizontalCenterOffset : real\nanchors.verticalCenterOffset : real\nanchors.baselineOffset : real\nanchors.alignWhenCentered : bool\n</cc>\n\n<c>\nimport QtQuick 2.0\nRectangle {\nwidth: 400; height: 200\ncolor: "lightblue"\n Image { id: book; source: "../images/book.svg"\n anchors.left: parent.left\n anchors.leftMargin: parent.width/16\n anchors.verticalCenter: parent.verticalCenter }\n Text { text: "Writing"; font.pixelSize: 32\n anchors.left: book.right\n anchors.leftMargin: 32\n anchors.baseline: book.verticalCenter }\n}\n</c>'
'5!ABS SBA!User Input!ABS SBA!*Emit signal when mouse moves over an area!ABS SBA!<h>\n*Keyboard Navigation and Focus\n</h>\n\nWhen the user presses or releases a key, the following occurs:\n1) Qt receives the key action and generates a key event.\n2) If a QQuickWindow is the active window, the key event is delivered to it.\n3) The key event is delivered by the scene to the Item with active focus. If no item has active focus, the key event is ignored.\n4) If the QQuickItem with active focus accepts the key event, propagation stops. Otherwise the event is sent to the Item\'s parent until the event is accepted, or the root item is reached.\n\nRectangle has active focus and the A key is pressed, the event will not be propagated further. Upon pressing the B key, the event will propagate to the root item and thus be ignored.\n<c>\nRectangle {\n width: 100; height: 100\n focus: true    <-----------------item with focus attribute\n Keys.onPressed: {\n  if (event.key == Qt.Key_A) {\n   console.log(\'Key A was pressed\');\n   event.accepted = true;\n  }\n }\n}\n</c>\n\nIf the root Item is reached, the key event is ignored and regular Qt key handling continues.\n\n\n<h>\n*Input Focus\n - Focus property\n - Focus Order\n - Active Focus\n - Focus Scope\n</h>\n\n - <b>Focus property</b>\nSubItem containing the \'focus\' property true recieves the focus\n<c>\nRectangle {\n color: "lightsteelblue"; width: 240; height: 25\n Text { id: myText }\n Item {\n  id: keyHandler\n  focus: true\n  Keys.onPressed: {\n   if (event.key == Qt.Key_A)\n    myText.text = \'Key A was pressed\'\n   else if (event.key == Qt.Key_B)\n    myText.text = \'Key B was pressed\'\n   else if (event.key == Qt.Key_C)\n    myText.text = \'Key C was pressed\'\n  }\n }\n}\n</c>\n\n - <b>Focus Order</b>\nFocus Order is decided among items for which \'focus\' attributes are set true. If Item is reused in other component then last item with focus attribute would receive the focus.\n\n//Window code that imports MyWidget\n<c>\nRectangle {\n id: window\n color: "white"; width: 240; height: 150\n Column {\n  anchors.centerIn: parent; spacing: 15\n  MyWidget {\n   focus: true             //set this MyWidget to receive the focus\n   color: "lightblue"\n  }\n  MyWidget {\n   color: "palegreen"\n  }\n }\n}\n</c>\n\nThe MyWidget code:\n<c>\nRectangle {\n id: widget\n color: "lightsteelblue"; width: 175; height: 25; radius: 10; antialiasing: true\n Text { id: label; anchors.centerIn: parent}\n focus: true\n Keys.onPressed: {\n  if (event.key == Qt.Key_A)\n   label.text = \'Key A was pressed\'\n  else if (event.key == Qt.Key_B)\n   label.text = \'Key B was pressed\'\n  else if (event.key == Qt.Key_C)\n   label.text = \'Key C was pressed\'\n }\n}\n</c>\nfocus order can be shifted to other userinput through KeyNavigation.tab press.\n\n<c>\nimport QtQuick 2.0\nRectangle{\nwidth:200:height:200\ncolor:"steelblue"\n TextInput{\n id:input1\n x:8;y:8\n width:96;height:20\n focus:true\n text:"Text Input 1"\n KeyNavigation.tab:input2\n }\n TextInput {\n id:input2\n x:8;y:32\n width:96;height:20\n text:"Text Input 2"\n KeyNavigation.tab:input1\n }\n}\n</c>\n\n -<b>Active focus</b>\nWhich Item has the focus can be decided with property activeFocus.\n<c>\nText {\n text: activeFocus ? "I have active focus!" : "I do not have active focus"\n}\n</c>\n\n -<b>Focus Scope</b>\n<m>https://www.youtube.com/embed/lIAway_X3E8</m>\ntwo textinput inside an Item container can recieve KeyNavigation.tab but to textinput inside two Item container can not receive KyNavigation.tab. In this case Item container is placed in Focus scope.inside a focus scope last textinput with \'focus:true\' would receive the key focus.\n<c>\nimport QtQuick 2.5\nFocusScope{\nwidth:96;height:input.height+8\n Rectangle{\n anchors.fill:parent\n color:"lightsteelblue"\n border.color:"gray"\n }\n property alias text:input.text\n TextInput{\n id:input\n height:30\n anchors.fill:parent\n anchors.margins:4\n focus:true\n }\n}\nimport QtQuick 2.0\nRectangle{\nwidth:200;height:200\n Column{\n anchors.centerIn:parent\n spacing:20\n  FocusScopeTextInput{\n  id:input1\n  text:"Input1"\n  KeyNavigation.tab:input2\n  }\n  FocusScopeTextInput{\n  id:input2\n  text:"Input2"\n  KeyNavigation.tab:input1\n  }\n }\n}\n</c>\n\n<m>http://minhinc.42web.io/image/qml-slide-inputfocusscope.png</m>\n\n<h>\n*Handling Keyboard input\n - Key-Specific Handlers\n - All keys Handler\n - Key Event Propogation\n - Event Propogation is Convenient\n</h>\nAny visual item can receive keyboard input through the Keys attached type.\nKeys can be handled via the onPressed and onReleased signal properties.\nThe signal properties have a KeyEvent parameter, named event which contains details of the event. If a key is handled event.accepted should be set to true to prevent the event from propagating up the item hierarchy. \n\nKyes\nProperties\n<cc>\nenabled : bool\nforwardTo : list<Object>\npriority : enumeration \n</cc>\n\nSignals\n<cc>\nasteriskPressed(KeyEvent event)\nbackPressed(KeyEvent event)\nbacktabPressed(KeyEvent event)\ncallPressed(KeyEvent event)\ncancelPressed(KeyEvent event)\ncontext1Pressed(KeyEvent event)\ncontext2Pressed(KeyEvent event)\ncontext3Pressed(KeyEvent event)\ncontext4Pressed(KeyEvent event)\ndeletePressed(KeyEvent event)\ndigit[0-9]Pressed(KeyEvent event)\ndownPressed(KeyEvent event)\nenterPressed(KeyEvent event)\nescapePressed(KeyEvent event)\nflipPressed(KeyEvent event)\nhangupPressed(KeyEvent event)\nleftPressed(KeyEvent event)\nmenuPressed(KeyEvent event)\nnoPressed(KeyEvent event)\npressed(KeyEvent event)\nreleased(KeyEvent event)\nreturnPressed(KeyEvent event)\nrightPressed(KeyEvent event)\nselectPressed(KeyEvent event)\nspacePressed(KeyEvent event)\ntabPressed(KeyEvent event)\nupPressed(KeyEvent event)\nvolumeDownPressed(KeyEvent event)\nvolumeUpPressed(KeyEvent event)\nyesPressed(KeyEvent event) \n</cc>\n\n <b>- Key-Specific Handlers</b>\n <b>- All keys Handler</b>\n\n<c>\nItem {\nanchors.fill: parent\nfocus: true\n Keys.onPressed: {\n  if (event.key == Qt.Key_Left) {\n  console.log("move left");\n  event.accepted = true;\n  }\n }\n}\n</c>\n\n <b>-Key Event Propagation</b>\n\n<c>\nforwardTo : list<Object>\n</c>\n\nThis property provides a way to forward key presses, key releases, and keyboard input coming from input methods to other items. This can be useful when you want one item to handle some keys (e.g. the up and down arrow keys), and another item to handle other keys (e.g. the left and right arrow keys). Once an item that has been forwarded keys accepts the event it is no longer forwarded to items later in the list.\nThis example forwards key events to two lists:\n\n<c>\nItem {\n ListView {\n id: list1\n // ...\n }\n ListView {\n id: list2\n // ...\n }\n Keys.forwardTo: [list1, list2]\n focus: true\n}\n</c>\n\n<h>\n*Multi-Touch\n - Common Multi-Touch Gestures\n - Handling Overlapping Touch Areas\n</h>\n\nMultiPointTouchArea\n\nProperties\n<cc>\nmaximumTouchPoints : int\nminimumTouchPoints : int\nmouseEnabled : bool\ntouchPoints : list<TouchPoint> \n</cc>\n\nSignals\n<cc>\ncanceled(list<TouchPoint> touchPoints)\ngestureStarted(GestureEvent gesture)\npressed(list<TouchPoint> touchPoints)\nreleased(list<TouchPoint> touchPoints)\ntouchUpdated(list<TouchPoint> touchPoints)\nupdated(list<TouchPoint> touchPoints) \n</cc>\n\nA MultiPointTouchArea is an invisible item that is used to track multiple touch points.\n\n<c>\nimport QtQuick 2.0\nRectangle {\nwidth: 400; height: 400\n MultiPointTouchArea {\n anchors.fill: parent\n  touchPoints: [\n  TouchPoint { id: point1 },\n  TouchPoint { id: point2 }\n  ]\n }\n Rectangle {\n width: 30; height: 30\n color: "green"\n x: point1.x\n y: point1.y\n }\n Rectangle {\n width: 30; height: 30\n color: "yellow"\n x: point2.x\n y: point2.y\n }\n}\n</c>\n\n<h>\n*Mouse/Single-Touch\n - Tap\n - Double-Tap\n - Top and Hold\n</h>'
'6!ABS SBA!Components and Structures!ABS SBA!*Write qml component as a separate .qml file!ABS SBA!<h>\n*Components\n</h>\n\n<m>https://www.youtube.com/embed/bq9GD0c0hYQ</m>\nA component is a resuable, encapsulated QML type with well-defined interfaces. Components are often defined by component files - that is, .qml files. the component type essentially allows QML componens to be defined inline, within a QML document, rather than as a separate QML file.\n\n<c>\nimport QtQuick 2.0\nItem {\nwidth: 100; height: 100\n Component {\n id: redSquare\n  Rectangle {\n  color: "red"\n  width: 10\n  height: 10\n  }\n }\n Loader { sourceComponent: redSquare }\n Loader { sourceComponent: redSquare; x: 20 }\n}\n</c>\n\n<h>\n*Dividing code into Components\n - Creating new Items through new .qml file\n - Creating Component dynamically\n</h>\n\n<m>https://www.youtube.com/embed/g5LsBYS_t8U</m>\n <b>-Creating new Items through new .qml file</b>\n<c>\n import QtQuick 2.0\n Rectangle { width: 200; height: 200; color: "red" }\n Rectangle { width: 200; height: 200; color: "blue" } // invalid two root object\n</c>\n\nCreating new Button type\n  // Button.qml\n<c>\n import QtQuick 2.0\n Rectangle {\n  width: 100; height: 100\n  color: "red"\n  MouseArea {\n   anchors.fill: parent\n   onClicked: console.log("Button clicked!")\n  }\n }\n</c>\n\nThe Button type can then be used in an application:\n  // application.qml\n<c>\n import QtQuick 2.0\n Column {\n  Button { width: 50; height: 50 }\n  Button { x: 50; width: 100; height: 50; color: "blue" }\n  Button { width: 50; height: 50; radius: 8 }\n }\n\n          -------------------\n          |Item : QQuickItem|\n          -------------------\n                 .\n                / \\\n                 -\n                 |\n            -----------\n            |Rectangle|\n            -----------\n                 .\n                / \\\n                 -\n                 |\n            -----------\n            | : Button| // Button inherits Rectangle in Button.qml and\n            ----------- // gets instantiated in application.qml\n</c>\n\n <b>- Creating Component dynamically</b>\na)\n<c>\nimport QtQuick 2.0\nItem {\n width: 100; height: 100\n <g>Component</g> {\n  id: redSquare\n  Rectangle {\n   color: "red"\n   width: 10\n   height: 10\n  }\n }\n Loader { sourceComponent: redSquare }\n Loader { sourceComponent: redSquare; x: 20 }\n</c>\n\nwhere id is extra provided than file component\nb)\n<c>\nvar component = Qt.createComponent("Button.qml");\n if (component.status == Component.Ready)\n  component.createObject(parent, {"x": 100, "y": 100});\n</c>\n\nc)\n<c>\nItem {\n id: root\n width: 500; height: 500\n Component {\n  id: myComponent\n  Rectangle { width: 100; height: 100; color: "red" }\n }\n Component.onCompleted: {\n  myComponent.createObject(root)\n  myComponent.createObject(root, {"x": 200})\n }\n}\n</c>\n\n\n<h>\n*Modules\n</h>\n\nQML Modules \nA QML module provides versioned types and JavaScript resources in a type namespace which may be used by clients who import the module. The types which a module provides may be defined in C++ within a plugin, or in QML documents. Modules make use of the QML versioning system which allows modules to be independently updated.\n\nDefining of a QML module allows:\n1)The sharing of common QML types within a project - for example, a group of UI components that are used by different windows\n2)The distribution of QML-based libraries\n3)The modularization of distinct features, so that applications only load the libraries necessary for their individual needs\n4) Versioning of types and resources so that the module can be updated safely without breaking client code \n\n<h>\n*Write qml component as a separate .qml file\n</h>\n\n<c>\n//ButtonC.qml\n  <g>Rectangle</g>\n    / \n     -                         \n     |\n   <g>ButtonC</g> <>--+---> <l>Text</l>\n               |\n               +---> <l>MouseArea</l>\n</c>\n\n<c>\n<l><ButtonC.qml></l>\n<g>import</g> QtQuick 2.0\n<g>Rectangle</g> {\nid:button\nproperty alias text: label.text\nsignal clicked()\ncolor: "blue"\n Text {\n id: label\n anchors.centerIn: parent\n }\n MouseArea{\n anchors.fill: parent\n onClicked: button.clicked()\n }\n}\n</c>\n\n<h>\n*qmldir file\n - Directory import\n - Module import\n</h>\n\nThere are two distinct types of qmldir files:\nQML document directory listing files\nQML module definition files\n\n <b>-Directory import</b>\nall qml file in a directory,i.e. directory1 can be import using\n<c>\nimport "./directory1"\n</c>\nor\n<c>\nimport "./directory1" as mydirectory\n\nmydirectory.Rectangle\n...\n</c>\n\nAn internal object type declaration allows a QML document to be registered as a type which becomes available only to the other QML documents contained in the directory import. The internal type will not be made available to clients who import the directory.\nExample:\n<c>\ninternal HighlightedButton HighlightedBtn.qml\n</c>\n\nA JavaScript resource declaration allows a JavaScript file to be exposed via the given identifier.\nExample:\n<c>\n  MathFunctions mathfuncs.js\n</c>\nAdditionally, JavaScript resources in the directory are not exposed to clients unless they are declared in a qmldir file. \n\nRemotely located directory\nA directory of QML files can also be imported from a remote location if the directory contains a directory listing qmldir file.  For example, if the myapp directory in the previous example was hosted at "http://www.my-example-server.com", and the mycomponents directory contained a qmldir file defined as follows:\n\n<c>\nhttp://www.my-example-server.com/ myapp\n                                       |- mycomponents\n                                           |- CheckBox.qml\n                                           |- DialogBox.qml\n                                           |- Slider.qml\n                                           |- qmldir\n</c>\nqmldir\n<c>\n  CheckBox CheckBox.qml\n  DialogBox DialogBox.qml\n  Slider Slider.qml\n</c>\n\nmain.qml\n<c>\nimport "http://www.my-example-server.com/myapp/mycomponents"\nDialogBox {\n CheckBox {\n // ...\n }\n Slider {\n // ...\n }\n}\n</c>\n\n <b>-Module Import</b>\nModule import happens with versioning. A qmldir file must be present in the module directory\n<c>\nimport MyModule 1.0\n</c>\n\nThere must be directory called MyModule or MyModule.1 or MyModule.1.0 . Directory containing module directory needs to be add to QQmlEngine::addImportPath.\nqmldir in side MyModule directory\n<c>\n  module MyModule\n  CustomButton 1.0 CustomButton.qml\n  CustomButton 2.0 CustomButton20.qml\n  CustomButton 2.1 CustomButton21.qml\n  plugin examplemodule\n  MathFunctions 2.0 mathfuncs.js\n</c>\n\nfor\n<c>\nimport a.b.c.d.e 1.0\n</c>\nqmldir file should be available in directory relatative to QQmlEngine::addImportPath("xyz") as\nxyz/a/b/c/d/e'
'7!ABS SBA!State and Transitions!ABS SBA!!ABS SBA!<h>\n*States\n</h>\n\n<m>https://www.youtube.com/embed/Y1tAvBliWa4</m>\n\n<m>https://www.youtube.com/embed/cDf9OiVsCeU</m>\n\nA state is a set of batched changes from the default configuration. All "Item" QtQuick type have a default state (state=="") that defines the default configuration of objects and property values. New states can be defined by adding State items to the states property to allow items to switch between different configurations.\n\nVarious changes that can be achieved through state are\n<c>\n<b>PropertyChanges</b>\n<b>AnchorChanges</b>\n<b>ParentChanges</b>\n</c>\n<m>http://minhinc.42web.io/image/qml-slide-statetransition.png</m>\n\nItem QtQuick type has two properties\n<c>\nstate:string\nstates:list<State>\n</c>\nSample Code of states property of Item\n<c>\nimport QtQuick 2.0\nRectangle {\n id: root               <cc>    --------- state triggering in signal handler </cc>\n width: 100; height: 100<cc>   /  </cc>\n MouseArea {            <cc>  /   </cc>\n  id: mouseArea         <cc>  |   </cc>\n  anchors.fill: parent  <cc>  v   </cc>\n  onClicked: root.state == \'\' ? root.state = "red_color" : (root.state==\'red_color\' ? root.state = \'blue_color\':root.state="");\n }\n states: [\n  State {\n   name: "red_color"\n   PropertyChanges { target: root; color: "red" } <cc><---Changing targets property</cc>\n  },\n  State {\n   name: "blue_color"\n   PropertyChanges { target: root; color: "blue" } <cc><---Changing targets property</cc>\n  }\n ]\n}\n</c>\n<h>\n*State Conditions\n</h>\nState QtQuick type has following property\n<c>\nchanges : list<Change>\nextend : string\nname : string\nwhen : bool \n</c>\nState would take effect only when \'when\' property holds true\n<c>\nRectangle {\n id: myRect\n width: 100; height: 100\n color: "red"\n MouseArea { id: mouseArea; anchors.fill: parent }\n states: State {\n  name: "hidden"; when: mouseArea.pressed\n  PropertyChanges { target: myRect; opacity: 0 }\n }\n}\n</c>\n<h>\n*Transitions\n</h>\n\n<m>https://www.youtube.com/embed/jUqPG62NrRo</m>\n\nTransition comes into effect when Item changes its state. Item sits on default state in initial phase.\nTransition has following property\n\n<c>\nanimations : list<Animation>\nenabled : bool\nfrom : string\nreversible : bool\nrunning : bool\nto : string \n</c>\n\nHere transition triggers NumberAnimation.\n<c>\nimport QtQuick 2.0\nRectangle {\n id: rect\n width: 100; height: 100\n color: "red"\n MouseArea {\n  id: mouseArea\n  anchors.fill: parent\n }\n states: State {\n  name: "moved"; when: mouseArea.pressed\n  PropertyChanges { target: rect; x: 50; y: 50 }\n }\n transitions: Transition {\n  NumberAnimation { properties: "x,y"; easing.type: Easing.InOutQuad }\n }\n}\n</c>\n\n\nTransitions During State Changes\nQt Quick States are property configurations where a property may have different values to reflect different states. State changes introduce abrupt property changes; animations smooth transitions to produce visually appealing state changes.\n\nThe Transition type can contain animation types to interpolate property changes caused by state changes. To assign the transition to an object, bind it to the transitions property.\n\n<cb>\n<l><main.qml></l>\nimport QtQuick 2.0\nRectangle {\nwidth: 75; height: 75\nid: button\nstate: "RELEASED"\n MouseArea {\n anchors.fill: parent\n onPressed: button.state = "PRESSED"\n onReleased: button.state = "RELEASED"\n }\n states: [\n  State {\n  name: "PRESSED"\n  PropertyChanges { target: button; color: "lightblue"}\n  },\n  State {\n  name: "RELEASED"\n  PropertyChanges { target: button; color: "green"}\n  }\n ]\n transitions: [\n  Transition {\n  from: "PRESSED"\n  to: "RELEASED"\n  ColorAnimation { target: button; duration: 100}\n  },\n  Transition {\n  from: "RELEASED"\n  to: "PRESSED"\n  ColorAnimation { target: button; duration: 100}\n  },\n  Transition {\n  to: "*"\n  PropertyAnimation { target: button; properties:"x"; duration: 100}\n  }\n ]\n}\n</cb>\n\n<m>http://minhinc.42web.io/image/qml-slide-statetransition1.png</m>'
'8!ABS SBA!Dynamic Creation of Items!ABS SBA!*Define component dynamically!ABS SBA!<h>\n*Creating custom Item\n</h>\nTypically an <g>Item</g> placed in a file(document) as root element becomes a component. This new component behaves as subclass of the root <g>Item</g>. i.e. <g>Rectangle</g> is an item and when it is placed in <g>Button.qml</g> file, \'Button\' becomes a new type. Editing <g>Button.qml</g> and adding attributes and methods to <g>Rectangle</g> is extending the class <g>Rectangle</g> where existing methods can be overriden.\n\n<c>\n<l>//ButtonC.qml</l>\n  <g>Rectangle</g>\n    / \\\n     -                         \n     |\n   <g>ButtonC</g> <>--+---> <g>Text</g>\n               |\n               +---> <g>MouseArea</g>\n</c>\n\n<cb>\n<l><ButtonC.qml></l>\nimport QtQuick 2.0\nRectangle {\nid:button\nproperty alias text: label.text\nsignal clicked()\ncolor: "blue"\n Text {\n id: label\n anchors.centerIn: parent\n }\n MouseArea{\n anchors.fill: parent\n onClicked: button.clicked()\n }\n}\n</cb>\n\n<cb>\n<l><LabelC.qml></l>\nimport QtQuick 2.7\nRectangle{\n color:"#dddddd"\n Text{\n id:label\n anchors.centerIn:parent\n anchors.verticalCenter:parent.verticalCenter\n property int count:1\n font.family: "Helvetica"\n font.pointSize: 24\n color: "red"\n height:parent.height\n text:"<b>"+this.count+"</b>"\n  function incrementcount(){\n   this.count=this.count+1\n  }\n }\n Timer{\n interval:1000;repeat:true;running:true\n onTriggered:label.incrementcount()\n }\n}\n</cb>\n\n<cb>\n<l><main.qml></l>\nimport QtQuick 2.7\nimport QtQuick.Layouts 1.3\nRectangle{\nid: toplevel\ncolor: "black"\n ColumnLayout{\n spacing:20\n anchors.centerIn:parent\n  LabelC{\n  width:100;height:50\n  }\n  ButtonC{\n  width:100;height:50\n  text:"Click Me"\n  onClicked:toplevel.color="white"\n  anchors.centerIn:parent\n   MouseArea {\n   //  onPressedChanged: button.color = (pressed) ? "red" : "blue"\n   }\n  }\n }\n}\n</cb>\n\n<m>http://minhinc.42web.io/image/qml-slide-dynamicitemcreation.png</m>\n<h>\n*Creating Items Dynamically\n - Procedural Method\n - Procedural/Declarative Creation\n - Declarative Method\n</h>\n\n<m>https://www.youtube.com/embed/ZVvGC9jegA8</m>\n<b>-Procedural Method</b>\nA document file (i.e. ButtonC.qml) can be crated as a <g>Component</g>, through <g>Qt.createComponent()</g>, with single root Item or through a <g>componentbbject</g> type that is declared in a document file itself. <g>Component</g> declared in a document file behave as an root Item \'declaration\' which is \'defined\' by <g><componentobject>.createObject()</g> function. Component from a document file is first created through <g>Qt.createComponent()</g> function and then <g>component</g> object can be instantiated to Item objects through <g><componentobject>.createObject()</g> function. When a document file is not available then <g>Qt.createQmlObject</g> function can be used to create object with document specified in a string.\n\n<n>> If Qt.createComponent() is used, the creation context is the QQmlContext in which this method is called\n> If Qt.createQmlObject() is called, the creation context is the context of the parent object passed to this method\n> If a Component{} object is defined and createObject() or incubateObject() is called on that object, the creation context is the context in which the Component is defined</n>\n\n - Qt.createComponent() -> <componentobject>.createObject()\n\n<cb>\n<l><Sprite.qml></l>\nimport QtQuick 2.0\nRectangle {\ncolor: "red"\nwidth: 20\nheight: 20\n//x:appWindow.width/2\n//y:appWindow.height/2\n}\n</cb>\n\n<cb>\n<l><main.qml></l>\nimport QtQuick 2.0\nimport "componentCreation.js" as MyScript\n\nRectangle {\nid: appWindow\nwidth: 300; height: 300\nproperty var object:undefined\n Component.onCompleted: {\n  object=MyScript.createSpriteObjects();\n  object.height=60\n }\n}\n</cb>\n\n<cb>\n<l><componentCreation.js></l>\nvar component;\nvar sprite;\n\nfunction createSpriteObjects() {\n component = Qt.createComponent("Sprite.qml");\n if (component.status == Component.Ready)\n  return finishCreation();\n else\n  component.statusChanged.connect(finishCreation);\n}\n\nfunction finishCreation() {\n if (component.status == Component.Ready) {\n //sprite = component.createObject(appWindow);\n sprite = component.createObject(appWindow,{"x":Qt.binding(function(){return appWindow.width/2}),"y":Qt.binding(function(){return appWindow.height/2})});\n  if (sprite == null) {\n  console.log("Error creating object");\n  }else return sprite;\n } else if (component.status == Component.Error) {\n        console.log("Error loading component:", component.errorString());\n        }\n return null;\n}\n</cb>\n\n<m>http://minhinc.42web.io/image/qml-slide-dynamicitemcreationproceduralbinding.png</m>\n Object can be created without blocking using <g>incubateObject()</g>.\n\n Destroying.\n Object can be destroyed using <g>destroy()</g> method.\n\n<cb>\n<l><TextC.qml></l>\n<G>import</g> QtQuick 2.0\n<G>Text</g>{\n<g>font</g>.family:<r>"Helvetica"</r>\n<g>font</g>.pointSize:8\n}\n</cb>\n\n<cb>\n<l><SelfDestroyingRect.qml></l>\n<G>import</g> QtQuick 2.0\n<G>Rectangle</g> {\nid: rect\nwidth: 30; height: 30\nproperty int count:0\ncolor: <r>"red"</r>\n <G>NumberAnimation</g> on <l>opacity</l> {\n to: 0\n duration: 10000\n  <l>onRunningChanged</l>: {\n   if (!running) {\n   //console.log("Destroying...")\n   rect.destroy();\n   textlist[count].text="Rectangle "+count+" destroyed";\n   }\n  }\n }\n}\n</cb>\n\n<cb>\n<l><main.qml></l>\n<G>import</g> QtQuick 2.0\n<G>Item</g> {\nid: container\nwidth: 200; height: 200\nproperty var textlist:[]\n <G>Component</g>.onCompleted: {\n var component = <g>Qt.createComponent</g>(<r>"SelfDestroyingRect.qml</r>");\n var componenttext = <g>Qt.createComponent</g>(<r>"TextC.qml"</r>);\n  for (var i=0; i<5; i++) {\n  var object = component.createObject(container,{<r>"count"</r>:i});\n  container.textlist.push(componenttext.createObject(container));\n  container.textlist[i].x=object.x=(object.width + 10) * i;\n  container.textlist[i].y=object.y=(object.height + 10) * i;\n  }\n }\n}\n</cb>\n\n<m>http://minhinc.42web.io/image/qml-slide-dynamicitemcreateobject.png</m>\n - Qt.createQmlObject\n<c>\nvar newObject = <g>Qt.createQmlObject</g>(<r>\'import QtQuick 2.0; Rectangle {color: "red"; width: 20; height: 20}\'</r>,\n                                   parentItem,\n                                   "dynamicSnippet1");\n</c>\n\ndynamicSnippet1 is file for error log.\n\n <b>-Procedural/Declrative creation</b>\na Component type in a document can be directly instantiated through createObject() function call on the Component.\n\n<cb>\n<l><ButtonC.qml></l>\n<G>import</g> QtQuick 2.0\n<G>Rectangle</g> {\nid:button\nproperty alias text: label.text\nproperty alias textcolor:label.color\nsignal clicked()\ncolor: "blue"\n <G>Text</g> {\n id: label\n anchors.centerIn: parent\n }\n <G>MouseArea</g>{\n anchors.fill: parent\n onClicked: button.clicked()\n }\n}\n</cb>\n\n<cb>\n<l><main.qml></l>\n<G>import</g> QtQuick 2.0\n<G>Item</g>{\nid:root\n//property var obj\n <G>Column</g>{\n id:columnid\n anchors.centerIn:parent\n spacing:20\n  <G>ButtonC</g>{\n  width:100;height:100\n  //anchors{top:root.top;left:root.left}\n  text:<r>"Click on me ..."</r>\n  textcolor:"white"\n   <l>onClicked</l>:{\n   //root.obj=dialogComponent.createObject(root);\n   componentid.createObject(columnid);\n   }\n  }\n  <G>Component</g>{\n  id:componentid\n   <G>Rectangle</g>{\n   //anchors{bottom:root.bottom;left:root.left}\n   width:100;height:100\n   color:<r>"red"</r>\n    <G>MouseArea</g>{\n    anchors.fill:parent\n     onClicked:{\n     //root.obj.destroy();\n     parent.destroy();\n     }\n    }\n   }\n  }\n }\n}\n</cb>\n\n<m>http://minhinc.42web.io/image/qml-slide-dynamicitemcreationcomponent.png</m>\n\n <b>-Declarative creation</b>\n<m>https://www.youtube.com/embed/uYfiKCyaps8</m>\nLike procedural creations a <g>Loader</g> type is used for creating object through a <g>Component</g>. if a <g>Compoennt</g> is a document file, i.e. ButtonC.qml, then <l>source</l> attribute can be specified or if <g>Component</g> is a type delcared in a document then <l>sourceComponent</l> attribute should be specified. Once <g>Loader</g> instantiate the <g>Item</g>, <g>Item</g> can be identifed through <Loader>.item,i.e. in <g>Connections</g> type. Like <g><ComponentObject></g>.<l>createObject</l>/<g><Component></g>.<l>createObject</l>, created <g>Item</g> object will have context of the <g>Loader</g> where it gets defined.\n\n<cc>\n<l><ButtonC.qml></l>\nimport QtQuick 2.0\nRectangle {\nid:button\nproperty alias text: label.text\nproperty alias textcolor:label.color\nsignal clicked()\ncolor: "blue"\n Text {\n id: label\n anchors.centerIn: parent\n }\n MouseArea{\n anchors.fill: parent\n onClicked: button.clicked()\n }\n}\n</cc>\n\n<cb>\n<l><main.qml></l>\n<G>import</g> QtQuick 2.0\n<G>Item</g>{\nid:root\n//property var obj\n <G>Column</g>{\n id:columnid\n anchors.centerIn:parent\n spacing:20\n  //Loader {\n  //id:loaderid\n  //}\n  <G>ButtonC</g>{\n  width:100;height:100\n  //anchors{top:root.top;left:root.left}\n  text:"Click on me ..."\n  textcolor:<r>"white"</r>\n   onClicked:{\n   //root.obj=dialogComponent.createObject(root);\n   //componentid.createObject(columnid);\n   loaderid.sourceComponent=componentid\n   }\n  }\n  <G>Loader</g> {\n  id:loaderid\n  }\n  <G>Component</g>{\n  id:componentid\n   <G>Rectangle</g>{\n   //anchors{bottom:root.bottom;left:root.left}\n   width:100;height:100\n   color:<r>"red"</r>\n    <G>MouseArea</g>{\n    id:mouseareaid\n    anchors.fill:parent\n     <l>onClicked</l>:{\n     //root.obj.destroy();\n     //parent.destroy();\n     loaderid.sourceComponent=undefined\n     }\n    }\n   }\n  }\n }\n}\n</cb>\n\n<m>http://minhinc.42web.io/image/qml-slide-dynamicitemcreationloader.png</m>\n\n<h>\n*Creating Multiple Items\n</h>\nMultiple items generally gets created through type Model View Controller pattern.\n\n<h>\n*Repeaters\n</h>\n\n<m>https://www.youtube.com/embed/CJSdQBs9AxM</m>\n<g>Repeater</g> is a view which have <l>delegate</l> as repeating item and a datamodel as the model. Data model can be of all types.\n-ListModel\n-JSON Data\n-property list<type>\n-QList<QObject*>\n-QAbstractItemModel\n<cb>\nimport QtQuick 2.7\nGrid{\ncolumns:3\nrows:2\nspacing:10\nListModel{\nid:fruitcolormodelid\nListElement{ fruit:"mango";color:"green" }\nListElement{ fruit:"lichi";color:"pink" }\nListElement{ fruit:"apple";color:"green" }\nListElement{ fruit:"guava";color:"yellow" }\nListElement{ fruit:"cherry";color:"red" }\nListElement{ fruit:"grape";color:"black" }\n}\nRepeater{\n//model:6\n//model:["mango","lichi","apple","guava","cherry","grapes"]\n//model:["yellow","green","red","blue","black","pink"]\nmodel:fruitcolormodelid\nRectangle{\nwidth:100;height:100\n//color:modelData\ncolor:model.color\nText{\ntext:model.fruit\ncolor:"white"\nanchors.centerIn:parent\n}\n}\n}\n}\n</cb>\n\n<m>http://minhinc.42web.io/image/qml-slide-dynamicitemcreaterepeater.png</m>'
'9!ABS SBA!C++ Integration!ABS SBA!*Implement Ecllipse as Qml Class type\n*Place the Ecllipse class type as Library!ABS SBA!<h>\n*Declartive Envrionment\n -QQmlApplicationEngine\n -QQuickView\n</h>\n\n<n>Qml is a declarative language.It has two parts Qml and Javascript. Declarative part is qml and is the object initialization code with property name and value separated by colon \':\'. It supports propery binding (LHS property modified when any RHS property  changes).Javascript part is written in member functions and callback functions. Variable are assigned through \'=\' operator and so breaking the property binding. <g>Binding</g> or <g>State</g> Qml type can be used.</n>\n\n<n>Qml part is interpreted through c++ classes ( QQuickRectangle, QQuickText ...) where as Javascript part is interpreted through JIT interpreter.</n>\n\n<cb>\n<G>import</G> QtQuick 2.2\n<G>Item</G>{\n <G>Rectangle</G> {\n id:toplevel     <cc> <l>//<---- declarative</l></cc>\n color:<r>"blue"</r>\n height:500\n width:height\n  <G>Text</G>{\n  text:"Hello World" <cc>  <l>//<---- declarative </l> </cc>\n  }\n }\n <G>MouseArea</G>{\n  anchors.fill:parent\n  <l>onClicked</l>:{\n  toplevel.height=50;  <cc>  <l>//<---- javascript</l></cc>\n  }\n  <l>onDoubleClicked</l>:{\n  toplevel.width=toplevel.height;\n  }\n  <l>onHeightChanged</l>:{\n  toplevel.height=this.height; <cc> <l>//<------- breaking the binding</l></cc>\n  } \n }\n}\n</cb>\n\n <b>-QQmlApplicationEngine</b>\n<cc>\n               <g>QObject</g>\n                 / \\\n                  -\n                  |\n              <g>QJSEngine</g>\n                 / \\\n                  -\n              <g>QQmlEngine</g>\n                 / \\\n                  -\n                  |\n        <g>QQmlApplicationEngine</g>\n</cc>\nQml items are simple items of Graphics Views scene graph technology where all items belong to a scene and then scene can be drawn on one or more views/Widgets/Windows. <g>Window</g> or <g>ApplicationWindow</g> Quick type generates a window where <g>Item</g> (<g>QQuickItem</g>) gets finally drawn on it. When Window/ApplicationWindow is used on qml side then there is no need for <g>QQuickView</g> class on C++ side and just <g>QQmlApplicationEngine</g> works.\n\n<c>\n    Scene                       QQuickWindow/QQuickView\n ------------                  ------------------------\n |          |  mapped to       |                      |\n |   Item   | ---------------> |   QQuickItem         |\n |          |                  |                      |\n ------------                  ------------------------\n</c>\n<cc>\n<L><main.qrc></l>\nQT+=quick\nTEMPLATE = app\nTARGET = engine\nINCLUDEPATH += .\n\nMOC_DIR=build/moc\nRCC_DIR=build/rcc\nOBJECTS_DIR=build/obj\nUI_DIR=build/uic\n\nSOURCES += main.cpp\nRESOURCES +=  main.qrc\n\n<L><main.qrc></l>\n<RCC>\n <qresource prefix="/">\n   <file>main.qml</file>\n </qresource>\n</RCC>\n</cc>\n\n<cb>\n<l><main.cpp></l>\n#<g>include</g> <QGuiApplication>\n#<g>include</g> <QQmlApplicationEngine>\n#<g>include</g> <QUrl>\n\nint main(int argc, char *argv[])\n{\n    <g>QGuiApplication</g> app(argc, argv);\n<l>//    QQmlApplicationEngine engine("main.qml");</l>\n    <g>QQmlApplicationEngine</g> engine(QUrl(QStringLiteral("qrc:/main.qml"))); <l>//creates QQuickView internally</l>\n    return app.exec();\n}\n</cb>\n\n<cb>\n<l><main.qml></l>\n<G>import</g> QtQuick 2.0\n<G>import</g> QtQuick.Window 2.2\n\n<G>Window</g> {\nvisible:true\nwidth:550\nheight:400\n <G>Text</g>{\n text:<r>"Hello World"</r>\n anchors.centerIn:parent\n }\n}\n</cb>\n\n <b>-QQuickView</b>\n<cc>\n      <g>QQuickWindow</g>\n          / \\\n           -\n           |\n      <g>QQuickView</g>\n</cc>\n<g>QQuickview</g> provides window/widget to the top level <g>Item</g> in qml file. If qml file has Item as root element then cpp file must have QQuickView in order to show the root level Item.\n<cc>\n<L><main.pro></l>\nQT+=quick\nTEMPLATE = app\nTARGET = quickview\nINCLUDEPATH += .\n\nMOC_DIR=build/moc\nRCC_DIR=build/rcc\nOBJECTS_DIR=build/obj\nUI_DIR=build/uic\n\n# Input\nSOURCES += main.cpp\nRESOURCES += \n\n<L><main.qrc></l>\n<RCC>\n <qresource prefix="/">\n   <file>main.qml</file>\n </qresource>\n</RCC>\n</cc>\n\n<cb>\n<l><main.cpp></l>\n#<g>include</g> <QGuiApplication>\n#<g>include</g> <QQuickView>\n#<g>include</g> <QUrl>\n\nint main(int argc, char *argv[]) {\n <g>QGuiApplication</g> app(argc, argv);\n <g>QQuickView*</g> view = new QQuickView();\n <g>QUrl</g> source = <g>QStringLiteral</g>(<r>"qrc:/main.qml"</r>);\n view->setSource(source);\n view->show();\n return app.exec();\n}\n</cb>\n\n<cb>\n<l><main.qml></l>\n<G>import</g> QtQuick 2.0\n\n<G>Rectangle</g>{\nwidth:400\nheight:300\ncolor:"green"\n <G>Text</g>{\n text:<r>"Hello World"</r>\n anchors.centerIn:parent\n }\n}\n</cb>\n\n<h>\n*Exporting C++ Objects to QML\n -QQmlContext\n</h>\n\n<m>https://www.youtube.com/embed/8MKAd5zzClQ</m>\nQml document file has various context like root context root Item context and its children context and so on.. On c++ side QQmlcontext class refer a particular context on Qml side, i.e root context.\nContexts allow data to be exposed to the QML components instantiated by the QML engine.\n\n<c>\n<g>QQmlEngine</g> engine;\n<g>QStringListModel</g> modelData;\n<g>QQmlContext</g> *context = new <g>QQmlContext</g>(engine.rootContext());\ncontext->setContextProperty("myModel", &modelData);\n\n<g>QQmlComponent</g> component(&engine);\ncomponent.setData("import QtQuick 2.0\nListView { model: myModel }", QUrl());\n<g>QObject</g> *window = component.create(context);\n</c>\n\n<cb>\n<l><main.cpp></l>\n#<g>include</g> <QGuiApplication>\n#<g>include</g> <QStringList>\n#<g>include</g> <qqmlengine.h>\n#<g>include</g> <qqmlcontext.h>\n#<g>include</g> <qqml.h>\n#<g>include</g> <QtQuick/qquickitem.h>\n#<g>include</g> <QtQuick/qquickview.h>\nint main(int argc, char ** argv) {\n <g>QGuiApplication</g> app(argc, argv);\n <g>QStringList</g> dataList;\n dataList.append("Item 1");\n dataList.append("Item 2");\n dataList.append("Item 3");\n dataList.append("Item 4");\n <g>QQuickView</g> view;\n <g>QQmlContext</g> *ctxt = view.rootContext();\n ctxt->setContextProperty("myModel", QVariant::fromValue(dataList));\n view.setSource(QUrl("qrc:view.qml"));\n view.show();\n return app.exec();\n}\n</cb>\n\n<cb>\n<l><view.qml></l>\n<G>import</g> QtQuick 2.0\n<G>ListView</g> {\nwidth: 100; height: 100\nmodel: myModel\n delegate: <G>Rectangle</g> {\n height: 25\n width: 100\n  <G>Text</g> { text: modelData }\n }\n}\n</cb>\n\n<cc>\n<l>main.pro</l>\nQT+=quick\nTEMPLATE = app\nTARGET = app2\nINCLUDEPATH += .\nSOURCES += main.cpp\nRESOURCES += view.qrc\n\n<l>main.qrc</l>\n<RCC>\n <qresource>\n  <file>view.qml</file>\n </qresource>\n</RCC>\n</cc>\n\n<h>\n*Exporting Classes to QML\n</h>\n\n<n>C++ classes declarare MetaObject properties and methods through macro Q_PROPERTY and Q_INVOKABLE. C++ classed is registered through <c><g>qmlRegisterType</g></c> to the qt meta object system in order to get is avaiable to qml side.</n>\n\n<cc>\n<l><main.qrc</l>\n<RCC>\n <qresource>\n  <file>main.qml</file>\n </qresource>\n</RCC>\n\n<l><main.pro</l>\nQT+=quick\nTEMPLATE = app\nTARGET = binding\nINCLUDEPATH += .\nMOC_DIR=build\nRCC_DIR=build\nUI_DIR=build\nOBJECTS_DIR=build\nHEADERS += country.h river.h countryprint.h\nSOURCES += country.cpp main.cpp river.cpp countryprint.cpp\nRESOURCES += country.qrc\n</cc>\n\n<cb>\n<l><country.h></l>\n#ifndef COUNTRY_H\n#define COUNTRY_H\n#<g>include</g> <QObject>\n#<g>include</g> <QDate>\n#<g>include</g> <QDebug>\n#<g>include</g> <qqml.h>\n#<g>include</g> "river.h"\nclass <g>CountryAttached</g> : public <g>QObject</g> {\n Q_OBJECT\n Q_PROPERTY(QDate datadate READ datadate WRITE setDatadate NOTIFY datadateChanged)\npublic:\n CountryAttached(QObject *object);\n QDate datadate() const;\n void setDatadate(const QDate &);\nsignals:\n void datadateChanged();\nprivate:\n QDate m_datadate;\n};\nclass <g>Country</g> : public <g>QObject</g> {\n <g>Q_OBJECT</g>\n <g>Q_PROPERTY</g>(River *mainriver READ mainriver WRITE setMainriver NOTIFY mainriverChanged)\n <g>Q_PROPERTY</g>(<g>QQmlListProperty</g><River> rivers READ rivers)\n <g>Q_CLASSINFO</g>(<r>"DefaultProperty"</r>, <r>"rivers"</r>)\npublic:\n Country(QObject *parent = 0);\n River *mainriver() const;\n void setMainriver(River *);\n <g>QQmlListProperty</g><<g>River</g>> rivers();\n int riverCount() const;\n River *river(int) const;\n static CountryAttached *qmlAttachedProperties(QObject *);\nsignals:\n void mainriverChanged();\n void announcementChanged();\nprivate:\n River *m_mainriver;\n QList<River *> m_rivers;\n};\n<g>QML_DECLARE_TYPEINFO</g>(<g>Country</g>, QML_HAS_ATTACHED_PROPERTIES)\n#endif\n\n<l><country.cpp></l>\n#include "country.h"\n<g>CountryAttached</g>::<g>CountryAttached</g>(QObject *object) : QObject(object) { }\nQDate CountryAttached::<l>datadate()</l> const {\n return m_datadate;\n}\nvoid CountryAttached::<l>setDatadate</l>(const QDate &d) {\n if (d != m_datadate) {\n  m_datadate = d;\n  emit datadateChanged();\n }\n}\nCountry::Country(QObject *parent) : QObject(parent), m_mainriver(0) { }\nRiver *Country::<l>mainriver</l>() const {\n return m_mainriver;\n}\nvoid Country::<l>setMainriver</l>(River *c) {\n if (c != m_mainriver){\n  m_mainriver = c;\n  emit mainriverChanged();\n }\n}\nQQmlListProperty<River> Country::<l>rivers</l>() {\n return QQmlListProperty<River>(this, m_rivers);\n}\nint Country::<l>riverCount()</l> const {\n return m_rivers.count();\n}\nRiver *Country::<l>river(int index)</l> const {\n return m_rivers.at(index);\n}\nCountryAttached *Country::<l>qmlAttachedProperties</l>(QObject *object) {\n return new CountryAttached(object);\n}\n</cb>\n\n<cb>\n<l><countryprinting.h></l>\n#ifndef COUNTRYPRINTING_H\n#define COUNTRYPRINTING_H\n#<g>include</g> <QQmlPropertyValueSource>\n#<g>include</g> <QQmlProperty>\n#<g>include</g> <QStringList>\n#<g>include</g> <river.h>\nclass <g>CountryPrint</g> : public <g>QObject</g>, public <g>QQmlPropertyValueSource</g> {\n <g>Q_OBJECT</g>\n <g>Q_INTERFACES</g>(<g>QQmlPropertyValueSource</g>)\npublic:\n CountryPrint(QObject *parent = 0);\n virtual void setTarget(const QQmlProperty &);\nprivate slots:\n void advance();\nprivate:\n <g>QQmlProperty</g> m_target;\n};\n#endif \n\n<l><countryprint.cpp></l>\n#include <QDebug>\n#include <QTimer>\n#<g>include</g> <typeinfo>\n#<g>include</g> "country.h"\n#<g>include</g> "river.h"\n#<g>include</g> "countryprint.h"\nCountryPrint::<l>CountryPrint</l>(QObject *parent) : QObject(parent) {\n    QTimer *timer = new QTimer(this);\n    QObject::connect(timer, &QTimer::timeout, this, &CountryPrint::advance);\n    timer->start(5000);\n}\nvoid CountryPrint::<l>setTarget</l>(const QQmlProperty &p) {\n    m_target = p;\n}\nvoid CountryPrint::<l>advance</l>() {\n QDate datadate;\n QObject *attached;\n River *river;\n river=m_target.object()->property(m_target.object()->metaObject()->property(m_target.object()->metaObject()->indexOfProperty("mainriver")).name()).value<River*>();\n attached= qmlAttachedPropertiesObject<Country>(river, false);\n if (attached) datadate = attached->property("datadate").toDate();\n if (datadate.isNull()) qWarning() <<endl<<"   " << river->name() << "No data date "<< river->about()->length()<<" "<<river->about()->states()<<" "<<river->about()->meet();\n else qDebug() <<endl<<"   " << river->name() << " "<< qPrintable(datadate.toString())<<river->about()->length()<<" "<<river->about()->states()<<" "<<river->about()->meet();\n}\n</cb>\n\n<cb>\n<l><main.cpp></l>\n#<g>include</g> <QCoreApplication>\n#<g>include</g> <QQmlEngine>\n#<g>include</g> <QQmlComponent>\n#<g>include</g> <QDebug>\n#<g>include</g> "country.h"\n#<g>include</g> "countryprint.h"\n#<g>include</g> "river.h"\n\nint <g>main</g>(int argc, char ** argv) {\n <g>QCoreApplication</g> app(argc, argv);\n <g>qmlRegisterType</g><<g>CountryAttached</g>>();\n <g>qmlRegisterType</g><<g>Country</g>>("Country", 1,0, "Country");\n <g>qmlRegisterType</g><<g>CountryPrint</g>>("Country", 1,0, "CountryPrint");\n <g>qmlRegisterType</g><<g>RiverDescription</g>>();\n <g>qmlRegisterType</g><<g>River</g>>("Country", 1,0, "River");\n \n <g>QQmlEngine</g> engine;\n <g>QQmlComponent</g> component(&engine, QUrl("qrc:main.qml"));\n <g>Country</g> *country = qobject_cast<Country *>(component.create());\n if (country){\n  for (int ii = 0; ii < country->riverCount(); ++ii) {\n   River *river = country->river(ii);\n   QDate datadate;\n   QObject *attached = qmlAttachedPropertiesObject<Country>(river, false);\n   if (attached) datadate = attached->property("datadate").toDate();\n   qDebug()<<"------------"<<endl<<"River Name : "<<river->name()<<endl<<"datedate :"<<(datadate.isNull()?"NO DATE":qPrintable(datadate.toString()))<<endl<<"Length : "<<river->about()->length()<<endl<<"States visiting : "<<river->about()->states()<<endl<<"Meets : "<<river->about()->meet();\n  }\n } else qWarning() << component.errors();\n return app.exec();\n}\n</cb>\n\n<cb>\n<l><river.h></l>\n#ifndef RIVER_H\n#define RIVER_H\n#<g>include</g> <QObject>\n#<g>include</g> <QStringList>\nclass <g>RiverDescription</g> : public <g>QObject</g> {\n <g>Q_OBJECT</g>\n <g>Q_PROPERTY</g>(qreal length READ length WRITE setLength NOTIFY lengthChanged)\n <g>Q_PROPERTY</g>(QStringList states READ states WRITE setStates NOTIFY statesChanged)\n <g>Q_PROPERTY</g>(QString meet READ meet WRITE setMeet NOTIFY meetChanged)\npublic:\n RiverDescription(QObject *parent = 0);\n qreal length() const;\n void setLength(qreal);\n QStringList& states();\n void setStates(QStringList&);\n QString state(int) const;\n int stateCount();\n QString meet() const;\n void setMeet(const QString &);\nsignals:\n void lengthChanged();\n void statesChanged();\n void meetChanged();\nprivate:\n qreal m_length;\n QStringList m_states;\n QString m_meet;\n};\nclass <g>River</g> : public <g>QObject</g> {\n <g>Q_OBJECT</g>\n <g>Q_PROPERTY</g>(QString name READ name WRITE setName NOTIFY nameChanged)\n <g>Q_PROPERTY</g>(RiverDescription *about READ about CONSTANT)\npublic:\n River(QObject *parent = 0);\n QString name() const;\n void setName(const QString &);\n RiverDescription *about();\nsignals:\n void nameChanged();\nprivate:\n QString m_name;\n RiverDescription m_description;\n};\n#endif // RIVER_H\n\n<l><river.cpp></l>\n#<g>include</g> "river.h"\nRiverDescription::<g>RiverDescription</g>(QObject *parent) : QObject(parent), m_length(0) { }\nqreal RiverDescription::<l>length()</l> const {\n return m_length;\n}\nvoid RiverDescription::<l>setLength(qreal s)</l> {\n if (m_length!=s) {\n  m_length = s;\n  emit lengthChanged();\n }\n}\nQStringList& RiverDescription::<l>states()</l> {\n return m_states;\n}\nvoid RiverDescription::<l>setStates(QStringList& l)</l>{\n if (m_states != l){\n m_states=l;\n emit statesChanged();\n }\n}\nQString RiverDescription::<l>meet()</l> const {\n return m_meet;\n}\nvoid RiverDescription::<l>setMeet(const QString& p)</l> {\n if (m_meet!=p){\n  m_meet = p;\n  emit meetChanged();\n }\n}\nQString RiverDescription::<l>state(int i)</l> const {\n return m_states.at(i);\n}\nRiverDescription *River::<l>about()</l> {\n return &m_description;\n}\nRiver::River(QObject *parent) : <g>QObject</g>(parent) { }\nQString River::name() const {\n return m_name;\n}\nvoid River::<l>setName(const QString &n)</l> {\n if(m_name!=n) {\n  m_name = n;\n  emit nameChanged();\n }\n}\n</cb>\n\n<cb>\n<l><main.qml></l>\n<G>import</g> Country 1.0\n<G>import</g> QtQuick 2.0\n<G>Country</g> {\n id: india\n <G>CountryPrint</g> on mainriver {}\n <G>mainriver</G>: <g>River</g> {\n  id:indusriver\n  name: <r>"Indus"</r>\n  Country.datadate: <r>"2009-07-06"</r>\n  about { length: 3180.0; states:[<r>"ladakh"</r>,<r>"punjab"</r>,<r>"sindh"</r>]; meet: <r>"sea"</r>}\n }\n <G>rivers</g>:[River {\n  name: <r>"Cauvery"</r>\n  Country.datadate: <r>"2010-04-26"</r>\n  about { length: 805.0; states:[<r>"karnataka"</r>,<r>"tamilnadu"</r>]; meet: <r>"sea"</r>}\n },\n <G>River</g> {\n  name: <r>"Godavari"</r>\n  about { length: 1465.0; states:[<r>"maharashtra"</r>,<r>"telangana"</r>,<r>"ap"</r>]; meet: <r>"sea"</r>}\n },\n <G>River</g> {\n  name: <r>"Ganga"</r>\n  Country.datadate: <r>"2014-08-13"</r>\n  about { length: 2525.0; states:[<r>"uttrakhand"</r>,<r>"up"</r>,<r>"bihar"</r>,<r>"jharkhand"</r>,<r>"wb"</r>,<r>"bangladesh"</r>]; meet: <r>"sea"</r>}\n },\n <G>River</g> {\n  name: <r>"Jhelum"</r>\n  about.length: 725.0\n  about.states:[<r>"j&k"</r>,<r>"pok"</r>,<r>"punjab"</r>]\n  about.meet:indusriver.name\n }]\n}\n</cb>\nOutput\n<cc>\n$./binding\n------------ \nRiver Name :  "Cauvery" \ndatedate : Mon Apr 26 2010 \nLength :  805 \nStates visiting :  ("karnataka", "tamilnadu") \nMeets :  "sea"\n------------ \nRiver Name :  "Godavari" \ndatedate : NO DATE \nLength :  1465 \nStates visiting :  ("maharashtra", "telangana", "ap") \nMeets :  "sea"\n------------ \nRiver Name :  "Ganga" \ndatedate : Wed Aug 13 2014 \nLength :  2525 \nStates visiting :  ("uttrakhand", "up", "bihar", "jharkhand", "wb", "bangladesh") \nMeets :  "sea"\n------------ \nRiver Name :  "Jhelum" \ndatedate : NO DATE \nLength :  725 \nStates visiting :  ("j&k", "pok", "punjab") \nMeets :  "Indus"\n\n    "Indus"   Mon Jul 6 2009 3180   ("ladakh", "punjab", "sindh")   "sea"\n\n    "Indus"   Mon Jul 6 2009 3180   ("ladakh", "punjab", "sindh")   "sea"\n\n    "Indus"   Mon Jul 6 2009 3180   ("ladakh", "punjab", "sindh")   "sea"\n^C\n</cc>\n<h>\n*Exporting Non-GUI Classes\n</h>\nNon Gui classess can be exported by subclassing QObject.\n<h>\n*Exporting Qpainter based GUI Classes\n -QQuickPaintedItem\n</h>\n\n<m>https://www.youtube.com/embed/E7LfWTJr_is</m>\nGui classeses can be exported by subclassing/extending <g>QQuickItem</g>. If painting is required then <g>QQuickPaintedItem</g> needs to be subclassed and <g>paint</g> function needs to overrriden.\n<cc>\n<l><main.pro></l>\nQT+=quick\nTEMPLATE = app\nTARGET = ellipse\nINCLUDEPATH += .\n\nMOC_DIR=build\nRCC_DIR=build\nUI_DIR=build\nOBJECTS_DIR=build\n\nHEADERS += ellipse.h\nSOURCES += ellipse.cpp main.cpp\nRESOURCES += main.qrc\n\n<l>main.qrc</l>\n<RCC>\n <qresource>\n  <file>main.qml</file>\n </qresource>\n</RCC>\n</cc>\n\n<cb>\n<l><ellipse.h></l>\n#ifndef ELLIPSE_H\n#define ELLIPSE_H\n#<g>include</g> <QtQuick/QQuickPaintedItem>\n#<g>include</g> <QColor>\n\nclass <g>Ellipsesub</g>:public <g>QQuickPaintedItem</g> {\n <g>Q_OBJECT</g>\n <g>Q_PROPERTY</g>(int angle READ angle WRITE setAngle)\n <g>Q_PROPERTY</g>(QColor color READ color WRITE setColor NOTIFY colorChanged)\n <g>Q_PROPERTY</g>(QString name READ name WRITE setName NOTIFY nameChanged)\npublic:\n <g>Ellipsesub</g>(QQuickItem *parent=0);\n int angle()const;\n void setAngle(const int);\n QColor color() const;\n void setColor(const QColor&);\n QString name() const;\n void setName(const QString&);\n void paint(QPainter *);\nsignals:\n void nameChanged();\n void colorChanged();\nprivate:\n int _angle;\n QString _name;\n QColor _color;\n};\nclass <g>Ellipse</g> : public <g>QQuickPaintedItem</g> {\n <g>Q_OBJECT</g>\n <g>Q_PROPERTY</g>(QQmlListProperty<Ellipsesub> ellipsesubs READ ellipsesubs)\n// Q_PROPERTY(Ellipsesub *ellipsesub READ ellipsesub WRITE setEllipsesub)\n <g>Q_PROPERTY</g>(QString name READ name WRITE setName NOTIFY nameChanged)\n <g>Q_PROPERTY</g>(QColor color READ color WRITE setColor NOTIFY colorChanged)\npublic:\n <g>Ellipse</g>(QQuickItem *parent = 0);\n QString name() const;\n void setName(const QString &name);\n QColor color() const;\n void setColor(const QColor &color);\n/* Ellipsesub* ellipsesub() const;\n void setEllipsesub(Ellipsesub*); */\n void paint(QPainter *painter);\n static void appendellipsesub(QQmlListProperty<Ellipsesub> *ellipsesublist,Ellipsesub *ellipsesub);\n\n QQmlListProperty<Ellipsesub> ellipsesubs();\n Q_INVOKABLE void clearEllipse();\nsignals:\n void nameChanged();\n void colorChanged();\n void ellipseCleared();\nprivate:\n QString _name;\n QColor _color;\n//Ellipsesub* _ellipsesub;\n QList<Ellipsesub*> _ellipsesublist;\n};\n#endif\n</cb>\n\n<cb>\n<l><ellipse.cpp></l>\n#<g>include</g> <QPainter>\n#<g>include</g> "ellipse.h"\n<g>Ellipsesub</g>::<l>Ellipsesub</l>(QQuickItem *parent):QQuickPaintedItem(parent),_angle(0){}\n/*Ellipsesub* Ellipse::ellipsesub() const { return _ellipsesub; }\nvoid Ellipse::setEllipsesub(Ellipsesub *ellipsesub){\n_ellipsesub=ellipsesub;\n_ellipsesub->setParentItem(this);\n}*/\nQString <g>Ellipsesub</g>::<l>name()</l> const { return _name; }\nvoid <g>Ellipsesub</g>::<l>setName(const QString& name)</l>{\n if (_name!=name){\n  _name=name;\n  emit nameChanged();\n }\n}\nQColor <g>Ellipsesub</g>::<l>color()</l> const { return _color; }\nvoid <g>Ellipsesub</g>::<l>setColor(const QColor& color)</l>{\n if(_color!=color){\n  _color=color;\n  update();\n  emit colorChanged();\n }\n}\nint <g>Ellipsesub</g>::<l>angle()</l> const { return _angle; }\nvoid <g>Ellipsesub</g>::<l>setAngle(const int angle)</l>{\n if(_angle!=angle){\n  _angle=angle;\n//  emit angleChanged();\n }\n}\nvoid <g>Ellipsesub</g>::<l>paint(QPainter *painter)</l>{\n int sidemin=qMin(width(),height());\n int sidemax=qMax(width(),height());\n painter->setViewport((width()-sidemin)/2,(height()-sidemin)/2,sidemin,sidemin);\n painter->setWindow(-sidemax/2,-sidemax/2,sidemax,sidemax);\n painter->setPen(QPen(_color,2));\n painter->setRenderHints(QPainter::Antialiasing,true);\n painter->save();\n painter->rotate(_angle);\n painter->drawEllipse(QRect(-width()/2,-height()/2,width(),height()).adjusted(1,1,-1,-1));\n painter->restore();\n}\n\n<g>Ellipse</g>::<l>Ellipse(QQuickItem *parent)</l>:QQuickPaintedItem(parent){}\nQString Ellipse::name() const { return _name; }\nvoid Ellipse::setName(const QString& name){\n if (_name!=name){\n  _name=name;\n  emit nameChanged();\n }\n}\nQColor <g>Ellipse</g>::<l>color()</l> const { return _color; }\nvoid Ellipse::setColor(const QColor& color){\n if(_color!=color){\n  _color=color;\n  update();\n  emit colorChanged();\n }\n}\nvoid <g>Ellipse</g>::<l>paint(QPainter *painter)</l>{\n painter->setPen(QPen(_color,2));\n painter->setRenderHints(QPainter::Antialiasing,true);\n painter->drawEllipse(boundingRect().adjusted(1,1,-1,-1));\n}\nvoid <g>Ellipse</g>::<l>clearEllipse()</l>{\n static QColor color=_color;\n if(_color!=Qt::transparent)\n  setColor(QColor(Qt::transparent));\n else\n  setColor(color);\n emit ellipseCleared();\n}\n<g>QQmlListProperty<Ellipsesub></g> <g>Ellipse</g>::<l>ellipsesubs()</l>{\n return QQmlListProperty<Ellipsesub>(this,nullptr,&Ellipse::appendellipsesub,nullptr,nullptr,nullptr);\n}\nvoid <g>Ellipse</g>::<l>appendellipsesub(QQmlListProperty<Ellipsesub> *ellipsesublist,Ellipsesub *ellipsesub)</l>{\n Ellipse *ellipse=qobject_cast<Ellipse*>(ellipsesublist->object);\n if(ellipse){\n  ellipsesub->setParentItem(ellipse);\n  ellipse->_ellipsesublist.append(ellipsesub);\n }\n}\n</cb>\n\n<cb>\n<l><main.cpp></l>\n#<g>include</g> <QGuiApplication>\n#<g>include</g> <QQuickView>\n#<g>include</g> <QDebug>\n#<g>include</g> "ellipse.h"\n\nint main(int argc, char ** argv) {\n <g>QGuiApplication</g> app(argc, argv);\n <g>qmlRegisterType</g><<g>Ellipse</g>>(<r>"EllipseM"</r>, 1,0, <r>"Ellipse"</r>);\n <g>qmlRegisterType</g><<g>Ellipsesub</g>>(<r>"EllipseM"</r>, 1,0, <r>"Ellipsesub"</r>);\n <g>QQuickView</g> view; \n view.setResizeMode(QQuickView::SizeRootObjectToView);\n view.setSource(QUrl("qrc:main.qml"));\n view.show();\n return app.exec();\n}\n</cb>\n\n<cb>\n<l><main.qml></l>\n<G>import</g> EllipseM 1.0\n<G>import</g> QtQuick 2.0\n<G>Item</g>{\nwidth:400;height:400\n <G>Row</g>{\n anchors.centerIn:parent\n spacing:20\n  <G>Ellipse</g> {\n  id: ellipseid1\n  width:200;height:200\n  name:"ellipse1"\n  color:"red"\n  onEllipseCleared:{ console.log(<r>"Ellipse1 cleared"</r>); }\n  <G>ellipsesubs</g>:[<G>Ellipsesub</g>{\n   width:100;height:50\n   anchors.centerIn:parent\n   color:<r>"green"</r>\n   },\n   <G>Ellipsesub</g>{\n   width:100;height:50\n   anchors.centerIn:parent\n   color:<r>"blue"</r>\n   angle:90\n   },\n   <G>Ellipsesub</g>{\n   width:100;height:50\n   anchors.centerIn:parent\n   color:<r>"red"</r>\n   angle:45\n   }]\n   <G>Text</g>{\n   text:ellipseid1.name\n   anchors{bottom:parent.bottom;horizontalCenter:parent.horizontalCenter;bottomMargin:-20}\n   }\n  }\n  <G>Ellipse</g> {\n  id: ellipseid2\n  width:200;height:200\n  name:<r>"ellipse2"</r>\n  color:ellipseid1.color\n  onEllipseCleared:console.log(<r>"Ellipse2 cleared"</r>)\n   <G>Text</g>{\n   text:ellipseid2.name\n   anchors{bottom:parent.bottom;horizontalCenter:parent.horizontalCenter;bottomMargin:-20}\n   }\n  }\n }\n <G>MouseArea</g>{\n id:mousearea\n anchors{fill:parent}\n onClicked:ellipseid1.clearEllipse()\n onDoubleClicked:ellipseid2.color=<r>"blue"</r>;\n }\n}\n</cb>\n\n<m>http://minhinc.42web.io/image/qml-slide-cppintegration-qquickitem.png</m>\n       Ellipse and EllipseSubsets \n\n<m>http://minhinc.42web.io/image/qml-slide-cppintegration-qquickitem2.png</m>\n  Ellipse1 color become transparent and so Ellipse2 due to property binding \n\n<m>http://minhinc.42web.io/image/qml-slide-cppintegration-qquickitem3.png</m>\n    Ellipse2 breaks binding on mouse doubleclick \n\n<h>\n*Building an application as a Library\n</h>\n\n<m>https://www.youtube.com/embed/19ibdDN0ZPo</m>\n<cc>\n<g>QQmlExtensionPlugin</g>\n      / \\\n       -\n       |\n       |\n          ::registerTypes() <l>//override</l>\n          ::initializeEngine() <l>//override</l>\n</cc>\n\nQml classes can be in application or can be pushed to a library to which application would link. In case of creating library,  <g>QQmlExtensionPlugin</g> needs to be subclassed overriding its <g>registerTypes</g> and <g>initializeEngine</g> methods.\n\n<n>1. Subclass <g>QQmlExtensionPlugin</g>\n  > Use the <g>Q_PLUGIN_METADATA()</g> macro to register the plugin with the Qt meta object system.\n  > Override the <g>registerTypes()</g> method and call qmlRegisterType() to register the types to be exported by the plugin.\n  > Override initializeEngine to initialize the extension from the uri using the engine. Here an application plugin may expose some data or objects to QML as context properties on the engine\'s root context.\n2. Write a project file for the plugin.\n3.Create a qmldir file to describe the plugin.</n>\n\n<c>\n$ ls imports/EllipseM/\nlibqmlellipseplugin.so  qmldir\n</c>\n\n<cc>\n<l><*.pro></l>\nQT+=qml quick\nTEMPLATE = lib\nCONFIG+=plugin\nDESTDIR=imports/EllipseM\nTARGET = qmlellipseplugin\n\nINCLUDEPATH += .\n\nHEADERS += ellipse.h ellipseplugin.h\nSOURCES += ellipse.cpp ellipseplugin.cpp\n\n<l><main.qrc></l>\n<RCC>\n <qresource>\n  <file>main.qml</file>\n </qresource>\n</RCC>\n</cc>\n\n<cb>\n<l><ellipseplugin.h></l>\n#ifndef ELLIPSEPLUGIN_H\n#define ELLIPSEPLUGIN_H\n#include <QQmlExtensionPlugin>\nclass <g>EllipsePlugin</g> : public <g>QQmlExtensionPlugin</g> {\n Q_OBJECT\n Q_PLUGIN_METADATA(IID QQmlExtensionInterface_iid)\npublic:\n void <l>registerTypes</l>(const char *uri);\n};\n#endif\n</cb>\n\n<cb>\n#<g>include</g> "ellipseplugin.h"\n#<g>include</g> "ellipse.h"\n#<g>include</g> <qqml.h>\nvoid <g>EllipsePlugin</g>::<l>registerTypes</l>(const char *uri) {\n <g>qmlRegisterType</g><<g>Ellipse</g>>(uri, 1, 0, <r>"Ellipse"</r>);\n <g>qmlRegisterType</g><<g>Ellipsesub</g>>(uri, 1, 0, <r>"Ellipsesub"</r>);\n}\n</cb>\n\n<n>Create a qmldir file to describe the plugin</n>\n\n<cb>\n<l><imports/EllipseM/qmldir></l>\nmodule EllipseM\nplugin qmlellipseplugin\n</cb>\n\n<cs>\n<*.pro>\nQT+=qml quick\nTEMPLATE = lib\nCONFIG+=plugin\nDESTDIR=imports/EllipseM\nTARGET = qmlellipseplugin\n\nINCLUDEPATH += .\n\nHEADERS += ellipse.h ellipseplugin.h\nSOURCES += ellipse.cpp ellipseplugin.cpp\n\n<ellipse.h>\n#ifndef ELLIPSE_H\n#define ELLIPSE_H\n#include <QtQuick/QQuickPaintedItem>\n#include <QColor>\n\nclass Ellipsesub:public QQuickPaintedItem {\n Q_OBJECT\n Q_PROPERTY(int angle READ angle WRITE setAngle)\n Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY colorChanged)\n Q_PROPERTY(QString name READ name WRITE setName NOTIFY nameChanged)\npublic:\n Ellipsesub(QQuickItem *parent=0);\n int angle()const;\n void setAngle(const int);\n QColor color() const;\n void setColor(const QColor&);\n QString name() const;\n void setName(const QString&);\n void paint(QPainter *);\nsignals:\n void nameChanged();\n void colorChanged();\nprivate:\n int _angle;\n QString _name;\n QColor _color;\n};\nclass Ellipse : public QQuickPaintedItem {\n Q_OBJECT\n Q_PROPERTY(QQmlListProperty<Ellipsesub> ellipsesubs READ ellipsesubs)\n// Q_PROPERTY(Ellipsesub *ellipsesub READ ellipsesub WRITE setEllipsesub)\n Q_PROPERTY(QString name READ name WRITE setName NOTIFY nameChanged)\n Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY colorChanged)\npublic:\n Ellipse(QQuickItem *parent = 0);\n QString name() const;\n void setName(const QString &name);\n QColor color() const;\n void setColor(const QColor &color);\n/* Ellipsesub* ellipsesub() const;\n void setEllipsesub(Ellipsesub*); */\n void paint(QPainter *painter);\n static void appendellipsesub(QQmlListProperty<Ellipsesub> *ellipsesublist,Ellipsesub *ellipsesub);\n\n QQmlListProperty<Ellipsesub> ellipsesubs();\n Q_INVOKABLE void clearEllipse();\nsignals:\n void nameChanged();\n void colorChanged();\n void ellipseCleared();\nprivate:\n QString _name;\n QColor _color;\n//Ellipsesub* _ellipsesub;\n QList<Ellipsesub*> _ellipsesublist;\n};\n#endif\n\n<ellipse.cpp>\n#include <QPainter>\n#include "ellipse.h"\nEllipsesub::Ellipsesub(QQuickItem *parent):QQuickPaintedItem(parent),_angle(0){}\n/*Ellipsesub* Ellipse::ellipsesub() const { return _ellipsesub; }\nvoid Ellipse::setEllipsesub(Ellipsesub *ellipsesub){\n_ellipsesub=ellipsesub;\n_ellipsesub->setParentItem(this);\n}*/\nQString Ellipsesub::name() const { return _name; }\nvoid Ellipsesub::setName(const QString& name){\n if (_name!=name){\n  _name=name;\n  emit nameChanged();\n }\n}\nQColor Ellipsesub::color() const { return _color; }\nvoid Ellipsesub::setColor(const QColor& color){\n if(_color!=color){\n  _color=color;\n  update();\n  emit colorChanged();\n }\n}\nint Ellipsesub::angle() const { return _angle; }\nvoid Ellipsesub::setAngle(const int angle){\n if(_angle!=angle){\n  _angle=angle;\n//  emit angleChanged();\n }\n}\nvoid Ellipsesub::paint(QPainter *painter){\n int sidemin=qMin(width(),height());\n int sidemax=qMax(width(),height());\n painter->setViewport((width()-sidemin)/2,(height()-sidemin)/2,sidemin,sidemin);\n painter->setWindow(-sidemax/2,-sidemax/2,sidemax,sidemax);\n painter->setPen(QPen(_color,2));\n painter->setRenderHints(QPainter::Antialiasing,true);\n painter->save();\n painter->rotate(_angle);\n painter->drawEllipse(QRect(-width()/2,-height()/2,width(),height()).adjusted(1,1,-1,-1));\n painter->restore();\n}\n\nEllipse::Ellipse(QQuickItem *parent):QQuickPaintedItem(parent){}\nQString Ellipse::name() const { return _name; }\nvoid Ellipse::setName(const QString& name){\n if (_name!=name){\n  _name=name;\n  emit nameChanged();\n }\n}\nQColor Ellipse::color() const { return _color; }\nvoid Ellipse::setColor(const QColor& color){\n if(_color!=color){\n  _color=color;\n  update();\n  emit colorChanged();\n }\n}\nvoid Ellipse::paint(QPainter *painter){\n painter->setPen(QPen(_color,2));\n painter->setRenderHints(QPainter::Antialiasing,true);\n painter->drawEllipse(boundingRect().adjusted(1,1,-1,-1));\n}\nvoid Ellipse::clearEllipse(){\n static QColor color=_color;\n if(_color!=Qt::transparent)\n  setColor(QColor(Qt::transparent));\n else\n  setColor(color);\n emit ellipseCleared();\n}\nQQmlListProperty<Ellipsesub> Ellipse::ellipsesubs(){\n return QQmlListProperty<Ellipsesub>(this,nullptr,&Ellipse::appendellipsesub,nullptr,nullptr,nullptr);\n}\nvoid Ellipse::appendellipsesub(QQmlListProperty<Ellipsesub> *ellipsesublist,Ellipsesub *ellipsesub){\n Ellipse *ellipse=qobject_cast<Ellipse*>(ellipsesublist->object);\n if(ellipse){\n  ellipsesub->setParentItem(ellipse);\n  ellipse->_ellipsesublist.append(ellipsesub);\n }\n}\n\n<ellipseplugin.h>\n#ifndef ELLIPSEPLUGIN_H\n#define ELLIPSEPLUGIN_H\n#include <QQmlExtensionPlugin>\nclass EllipsePlugin : public QQmlExtensionPlugin {\n Q_OBJECT\n Q_PLUGIN_METADATA(IID QQmlExtensionInterface_iid)\npublic:\n void registerTypes(const char *uri);\n};\n#endif\n\n<ellipseplugin.cpp>\n#include "ellipseplugin.h"\n#include "ellipse.h"\n#include <qqml.h>\nvoid EllipsePlugin::registerTypes(const char *uri) {\n qmlRegisterType<Ellipse>(uri, 1, 0, "Ellipse");\n qmlRegisterType<Ellipsesub>(uri, 1, 0, "Ellipsesub");\n}\n\n<imports/EllipseM/qmldir>\nmodule EllipseM\nplugin qmlellipseplugin\n</cs>\n\n<h>\n*Using Custom Types Plugins\n</h>\n\n<m>https://www.youtube.com/embed/UxnOiAejgtQ</m>\nApplication needs to add module directory which contains qmldir file i.e imports/EllipseM. Here EllipseM is module name so only \'imports\' directory needs to be added to QQmlEngine::addImportPath. It is expected that plugin library is available in the directory where qmldir file exists, otherwise plugin path needs to be added in QQmlEngine::addPluginPath.\n\n<cc>\n<l><*.pro></l>\nQT+=quick\nTEMPLATE = app\nTARGET = ellipse\nINCLUDEPATH += .\n\nMOC_DIR=build\nRCC_DIR=build\nUI_DIR=build\nOBJECTS_DIR=build\n\nSOURCES += main.cpp\nRESOURCES += main.qrc\n</cc>\n\n<cb>\n<l><main.cpp></l>\n#include <QGuiApplication>\n#include <QQuickView>\n#include <QQmlEngine>\n#include <QDebug>\n\nint main(int argc, char ** argv) {\n QGuiApplication app(argc, argv);\n QQuickView view; \n view.engine()->addImportPath(app.applicationDirPath()+"/imports");\n view.setResizeMode(QQuickView::SizeRootObjectToView);\n view.setSource(QUrl("qrc:main.qml"));\n view.show();\n return app.exec();\n}\n</cb>\n\n<c>\n$ ls imports/\nEllipseM\n$ ls imports/EllipseM/\nlibqmlellipseplugin.so  qmldir\n$ cat imports/EllipseM/qmldir \nmodule EllipseM\nplugin qmlellipseplugin\n$./ellipse\n</c>\n<m>http://minhinc.42web.io/image/qml-slide-cppintegration-qquickitem.png</m>\n       Ellipse and EllipseSubsets \n\n<cs>\n<*.pro>\nQT+=quick\nTEMPLATE = app\nTARGET = ellipse\nINCLUDEPATH += .\n\nMOC_DIR=build\nRCC_DIR=build\nUI_DIR=build\nOBJECTS_DIR=build\n\nSOURCES += main.cpp\nRESOURCES += main.qrc\n\n<main.qrc>\n<RCC>\n <qresource>\n  <file>main.qml</file>\n </qresource>\n</RCC>\n\n<imports/EllipseM/qmldir>\nmodule EllipseM\nplugin qmlellipseplugin\n\n<main.cpp>\n#include <QGuiApplication>\n#include <QQuickView>\n#include <QQmlEngine>\n#include <QDebug>\n\nint main(int argc, char ** argv) {\n QGuiApplication app(argc, argv);\n QQuickView view; \n view.engine()->addImportPath(app.applicationDirPath()+"/imports");\n view.setResizeMode(QQuickView::SizeRootObjectToView);\n view.setSource(QUrl("qrc:main.qml"));\n view.show();\n return app.exec();\n}\n\n<main.qml>\nimport EllipseM 1.0\nimport QtQuick 2.0\nItem{\nwidth:400;height:400\n Row{\n anchors.centerIn:parent\n spacing:20\n  Ellipse {\n  id: ellipseid1\n  width:200;height:200\n  name:"ellipse1"\n  color:"red"\n  onEllipseCleared:{ console.log("Ellipse1 cleared"); }\n  ellipsesubs:[Ellipsesub{\n   width:100;height:50\n   anchors.centerIn:parent\n   color:"green"\n   },\n   Ellipsesub{\n   width:100;height:50\n   anchors.centerIn:parent\n   color:"blue"\n   angle:90\n   },\n   Ellipsesub{\n   width:100;height:50\n   anchors.centerIn:parent\n   color:"red"\n   angle:45\n   }]\n   Text{\n   text:ellipseid1.name\n   anchors{bottom:parent.bottom;horizontalCenter:parent.horizontalCenter;bottomMargin:-20}\n   }\n  }\n  Ellipse {\n  id: ellipseid2\n  width:200;height:200\n  name:"ellipse2"\n  color:ellipseid1.color\n  onEllipseCleared:console.log("Ellipse2 cleared")\n   Text{\n   text:ellipseid2.name\n   anchors{bottom:parent.bottom;horizontalCenter:parent.horizontalCenter;bottomMargin:-20}\n   }\n  }\n }\n MouseArea{\n id:mousearea\n anchors{fill:parent}\n onClicked:ellipseid1.clearEllipse()\n onDoubleClicked:ellipseid2.color="blue";\n }\n}\n</cs>'
'10!ABS SBA!Graphical Effects!ABS SBA!!ABS SBA!<h>\nCanvas\n</h>\nThe Canvas item allows drawing of straight and curved lines, simple and complex shapes, graphs, and referenced graphic images. It can also add text, colors, shadows, gradients, and patterns, and do low level pixel operations. \nRendering to the Canvas is done using a Context2D object, usually as a result of the paint signal.\n<c>\nimport QtQuick 2.0\nCanvas {\nid: mycanvas\nwidth: 100\nheight: 200\n onPaint: {\n var ctx = getContext("2d");\n ctx.fillStyle = Qt.rgba(1, 0, 0, 1);\n ctx.fillRect(0, 0, width, height);\n }\n}\n</c>\n\n<h>\nParticles\n</h>\nA particle system consists of three things\nA <g>ParticleSystem</g> - which binds all elements to a simulation\nAn <g>Emitter</g> which emits particles into the system\nA <g>ParticlePainterderived</g> element, which visualizes the particles\n\n<c>\nimport QtQuick 2.0\nimport QtQuick.Particles 2.0\n\nRectangle {\nid:root\nwidth:480;height:160\ncolor:"#1f1f1f"\nParticleSystem{\nid:particlesystem\n}\nEmitter{\nid:emitter\nanchors.centerIn:parent\nwidth:160;height:80\nsystem:particlesystem\nemitRate:10\nlifeSpan:1000\nlifeSpanVariation:500\nsize:16\nendSize:32\n}\nImageParticle{\nsource:"myparticle.png"\nsystem:particlesystem\n}\n}\n</c>\n<h>\nShaders\n</h>'
'11!ABS SBA!Animations!ABS SBA!!ABS SBA!<h>\n*Animations\n - PropertyAnimation\n - ParallelAnimation\n - SequentialAnimation\n - PathAnimation\n</h>\n<cc>\n                       Animation\n                          .\n                         / \\ \n                          -\n                          |\n+-----------+-----------+-+-----------+-------------+------------------+\n|           |           | |           |             |                  |\n----------- ----------- | ----------- ----------- ----------- ----------\n|Anchor   | |Parallel | | |Parent   | |Path     | |Pause    | |Property|\n|Animation| |Animation| | |Animation| |Animation| |Animation| |Action  |\n----------- ----------- | ----------- ----------- ----------- ----------\n                        |\n                        |\n      +-----------------+-----+\n      |         |             |\n----------- ---------  ------------\n|Property | |Script |  |Sequential|\n|Animation| |Action |  |Animation |\n----------- ---------  ------------\n    .\n   / \\ \n    -\n    |\n+-----------+-----------+\n|           |           |\n----------- ----------- ----------- -----------\n|Color    | |Number   | |Rotation | |Vector3d |\n|Animation| |Animation| |Animation| |Animation|\n----------- ----------- ----------- -----------\n</cc>\n\nVarious animations\n<g>Transition</g> - Animates transitions during state changes\n<g>SequentialAnimation</g> - Runs animations sequentially\n<g>ParallelAnimation</g> - Runs animations in parallel\n<g>Behavior</g> - Specifies a default animation for property changes\n<g>PropertyAction</g> - Sets immediate property changes during animation\n<g>PauseAnimation</g> - Introduces a pause in an animation\n<g>SmoothedAnimation</g> - Allows a property to smoothly track a value\n<g>SpringAnimation</g> - Allows a property to track a value in a spring-like motion\n<g>ScriptAction</g> - Runs scripts during an animation\n\nTypes that animate properties based on data types\n<g>AnchorAnimation</g> Animates changes in anchor values\n<g>ColorAnimation</g> Animates changes in color values\n<g>NumberAnimation</g> Animates changes in qreal-type values\n<g>ParentAnimation</g> Animates changes in parent values\n<g>PathAnimation</g> Animates an item along a path\n<g>PropertyAnimation</g> Animates changes in property values\n<g>RotationAnimation</g> Animates changes in rotation values\n<g>Vector3dAnimation</g> Animates changes in QVector3d values\n\nProperties                  Signals               Methods\n<c>\nalwaysRunToEnd:bool    started()         complete()\nloops:int              stopped()         pause()\npaused:bool                              restart()\nrunning:bool                             resume()\n                                         start()\n                                         stop() \n</c>     \n <b>-PropertyAnimation</b>\nPropertyAnimation provides a way to animate changes to a property\'s value.  It can be used to define animations in a number of ways:\n\nIn a Transition\n<cb>\n<l><main.qml</l>\nimport QtQuick 2.0\nItem{\nid:itemid\nwidth:200;height:200\n Rectangle {\n id: rect\n width: 50; height: 50\n color: "red"\n  states: [\n   State {\n   name: "moved"\n   PropertyChanges { target: rect; x:itemid.width-this.width;y:itemid.height-this.height }\n   },\n   State{\n   name:""\n   PropertyChanges{target:rect;x:0;y:0}\n   }]\n  transitions: Transition {\n  PropertyAnimation { properties: "x,y"; easing.type: Easing.InOutQuad;duration:5000 }\n  }\n }\nfocus:true\n Keys.onSpacePressed:rect.state="moved"\n Keys.onTabPressed:rect.state=""\n}\n</cb>\n\n<m>http://minhinc.42web.io/image/qml-slide-animationpropertyanimation.png</m>\n\nIn a Behavior\n<c>\nRectangle {\nwidth: 100; height: 100\ncolor: "red"\n Behavior on x { PropertyAnimation {} }\n MouseArea { anchors.fill: parent; onClicked: parent.x = 50 }\n}\n</c>\n\nAs a property value source\nFor example, to repeatedly animate the rectangle\'s x property:\n<c>\nRectangle {\nwidth: 100; height: 100\ncolor: "red"\n SequentialAnimation on x {\n loops: Animation.Infinite\n PropertyAnimation { to: 50 }\n PropertyAnimation { to: 0 }\n }\n}\n</c>\n\nIn a signal handler\n<c>\nMouseArea {\n anchors.fill: theObject\n onClicked: PropertyAnimation { target: theObject; property: "opacity"; to: 0 }\n}\n</c>\n\nStandalone\n<cb>\nimport QtQuick 2.0\nRectangle {\nid: theRect\nwidth: 100; height: 100\ncolor: "red"\n // this is a standalone animation, it\'s not running by default\n PropertyAnimation { id: animation; target: theRect; property: "width"; to: 30; duration: 500 }\n// MouseArea { anchors.fill: parent; onClicked: animation.running = true }\n MouseArea { anchors.fill: parent; onClicked: animation.start() }\n}\n</cb>\n\n <b>-PathAnimation</b>\npathanimation does animation on a set of pixels defined by Path Class.\n\n<cb>\n<l><main.qml></l>\nimport QtQuick 2.0\nRectangle {\nid: window\nwidth: 320;height: 480\n Canvas {\n id: canvas\n anchors.fill: parent\n antialiasing: true\n  onPaint: {\n  var context = canvas.getContext("2d")\n  context.clearRect(0, 0, width, height)\n  context.strokeStyle = "red"\n  context.path = pathAnim.path\n  context.stroke()\n  }\n }\n SequentialAnimation {\n running: true\n loops: -1\n PauseAnimation { duration: 1000 }\n  PathAnimation {\n  id: pathAnim\n  duration: 8000\n  easing.type: Easing.InQuad\n  target: box\n  orientation: PathAnimation.RightFirst\n  anchorPoint: Qt.point(box.width/2, box.height/2)\n   path: Path {\n   startX: 50; startY: 50\n    PathCubic {\n    x: window.width - 50\n    y: window.height - 50\n    control1X: x; control1Y: 50\n    control2X: 50; control2Y: y\n    }\n   onChanged: canvas.requestPaint();\n   }\n  }\n }\n Rectangle {\n  id: box\n  x: 25; y: 25\n  width: 50; height: 50\n  border.width: 1\n  antialiasing: true\n  Text {\n   anchors.centerIn: parent\n   text: "Box"\n  }\n }\n}\n</cb>\n\n<m>http://minhinc.42web.io/image/qml-slide-animationpath.png</m>\n\n<h>\n*Behaviour on <property>\n*Animation on <property>\n*StandAlone Animation\n</h>\n\nDefault Animation as Behaviors\n<c>\nRectangle {\nwidth: 75; height: 75; radius: width\nid: ball\ncolor: "salmon"\n Behavior on x {\n  NumberAnimation {\n  id: bouncebehavior\n   easing {\n   type: Easing.OutElastic\n   amplitude: 1.0\n   period: 0.5\n   }\n  }\n }\n Behavior on y {\n  animation: bouncebehavior\n }\n Behavior {\n  ColorAnimation { target: ball; duration: 100 }\n }\n}\n</c>\n\n<h>\n*Easing Curves\n</h>\nEasing\nEasing curves define how the animation will interpolate between the start value and the end value. Different easing curves might go beyond the defined range of interpolation. The easing curves simplify the creation of animation effects such as bounce effects, acceleration, deceleration, and cyclical animations,i.e Linear, Quad. For some curves,i.e. Easing.InOutElastic, amplitude, period and/or overshoot should also be mentioned.\n\n<c>\nPropertyAnimation { properties: "y";\n easing.type: Easing.InOutElastic;\n easing.amplitude: 2.0;\n easing.period: 1.5 }\n</c>\n\n<m>http://minhinc.42web.io/image/qml-slide-animationeasying.png</m>\n\n<m>http://minhinc.42web.io/image/qml-slide-animationeasying2.png</m>\n\n\n<h>\n*Animation Groups\n</h>\nThere are two animation groups. SequentialAnimation and ParallelAnimation. They group contained animation sequentially and parallaly respectively.\n<c>\nimport QtQuick 2.0\nRectangle {\nwidth: 100; height: 100\ncolor: "red"\n MouseArea{\n anchors.fill:parent\n onClicked:seqid.start()\n }\n SequentialAnimation on color {\n id:seqid\n ColorAnimation { to: "yellow"; duration: 1000 }\n ColorAnimation { to: "blue"; duration: 1000 }\n }\n}\n</c>\nOnce individual animations are placed into a SequentialAnimation or ParallelAnimation, they can no longer be started and stopped independently. The sequential or parallel animation must be started and stopped as a group.\n\nSharing Animation Instances\nSharing animation instances between Transitions or Behaviors is not supported, and may lead to undefined behavior.\n\n<c>\nRectangle {\n// NOT SUPPORTED: this will not work correctly as both Behaviors\n// try to control a single animation instance\nNumberAnimation { id: anim; duration: 300; easing.type: Easing.InBack }\nBehavior on x { animation: anim }\nBehavior on y { animation: anim }\n}\n</c>\n\nSolution\n<c>\n// MyNumberAnimation.qml\nNumberAnimation { id: anim; duration: 300; easing.type: Easing.InBack }\n// main.qml\nRectangle {\nBehavior on x { MyNumberAnimation {} }\nBehavior on y { MyNumberAnimation {} }\n}\n</c>'
'12!ABS SBA!Qt Quick Controls!ABS SBA!*Place Anchor layout inside Vertical layout!ABS SBA!<h>\n*Qt Quick Designer\n</h>\n\n<h>\n*Qt Quick Controls\n</h>\n\n<m>https://www.youtube.com/embed/5dYr8qpqDXg</m>\n\n<cc>\n                       Animation\n                          .\n                         / \\\n                          -\n                          |\n+-----------+-----------+-+-----------+-------------+------------------+\n|           |           | |           |             |                  |\n----------- ----------- | ----------- ----------- ----------- ----------\n|Anchor   | |Parallel | | |Parent   | |Path     | |Pause    | |Property|\n|Animation| |Animation| | |Animation| |Animation| |Animation| |Action  |\n----------- ----------- | ----------- ----------- ----------- ----------\n                        |\n                        |\n      +-----------------+-----+\n      |         |             |\n----------- ---------  ------------\n|Property | |Script |  |Sequential|\n|Animation| |Action |  |Animation |\n----------- ---------  ------------\n    .\n   / \\\n    -\n    |\n+-----------+-----------+\n|           |           |\n----------- ----------- ----------- -----------\n|Color    | |Number   | |Rotation | |Vector3d |\n|Animation| |Animation| |Animation| |Animation|\n----------- ----------- ----------- -----------\n</cc>\n\nControl is the base type of user interface controls. It receives input events from the window system, and paints a representation of itself on the screen. \n\nQt Quick Controls classes comes from module QtQuick.Controls\nclasses\n-------\n<cc>\nApplicationWindow : Provides a top-level application window\nBusyIndicator : A busy indicator\nButton : A push button with a text label\nCalendar : Provides a way to select dates from a calendar\nCheckBox : A checkbox with a text label\nComboBox : Provides a drop-down list functionality\nGroupBox : Group box frame with a title\nLabel : A text label\nMenu : Provides a menu component for use as a context menu, popup menu, or as part of a menu bar\nMenuBar : Provides a horizontal menu bar\nProgressBar : A progress indicator\nRadioButton : A radio button with a text label\nScrollView : Provides a scrolling view within another Item\nSlider : Provides a vertical or horizontal slider control\nSpinBox : Provides a spin box control\nSplitView : Lays out items with a draggable splitter between each item\nStackView : Provides a stack-based navigation model\nStackViewDelegate : A delegate used by StackView for loading transitions\nStatusBar : Contains status information in your app\nSwitch : A switch Tab Represents the content of a tab in a TabView\nTabView : A control that allows the user to select one of multiple stacked items\nTableViewColumn : Used to define columns in a TableView or in a TreeView\nTextArea : Displays multiple lines of editable formatted text\nTextField : Displays a single line of editable plain text\nToolBar : Contains ToolButton and related controls\nToolButton : Provides a button type that is typically used within a ToolBar\nTableView : Provides a list view with scroll bars, styling and header sections\nTreeView : Provides a tree view with scroll bars, styling and header sections\nAction : Abstract user interface action that can be bound to items\nExclusiveGroup : Way to declare several checkable controls as mutually exclusive\nMenuItem : Item to add in a menu or a menu bar\nMenuSeparator : Separator for items inside a menu\nStack : Provides attached properties for items pushed onto a StackView\n</cc> \n\nA Quick control has following property\nProperty\n<cc>\nProperties\navailableHeight : real\navailableWidth : real\nbackground : Item\nbottomPadding : real\ncontentItem : Item\nfocusPolicy : enumeration\nfocusReason : enumeration\nfont : font\nhoverEnabled : bool\nhovered : bool\nleftPadding : real\nlocale : Locale\nmirrored : bool\npadding : real\nrightPadding : real\nspacing : real\ntopPadding : real\nvisualFocus : bool\nwheelEnabled : bool\n</cc>\n\n<m>http://minhinc.42web.io/image/qml-slide-quickcontrol.png</m>\n\ne.x Button\n<c>\nRowLayout {\n Button {\n text: "Ok"\n onClicked: model.submit()\n }\n Button {\n text: "Cancel"\n onClicked: model.revert()\n }\n}\n</c>\n<m>https://www.youtube.com/embed/Rkg6CD05Urk</m>\n\n<m>https://www.youtube.com/embed/qyWunbEO88w</m>\n\n<h>\n*Application Window\n</h>\n\nApplicationWindow is similar to QMainWindow on QWidget side which contains MeneBar ToolBar Statusbar like predefined gadgets.\n\n<m>http://minhinc.42web.io/image/qml_slide_applicationwindow.png</m>\n\nexample\n<c>\nApplicationWindow {\n id: window\n visible: true\n menuBar: MenuBar {\n  Menu { MenuItem {...} }\n  Menu { MenuItem {...} }\n }\n toolBar: ToolBar {\n  RowLayout {\n   anchors.fill: parent\n   ToolButton {...}\n  }\n }\n TabView {\n  id: myContent\n  anchors.fill: parent\n  ...\n }\n}\n</c>\n\nOn C++ side QtQuickView can not be used as C++ type as it instantiate ApplicationWindow, instead QQmlApplicationEngine would be used. To fetch the QQuickWindow, root object can be returned\n\n<c>\nint main(int argc,char *argv[]){\nQGuiApplication(argc, argv);\nQQmlApplicationEngine engine("main.qml");\nQQuickWindow *win=engine.rootObjects()[0];\nreturn app.exec();\n}\n</c>\n\n<h>\n*Controls and Views\n</h>\n\n<c>\nListModel {\nid: nameModel\nListElement { name: "Alice" }\nListElement { name: "Bob" }\nListElement { name: "Jane" }\nListElement { name: "Victor" }\nListElement { name: "Wendy" }\n}\nComponent {\nid: nameDelegate\nText {\ntext: name;\nfont.pixelSize: 32\n}\n}\n</c>\n\nUsing Views\nList Views\n<c>\nListView {\nanchors.fill: parent\nmodel: nameModel\ndelegate: nameDelegate\nclip: true\n}\n</c>\n\n<h>\n*Layouts\n</h>\n\nGrid Layout\n<c>\nimport QtQuick 2.0\nGrid {\nx: 15; y: 15; width: 300; height: 300\ncolumns: 2; rows: 2; spacing: 20\nRectangle { width: 125; height: 125; color: "red" }\nRectangle { width: 125; height: 125; color: "green" }\nRectangle { width: 125; height: 125; color: "silver" }\nRectangle { width: 125; height: 125; color: "blue" }\n}\n\nimport QtQuick 2.0\nRectangle {\nwidth: 400; height: 400; color: "black"\nGrid {\nx: 5; y: 5\nrows: 5; columns: 5; spacing: 10\nRepeater { model: 24\nRectangle { width: 70; height: 70\ncolor: "lightgreen" } }\n}\n}\n</c>\n\n<h>\n*Styling\n</h>\nqml application can have many styling which can be set\na)in main.cpp\n<c>\n    QQmlApplicationEngine engine;\n    QQuickStyle::setStyle("Fusion");\n    engine.load(QUrl(QStringLiteral("qrc:/main.qml")));\n    if (engine.rootObjects().isEmpty())\n        return -1;\n</c>\nb) qtquickcontrols2.conf. Qt Quick Controls 2 support a special configuration file, :/qtquickcontrols2.conf, that is built into an application\'s resources.\n<c>\n [Controls]\n  Style=Material\n\n  [Universal]\n  Theme=Dark\n  Accent=Red\n\n  [Material]\n  Theme=Light\n  Accent=Teal\n  Primary=BlueGrey\n</c>\n\n<h>\n*Qml Transformation\n</h>\n\n<m>https://www.youtube.com/embed/frC9nZGrLAM</m>\n<m>https://www.youtube.com/embed/Q9j-fRWGed8</m>'
'13!ABS SBA!Presenting Data!ABS SBA!*Implement List data model view through\ndelegate!ABS SBA!<h>\n*Data Item\n- Arranging Items\n  - Positioners\n  - Repeaters\n</h>\nArranging Items\nPositioners and repeaters make it easier to work with many items.\n <b>-Item Positioners</b>\n\n<n>Positioner items are container items that manage the positions of items in a declarative user interface. Positioners behave in a similar way to the layout managers used with standard Qt widgets, except that they are also containers(<g>Item</g> subclassed) in their own right.</n>\n\nSet of Positioners\n<g>LayoutMirroring</g> Property used to mirror layout behavior\n<g>Column</g> Positions its children in a column\n<g>Flow</g> Positions its children side by side, wrapping as necessary\n<g>Grid</g> Positions its children in grid formation\n<g>Positioner</g> Provides attached properties that contain details on where an item exists in a positioner\n<g>Row</g> Positions its children in a row\n\nLayoutMirroring and Positioner are attached property used to provide mirroring and give special information to Positioners Item containers,i.e. Rectangle, respectively.\nLayoutMirroring\nThe <g>LayoutMirroring</g> attached property is used to horizontally mirror Item anchors, positioner types (such as Row and Grid) and views (such as GridView and horizontal ListView). Mirroring is a visual change: left anchors become right anchors, and positioner types like Grid and Row reverse the horizontal layout of child items.\nProperties\n<cc>\nchildrenInherit : bool\nenabled : bool \n</cc>\n\nPositioner\nAn object of type <g>Positioner</g> is attached to the top-level child item within a Column, Row, Flow or Grid. It provides properties that allow a child item to determine where it exists within the layout of its parent Column, Row, Flow or Grid \nProperties\n<cc>\nindex : int\nisFirstItem : bool\nisLastItem : bool \n</cc>\n\n<cc>\n<l><main.qml></l>\n<G>import</g> QtQuick 2.0\n<G>Rectangle</g> {\n//LayoutMirroring.enabled: true\n//LayoutMirroring.childrenInherit: true\ncolor: "yellow"\nborder.width: 1\n <G>Row</g> {\n// LayoutMirroring.enabled: true\n// LayoutMirroring.childrenInherit: true\n anchors { left: parent.left; margins: 5 }\n y: 5; spacing: 5\n  Repeater {\n  model: 5\n   Rectangle {\n   color: "red"\n   opacity: (5 - index) / 5\n   width: 40; height: 40\n    Text {\n     text: parent.Positioner.index + 1\n     anchors.centerIn: parent\n    }\n   }\n  }\n }\n Row {\n LayoutMirroring.enabled: true    <l>//LayoutMirroring Attached property</l>\n LayoutMirroring.childrenInherit: true\n anchors { left: parent.left; margins: 5 }\n y: 5; spacing: 5\n  Repeater {\n  model: 5\n   Rectangle {\n   color: "red"\n   opacity: (5 - index) / 5\n   width: 40; height: 40\n    Text {\n     text: parent.Positioner.index + 1 <l>//Positioner Attached property</l>\n     anchors.centerIn: parent\n    }\n   }\n  }\n }\n}\n</cc>\n\n<m>http://minhinc.42web.io/image/qml-slide-presentingdatapositioner.png</m>\n\nColumn, Row, Grid and Flow are Item Positioners type which is subclass of Item type contains other Items\n<c>\n                Item\n                / \\\n                 -\n                 |\n +--------------------+----------------+----------------+\n |                    |                |                |\n Column              Row              Grid             Flow\n+add:Transition      +add:Transition  +add:Transition  +add:Transition\n+move:Transition     +move:Transition +move:Transition +move:Transition\n+populate:Transition <cc>+populate:Transition            +populate:Transition             +populate:Transition</cc>\n+spacing             +spacing         +spacing         +spacing\n</c>\n\nColumn\nColumn is a type that positions its child items along a single column. It can be used as a convenient way to vertically position a series of items without using anchors.\n\n<c>\n<l><main.qml></l>\nimport QtQuick 2.0\nColumn{\nspacing:10\n Repeater{\n model:["green","red","blue","pink","green"]\n  Rectangle{\n  width:100;height:30\n  color:modelData\n   Text{\n   text:((parent.Positioner.isFirstItem)?"First Item : ":((parent.Positioner.isLastItem)?"Last Item : ":""))+parent.Positioner.index\n   color:"white"\n   anchors.centerIn:parent\n   }\n  }\n }\n}\n</c>\n\n<m>http://minhinc.42web.io/image/qml-slide-presentingdatacolumn.png</m>\n\nFlow\nThe Flow item positions its child items like words on a page, wrapping them to create rows or columns of items.\n\n<cb>\n<l><main.qml></l>\nimport QtQuick 2.7\nItem {\nwidth: 600\nheight: 600\n Component {\n id: element\n  Rectangle {\n  width: Math.round(Math.random() * 100) + 50\n  height: Math.round(Math.random() * 100) + 50\n  color: Qt.rgba(Math.random(),Math.random(),Math.random(),1)\n  }\n }\n Flow {\n id: flow\n spacing: 2\n anchors.fill: parent\n  add: Transition {\n   NumberAnimation { properties: "x,y"; easing.type: Easing.OutBack }\n  }\n move: add\n }\n/* Timer {\n id: timer\n property bool is_add: true\n interval: 1000\n repeat: true\n running: true\n onTriggered: {\n  if(timer.is_add) {\n   element.createObject(flow);\n   if(flow.children.length > 20) timer.is_add = false;\n  } else {\n   flow.children[0].destroy();\n   if(flow.children.length <= 1) timer.is_add = true;\n  }\n }\n}*/\nfocus:true\nKeys.onSpacePressed:element.createObject(flow);\nKeys.onEscapePressed:flow.children[0].destroy();\n}\n</cb>\n\n<m>http://minhinc.42web.io/image/qml-slide-presentingdataflow.png</m>\nspace keypress adds to it and escape delete at position 0\n\n<b>-Repeater</b>\nThe Repeater type is used to create a large number of similar items. Like other view types, a Repeater has a model and a delegate: for each entry in the model, the delegate is instantiated in a context seeded with data from the model. A Repeater item is usually enclosed in a positioner type such as Row or Column to visually position the multiple delegate items created by the Repeater.\nProperties\n<cc>\n count : int\n delegate : Component\n model : any \n</cc>\nSignals\n<cc>\n itemAdded(int index, Item item)\n itemRemoved(int index, Item item) \n</cc>\nMethods\n<cc>\n Item itemAt(index) \n</cc>\n<c>\nGrid {  <cc><-- Positioner Type</cc>\n  Repeater {\n  model: 16  <cc><-------- Model</cc>\n  Rectangle {  <cc><------- Delegate</cc>\n   id: rect\n   width: 30; height: 30\n   border.width: 1\n   color: Positioner.isFirstItem ? "yellow" : "lightsteelblue"\n   Text { text: rect.Positioner.index }\n  }\n }\n}\n</c>\n\n<m>http://minhinc.42web.io/image/qml-slide-positioner_repeater.png</m>\n\n<h>\n*Scene Graph\n - Data Models\n - Using Views\n - Using Delegates\n</h>\n<b>Data Models</b>\nModels and views provide a way to handle data sets\n - Models hold data or items\n - Views display data or items using delegates\n<m>http://minhinc.42web.io/image/qml-slide-datamodel.png</m>\nData is provided to the delegate via named data roles which the delegate may bind to\nMainly of following kind of models.\n - ListModel\n - XmlListModel\n - VisualItemModel\n - ObjectModel\n - Integer as Model\n - Object Instances as Models\n - Repeaters\n\n- ListModel\nListModel is a simple hierarchy of types specified in QML. The available roles are specified by the ListElement properties.\n<c>\nListModel {\n id: fruitModel\n ListElement { name: "Apple";cost: 2.45 }\n ListElement { name: "Orange";cost: 3.25 }\n ListElement { name: "Banana";cost: 1.95 }\n}\n</c>\nThe above model has two roles, name and cost. These can be bound to by a ListView delegate, for example:\n<c>\nListView {\n anchors.fill: parent\n model: fruitModel\n delegate: Row {\n  Text { text: "Fruit: " + name }\n  Text { text: "Cost: $" + cost }\n }\nMouseArea {\n anchors.fill: parent\n onClicked: fruitModel.append({"cost": 5.95, "name":"Pizza"})\n}\n}\n</c>\nfruitModel can be appended through javascript code\n\n- XmlListModel\nXmlListModel allows construction of a model from an XML data source. The roles are specified via the XmlRole type. The type needs to be imported.\n<c>\nimport QtQuick.XmlListModel 2.0\n</c>\nThe following model has three roles, title, link and description:\n<c>\nXmlListModel {\n id: feedModel\n source: "http://rss.news.yahoo.com/rss/oceania"\n query: "/rss/channel/item"\n XmlRole { name: "title"; query: "title/string()" }\n XmlRole { name: "link"; query: "link/string()" }\n XmlRole { name: "description"; query: "description/string()" }\n}\n</c>\n\n- ObjectModel\nA ObjectModel contains the visual items to be used in a view. When a ObjectModel is used in a view, the view does not require a delegate since the ObjectModel already contains the visual delegate (items).\nAn item can determine its index within the model via the index attached property.\n<c>\nimport QtQuick 2.0\nimport QtQml.Models 2.1\nRectangle {\n ObjectModel {\n  id: itemModel\n  Rectangle { height: 30; width: 80; color: "red" }\n  Rectangle { height: 30; width: 80; color: "green" }\n  Rectangle { height: 30; width: 80; color: "blue" }\n }\n ListView {\n  anchors.fill: parent\n  model: itemModel\n }\n}\n</c>\n<m>http://minhinc.42web.io/image/qml-slide-objectmodel.png</m>\n\n-Integer as Model\nAn integer can be used as a model that contains a certain number of types. In this case, the model does not have any data roles.\nThe following example creates a ListView with five elements:\n<c>\nItem {\n width: 200; height: 250\n Component {\n  id: itemDelegate\n  Text { text: "I am item number: " + index }\n }\n ListView {\n  anchors.fill: parent\n  model: 5\n  delegate: itemDelegate\n }\n}\n</c>\n \n- Object Instances as Models\nAn object instance can be used to specify a model with a single object type. The properties of the object are provided as roles.\n<c>\nRectangle {\n width: 200; height: 250\n Text {\n  id: myText\n  text: "Hello"\n  color: "#dd44ee"\n }\n Component {\n  id: myDelegate\n  Text { text: model.color }  <cc><--- Explicitly calling model.color </cc>\n }\n ListView {\n  anchors.fill: parent\n  anchors.topMargin: 30\n  model: myText\n  delegate: myDelegate\n }\n}\n</c>\n\n-Repeaters\nRepeaters create items from a template for use with positioners, using data from a model. Combining repeaters and positioners is an easy way to lay out lots of items. A Repeater item is placed inside a positioner, and generates items that the enclosing positioner arranges. Each Repeater creates a number of items by combining each element of data from a model, specified using the model property.\n<c>\nimport QtQuick 2.0\nRectangle {\n width: 400; height: 400; color: "black"\n Grid {\n  x: 5; y: 5\n  rows: 5; columns: 5; spacing: 10\n  Repeater { model: 24\n   Rectangle { width: 70; height: 70\n    color: "lightgreen"\n    Text { text: index\n     font.pointSize: 30\n     anchors.centerIn: parent } }\n  }\n }\n}\n</c>\n<b>- Using Views</b>\nViews are containers for collections of items. They are feature-rich and can be customizable to meet style or behavior requirements.\nViews allow visual customization through decoration properties such as the header, footer, and section properties. By binding an object, usually another visual object, to these properties, the views are decoratable. A footer may include a Rectangle type showcasing borders or a header that displays a logo on top of the list.\n\nA set of standard views are provided in the basic set of Qt Quick graphical types:\nListView - arranges items in a horizontal or vertical list\nGridView - arranges items in a grid within the available space\nPathView - arranges items on a path\n\n- ListView\n<c>\nListModel {\n id: nameModel\n ListElement { name: "Alice" }\n ListElement { name: "Bob" }\n ListElement { name: "Jane" }\n ListElement { name: "Harry" }\n ListElement { name: "Wendy" }\n}\nComponent {\n id: nameDelegate\n Text {\n  text: name;\n  font.pixelSize: 24\n }\n}\nListView {\n anchors.fill: parent\n clip: true\n model: nameModel\n delegate: nameDelegate\n header: bannercomponent\n footer: Rectangle {\n  width: parent.width; height: 30;\n  gradient: clubcolors\n }\n highlight: Rectangle {\n  width: parent.width\n  color: "lightgray"\n }\n}\nComponent {     //instantiated when header is processed\n id: bannercomponent\n Rectangle {\n  id: banner\n  width: parent.width; height: 50\n  gradient: clubcolors\n  border {color: "#9EDDF2"; width: 2}\n  Text {\n   anchors.centerIn: parent\n   text: "Club Members"\n   font.pixelSize: 32\n  }\n }\n}\nGradient {\n id: clubcolors\n GradientStop { position: 0.0; color: "#8EE2FE"}\n GradientStop { position: 0.66; color: "#7ED2EE"}\n}\n</c>\n\n<b>- Using Delegates </b>\nViews need a delegate to visually represent an item in a list. A view will visualize each item list according to the template defined by the delegate. Items in a model are accessible through the index property as well as the item\'s properties.\n<c>\nComponent {\nid: petdelegate\nText {\n id: label\n font.pixelSize: 24\n text: if (index == 0)\n  label.text = type + " (default)"\n else\n  text: type\n }\n}\n</c>\n<m>http://minhinc.42web.io/image/qml-slide-delegate.png</m>\n\nThe list view to which the delegate is bound is accessible from the delegate through the ListView.view property. Likewise, the GridView GridView.view is available to delegates. The corresponding model and its properties, therefore, are available through ListView.view.model. In addition, any defined signals or methods in the model are also accessible.\n\n<c>\nRectangle {\n width: 200; height: 200\nListModel {\n id: fruitModel\n property string language: "en"\n ListElement {\n  name: "Apple"\n  cost: 2.45\n }\n ListElement {\n  name: "Orange"\n  cost: 3.25\n }\n ListElement {\n  name: "Banana"\n  cost: 1.95\n }\n}\nComponent {\n id: fruitDelegate\n Row {\n  id: fruit\n  Text { text: " Fruit: " + name; color: fruit.ListView.view.fruit_color }\n  Text { text: " Cost: $" + cost }\n  Text { text: " Language: " + fruit.ListView.view.model.language }\n }\n}\nListView {\n property color fruit_color: "green"\n model: fruitModel\n delegate: fruitDelegate\n anchors.fill: parent\n}\n}\n</c>\n \n\n<h>\n*Implement List data model view through delegate\n</h>\n\n<cc>\n<l><main.pro></l>\nQT+=quick\nTEMPLATE = app\nTARGET = modelapp\nINCLUDEPATH += .\nRCC_DIR=build\nOBJECTS_DIR=build\nMOC_DIR=build\n\n# Input\nHEADERS += person.h\nSOURCES += main.cpp person.cpp\nRESOURCES += main.qrc\n\n<l><main.qrc></l>\n<RCC>\n <qresource>\n  <file>main.qml</file>\n </qresource>\n</RCC>\n</cc>\n\n<cb>\n<l><person.h></l>\n#ifndef PERSON_H\n#define PERSON_H\n#include <QObject>\n#include <QString>\n#include <QList>\nclass Person:public QObject {\nQ_OBJECT\nQ_PROPERTY(QString name READ name WRITE setName)\nQ_PROPERTY(int age READ age WRITE setAge)\nQ_ENUMS(Height)\nQ_PROPERTY(Height height READ height WRITE setHeight)\npublic:\nPerson(QObject *p=0);\nenum Height{SHORT=0,MID,TALL};\nQString name() const;\nvoid setName(const QString&);\nint age() const;\nvoid setAge(int);\nHeight height() const;\nvoid setHeight(Height);\nprivate:\nQString _name;\nint _age;\nHeight _height;\n};\n#endif\n</cb>\n\n<cb>\n<l><person.cpp></l>\n#include "person.h"\nPerson::Person(QObject *p):QObject(p){}\nQString Person::name() const{ return _name; }\nvoid Person::setName(const QString& name){\nif (name!=_name){\n_name=name;\n//emit nameChanged();\n}\n}\nint Person::age() const{ return _age; }\nvoid Person::setAge(int age){\nif (age!=_age){\n_age=age;\n//emit ageChanged();\n}\n}\nPerson::Height Person::height()const { return _height; }\nvoid Person::setHeight(Person::Height height){\nif (_height!=height){\n_height=height;\n//emit heightChanged();\n}\n}\n</cb>\n\n<cb>\n<l><main.cpp></l>\n#include <QGuiApplication>\n#include <QQmlEngine>\n#include <QQuickView>\n#include <QDebug>\n#include "person.h"\n\nint main(int argc, char ** argv) {\nQGuiApplication app(argc, argv);\nqmlRegisterType<Person>("Person", 1,0, "Person");\n QQuickView view; \n view.setResizeMode(QQuickView::SizeRootObjectToView);\n view.setSource(QUrl("qrc:main.qml"));\n view.show();\nreturn app.exec();\n}\n</cb>\n\n<cb>\n<l><main.qml></l>\nimport QtQuick 2.0\nimport Person 1.0\nItem{\nproperty list<Person> personmodel:[Person{name:"John";age:20;height:Person.MID}, Person{name:"Rinku";age:10;height:Person.TALL} ]\nListView{\nwidth:200;height:400\nmodel:personmodel\ndelegate:Text{\ntext:name+":"+age+":"+height\n}\n}\n}\n</cb>\n\n<m>http://minhinc.42web.io/image/qml-slide-presentingdataimplementdatamodel.png</m>'
'31!ABS SBA!title!ABS SBA!None!ABS SBA!Qml QtQuick Essentials Training'
'32!ABS SBA!subtitle!ABS SBA!None!ABS SBA!3-day session'
'33!ABS SBA!h_Overview!ABS SBA!None!ABS SBA!Qt Quick scene graph concept\nUnderstanding Qml Component/Document/Module Architecute\nUnderstanding QtQuick classes\nExporting C++ class to Qml as object and class type\nThree layers software development with qml and c++\nDynamic Properties'
'34!ABS SBA!h_Duration!ABS SBA!None!ABS SBA!Three days - 15 hours (5 hours a day)\n4hrs lecture, 1hr practical lab review'
'35!ABS SBA!h_Trainer!ABS SBA!None!ABS SBA!<a href="https://www.linkedin.com/in/pravinkumarsinha">http://www.linkedin.com/in/pravinkumarsinha</a>'
'36!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'37!ABS SBA!h_Prerequisite!ABS SBA!None!ABS SBA!<b>Knowledge of Qt programming</b>\nKnowledge of Qt programming is important. Technically Qml is javascript\ncounter part of Python Qt. Knowing Qt will help fast understanding of Qml.\nQt slides can browsed at\n<a href=http://minhinc.42web.io/training/qt/advance-qt-slides.php>http://minhinc.42web.io/training/qt/advance-qt-slides.php</a>\n\nPdf document can be downloaded from\n<a href=http://minhinc.42web.io/training/advance-qt-slides.pdf>http://minhinc.42web.io/training/advance-qt-slides.pdf</a>\n\n<b>Knowledge of GUI and other concepts</b>\nQt/Qml is used for GUI development and many other technologies including \nNetworks, operating systems, Database, scripting. Basic knowledge of these domains \nare required as per the Qt/Qml is developed for the particular domain.'
'38!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'39!ABS SBA!h_Setup!ABS SBA!None!ABS SBA!Ubuntu LTS 18.x Qt 5.11/5.12'
'40!ABS SBA!h2_Lecture!ABS SBA!None!ABS SBA!Lecture session will be course content presentation through the trainer.\nAny source code example related to the topic will be demonstrated, it would\ninclude executing the binaries. Lecture content can be downloaded at \n<a href=http://minhinc.42web.io/training/advance-qml-slides.pdf>http://minhinc.42web.io/training/advance-qml-slides.pdf</a>'
'41!ABS SBA!h2_Labs!ABS SBA!None!ABS SBA!Labs session would be completely hands on session where each example (with\nexample data and execution instruction) would be provided to the students. Students\ncan verify their results with the results provided in the material.'
      qt      
'1!ABS SBA!Introduction!ABS SBA!*Qt Creator\n*Qt Designer\n*Qt Debugging\n*Writing Hello World using Qt Creator!ABS SBA!<h>\n*GUI Programming Fundamentals\n - Window registration and creation\n- Message loop\n - Event callback handler\n</h>\n<a>\n<b>Abstract</b>:It describes X11 gui fundamentals, as how a basic window is created in client server model of X11. This section also describes the flow of hardware event generation to event dispatching to app event queue. It mentions role of X11 server and Window manager entities on Server side. On client side how a event callback function is registered (against a window) with the X11 server and Window manager then how events generated on window are routed to registered callback function of application. Events are further processed through event loop processing manner quite different from sequential processing of non gui application. This section also lists the various Qt classes against each section in GUI programming.\n</a>\n\n<b>Window registration and creation.</b>\n<m>http://minhinc.42web.io/image/qt-slide-winregcreation.gif</m>\n<cb>\nDisplay *dis;\nint screen;\nWindow win;\nGC gc;\nvoid init_x() {\n/* get the colors black and white (see section for details) */\n unsigned long black,white;\n/* use the information from the environment variable DISPLAY to create the X connection:*/\n dis=<g>XOpenDisplay</g>((char *)0);\n screen=<g>DefaultScreen</g>(dis);\n black=<g>BlackPixel</g>(dis,screen),/* get color black */\n white=<g>WhitePixel</g>(dis, screen);  /* get color white */\n/* once the display is initialized, create the window. This window will be have be 200 pixels across and 300 down. It will have the foreground white and background black */\n win=<g>XCreateSimpleWindow</g>(dis,DefaultRootWindow(dis),0,0,200, 300, 5, white, black);\n/* here is where some properties of the window can be set. The third and fourth items          indicate the name which appears at the top of the window and the name of the minimized window respectively. */\n <g>XSetStandardProperties</g>(dis,win,"My Window","HI!",None,NULL,0,NULL);\n/* this routine determines which types of input are allowed in the input.  see the appropriate section for details... */\n <g>XSelectInput</g>(dis, win, ExposureMask|ButtonPressMask|KeyPressMask);\n/* create the Graphics Context */\n gc=<g>XCreateGC</g>(dis, win, 0,0);\n/* here is another routine to set the foreground and background colors _currently_ in use in the window. */\n <g>XSetBackground</g>(dis,gc,white);\n <g>XSetForeground</g>(dis,gc,black);\n/* clear the window and bring it on top of the other windows */\n <g>XClearWindow</g>(dis, win);\n <g>XMapRaised</g>(dis, win);\n}\nvoid close_x() {\n/* it is good programming practice to return system resources to the system... */\n <g>XFreeGC</g>(dis, gc);\n <g>XDestroyWindow</g>(dis,win);\n <g>XCloseDisplay</g>(dis);\n exit(1);\n}\n</cb>\n\n<b>Event Callback</b>\n<m>http://minhinc.42web.io/image/qt-slide-x11eventflow.png</m>\n\n<b>Message Loop</b>\n<m>http://minhinc.42web.io/image/qt-slide-messageloop.png</m>\n\n- Message loop\n  1. setting up the input masks\n  2. creating an instance of the XEvent\n  3. checking for events\n  4. handling events.\n\n<cb>\nXEvent event;/* the XEvent declaration !!! */\nKeySym key;/* a dealie-bob to handle KeyPress Events */\nchar text[255];/* a char buffer for KeyPress Events */\n/* look for events forever... */\nwhile(1) {\n /* get the next event and stuff it into our event variable.  Note:  only events we set the mask for are detected! */\n XNextEvent(dis, &event);\n if (event.type==Expose && event.xexpose.count==0) {\n /* the window was exposed redraw it! */\n  redraw();\n }\n if (event.type==KeyPress && XLookupString(&event.xkey,text,255,&key,0)==1) {\n /* use the XLookupString routine to convert the invent KeyPress data into regular text.  Weird but necessary...  */\n  if (text[0]==\'q\') {\n   close_x();\n  }\n  printf("You pressed the %c key!",text[0]);\n }\n if (event.type==ButtonPress) {\n  /* tell where the mouse Button was Pressed */\n  printf("You pressed a button at (%i,%i)", event.xbutton.x,event.xbutton.y);\n }\n}\n</cb>\n\n- Event callback handler.\n i- Registering window callback function with the Window Manager.\n   Qt Class - QWidget\n ii- Initializing Thread Event loop.\n   Qt class - QCoreApplication\n iii- Creating window.\n   Qt class - QWidget\n iv-  Generate the event, Hardware event, synthetic events\n   Qt class - QEvent\n v- Handling events specific to the window in event callback funciton.\n   Qt class - QWidget\n\n<m>http://minhinc.42web.io/image/qt-slide-x11architecture.png</m>\n<m>http://minhinc.42web.io/image/qt-slide-eventcallback.png</m>\n\n<cb>\n<g>QObject</g>  - Event mechanism, signal-slot, timer, Thread\n\n  / \\\n   -\n   |\n<g>QCoreApplication</g> - Event loop for console Qt application\n                   Network event, Timer event, Non GUI etc.\n                   exec() - starts queue\n                   quit() - ends queue, returns\n  / \\\n   -\n   |\n<g>QGuiApplication</g> - Event loop, communicates with Window Manager\n                                          Provides session\n  / \\\n   -\n   |\n<g>QApplication</g> - Event loop for GUI events\n</cb>\n\nSingle Instance of Q[Core|Gui]Application\n\n<h>\n*Qt Overview and Status\n - Qt history and its presence\n - Licensing (GPL, LGP, Commercial)\n</h>\n<a>\n<b>Abstract</b>:This section lists various licensing policies supported by Qt. GPL is completely free where as LGPL is less free to Commeriacial which is completely charged.\n</a>\n\nMeet Qt\nQt Development Frameworks founded in 1994\nTrolltech acquired by Nokia in 2008\nDigia tool control of Qt in 2012\nQt Company formed in 2013\n80 employees worldwide\nTrusted by over 6,500 companies worldwide\n8 companies out of 10 top companies uses Qt\nQt: a coss-platform application and UI framework\nFor desktop, mobile and embedded development\nUsed by more than 350,000 commercial and open source developers\nBacked by Qt consulting, support and training\n\n<m>http://minhinc.42web.io/image/qt-slide-meetqt.png</m>\n\n<c>\n                  Licensing Options\nLicense     Cost     Runtime Support  Prop.Apps. Changes\nCommercial  Charged  Yes     Included Yes        Closed\nLGPL        Free     No      Add-On   Yes        Contribute\nGPL         Free     No      Add-On   No         Contribute\n</c>\n\n* Cost: License fee charged (Charged | Free)\n* Runtime: Charge for Runtimes (Yes | No)\n* Support: (Included | Add-On)\n* Prop.Apps: Can create proprietary applications\n* Yes: In accordance with the license terms\n* No: Source code must be made available\n* Changes: Must provide source code changes to Qt\n* Closed - No source code must be disclosed\n* Contribute: Source code must be provided\n\n<b>GPL</b>\na) You must cause the modified files to carry prominent notices stating that you changed the files and the date of any change.\nb) You must cause any work that you distribute or publish, that in whole or in part contains or is derived from the Program or any part thereof, to be licensed as a whole at no charge to all third parties under the terms of this License.\nc) If the modified program normally reads commands interactively when run, you must cause it, when started running for such interactive use in the most ordinary way, to print or display an announcement including an appropriate copyright notice and a notice that there is no warranty (or else, saying that you provide a warranty) and that users may redistribute the program under these conditions, and telling the user how to view a copy of this License. (Exception: if the Program itself is interactive but does not normally print such an announcement, your work based on the Program is not required to print an announcement.)\n\n<b>LGPL</b>\na)If a program uses LGPL libraries then source code is not required to be given to user when used commercially.\nb)If LGPL library is integrated (statically) or program is derived from then LGPL or LGPL library is modified then user source code must be provided when requested through the end user.\n\n<b>Qt Modules</b>\n<m>http://minhinc.42web.io/image/qt-slide-module2_s.png</m>\n\n<h>\n*QObject\n</h>\n<a>\n<b>Abstract</b>: Qt has meta object system which creates extra information for the classes dervied from QObject and has Q_OBJECT MACRO in class private area. Extra information is stored in spearate moc_<classname> file  which extends Q_OBJECT class to have meta information in it.\n</a>\n\n<m>https://www.youtube.com/embed/glNYRahiTrE</m>\n\n<m>https://www.youtube.com/embed/IPUifRmWGrw</m>\n* QObject is the heart of Qt\'s object model\n* It is base class of all qt classes\n* Based on parent-child relationship\n* Adds features to C++, like ...\n  - Signals and slots\n  - Properties\n  - Event handling\n  - Memory Management\n  - ...\n* Some features are standard C++\n* Some use Qt\'s meta-object system\n* QObject has no visual representation\n\n<m>http://minhinc.42web.io/image/qt-slide-qobjecttree.png</m>\n\nQt\'s meta-object system provides the signals and slots mechanism for inter-object communication, run-time type information, and the dynamic property system.\nThe meta-object system is based on three things:\n 1. The QObject class\n 2. The Q_OBJECT macro inside the private section of the class\n 3. The Meta-Object Compiler (moc) extends class with meta object information\n\n<m>https://www.youtube.com/embed/KD7Ggq1iP1M</m>\nExtra information pushed by moc compiler are\n * QObject::metaObject()\n * QMetaObject::className()\n * QObject::inherits()\n * QObject::tr() and QObject::trUtf8() translate strings for internationalization.\n * QObject::setProperty() and QObject::property() dynamically set and get properties by name.\n * QMetaObject::newInstance() constructs a new instance of the class.\n\n<b>MOC compiler</b>\n<m>https://www.youtube.com/embed/FivBdWjy-vw</m>\nC++ code in Qt contains few QT specific tags and these tags are first parsed through MOC (Meta object compiler) generating final C++ code for g++ compiler.\n<cb>\nstruct myobject:QObject{\nprivate:\nQ_OBJECT  // for moc compiler, required for signal/slot support\npublic slots:        // moc term\nvoid myslot();\nsignals:            // moc term\nvoid mysignal();\n};\n</cb>\n\nSending signal\n<cb>\nemit mysignal(); // emit is moc keyword\n</cb>\n\nmoc creates meta-object information\n<cb>\n<g>moc</g> -o moc_myclass.cpp myclass.h\n<g>c++</g> -c myclass.cpp; c++ -c moc_myclass.cpp\n<g>c++</g> -o myapp moc_myclass.o myclass.o\n</cb>\n\n<h>\n*Hello World using Qt creator\n - Qt Designer\n - Qt Debugging\n</h>\n\n<b>Creator</b>\n<m>http://minhinc.42web.io/image/qt-slide-creator_s.png</m>\n\n<b>Debugger</b>\n<m>http://minhinc.42web.io/image/qt-slide-debugger_s.png</m>\n\n<cb>\n<<main.cpp>>\n#include <QApplication>\n#include <QPushButton>\nint main(int argc, char *argv[]){\nQApplication app(argc,argv);\nQPushButton *button=new QPushButton("Hello World");\nbutton->show();\nreturn app.exec();\n}\n</cb>\n\n<h>\n*Executing pyqt program\n</h>\n\n<h>\n*Qt Resources\n</h>\n<m>https://www.youtube.com/embed/RM94MIBC3Jc</m>\n\n<m>https://www.youtube.com/embed/8Yv81yIFpbI</m>\n\n<h>\n*Installing PyQt\n</h>\n\n<m>https://www.youtube.com/embed/2lKB7vEBHBo</m>'
'2!ABS SBA!Qt Core!ABS SBA!*QString, QList\n*QFile, QTextStream and QDataStream!ABS SBA!<h>\n*String Handling\n</h>\n- String handling classes:\n * Unicode-aware string and character classes.\n * Regular expression engine for pattern matching.\n\n- Strings can be created in a number of ways:\n * From a number using a static function:\n   QString n = QString::number(1234);\n * From a char pointer using the static functions:\n   QString text = QString::fromLatin1("Hello Qt");\n   QString text = QString::fromUtf8(inputText);\n   QString text = QString::fromLocal8Bit(cmdLineInput);\n\n- Other properties\n * simplified() // removes duplicate whitespace\n * left(), mid(), right() // part of a string\n * leftJustified(), rightJustified() // padded version\n   QString s = "apple";\n   QString t = s.leftJustified(8, \'.\'); // t == "apple..."\n\n- Data can be extracted from strings.\n   * Numbers:\n   int value = QString::toInt();\n   float value = QString::toFloat();\n   * Strings:\n   QString text = ...;\n   QByteArray bytes = text.toLatin1();\n   QByteArray bytes = text.toUtf8();\n   QByteArray bytes = text.toLocal8Bit();\n\n- Obtaining raw character data from a QByteArray:\n  char *str = bytes.data();\n  const char *str = bytes.constData();\n\n<h>\n*Container Classes\n</h>\n\nItem Container Classes\n  -Template-based classes can be used to store items of a specified type. i.e. for resizable array of QStrings, it is QVector<QString>.\n\nGeneral purpose template-based container classes\n  - Sequential containers\n  - Associative containers\n\n<b>Sequential container</b>\nQList<QString> Sequence Container. QList is implemented using an array ensuring that index-based access is very fast.\nQLinkedList<T> Unlike QList it uses iterator rather then index to access items. Inserting items in middle is easier.\nQVector<T> Last in, first out (LIFO).\nQstack<T> Adaptar class and subclass of QVector. push(), pop() and top().\nQQueue<T> Adapter class and subclass of QList. First in First out. enqueue(), dequeue() and head().\n\n<b>Associative containers</b>\nQMap<Key, T> maps keys of type Key to values of type T. Stores data in key order.\nQMultiMap<Key, T> QMap where key can be associated with multiple maps.\nQHash<Key, T> Similar to QMap but stores its data in a arbitrary order. Significantly faster lookup.\nQMultiHash<Key, T> Subclass of QHash provides interface for multi-valued hashes.\n\nQt\'s Item Containers compared to STL\n - Lighter, safer, and easier to use than STL containers\n - If you prefer STL, feel free to continue using it.\n - Methods exist that convert between Qt and STL e.g. you need to pass std::list to a Qt method\n\n<b>Sequential Container...</b>\nQList\n<c>\nQList<QString> list;\nlist << "one" << "two" << "three";\nQString item1 = list[1]; // "two"\nfor(int i=0; i<list.count(); i++) {\nconst QString &item2 = list.at(i);\n}\nint index = list.indexOf("two"); // returns 1\n</c>\n\n<b>Associative Container...</b>\nQMap\n<c>\nQMap<QString, int> map;\nmap["Norway"] = 5; map["Italy"] = 48;\nint value = map["France"]; // inserts key if not exists\nif(map.contains("Norway")) {\nint value2 = map.value("Norway"); // recommended lookup\n}\n</c>\n\n- Constraints\n - Values types in containers must be assignable types. Constructor,  Copy constructor and assignment operator must defined. Missing this compiler any way generates synthesised in order to have shallow copy.\n - In QMap<Key, T>, Key must support operator<.\n - All value type must also supoort operator<< and operator>> inroder to be read or written using QDataStream.\n\n<cb>\n<g>class</g> Movie{\n <l>public</l>:\n  Movie(){}\n  Movie(const Movie& other);\n  operaotr=(const Movie& other);\n <l>private</l>:\n  int id;\n  QString title;\n  QDate releaseDate;\n};\nQDataStream <l>&operator<<</l>(QDataStream &out, const Movie& movie){\n out << (qint32)movie.id << movie.title << movie.releaseDate;\n return out;\n}\nQDataStream <l>&operator>></l>(QDataStream &in, Movie &movie){\n qint32 id;\n QDate date;\n in>>id>>movie.title >> date;\n movie.id=(int)id;\n movie.releaseDate = date;\n return in;\n}\n</cb>\n\nIterators\n * Java-style iterators simple and easy to use.\n * QListIterator<...> for read\n * QMutableListIterator<...> for read-write\n\n * STL-style iterators slightly more efficient\n * QList::const_iterator for read\n * QList::iterator for read-write\n * Same works for QSet, QMap, QHash, ...\n\nJava-style\nModifying During Iteration\n  * Use mutable versions of the iterators\n  * e.g. QMutableListIterator.\n\n<c>\nQList<int> list;\nlist << 1 << 2 << 3 << 4;\nQMutableListIterator<int> i(list);\nwhile (i.hasNext()) {\nif (i.next() % 2 != 0)\ni.remove();\n}\n</c>\n\nSTL-style Iterators\n<c>\nQList<QString> list;\nlist << "A" << "B" << "C";\nQList<QString>::iterator i;\nForward mutable iteration\nfor (i = list.begin(); i != list.end(); ++i) {\n*i = (*i).toLower();\n}\n</c>\n\n* Backward mutable iteration\ni = list.end();\nwhile (i != list.begin()) {\n--i;\n*i = (*i).toLower();\n}\n\n* QList<QString>::const_iterator for read-only The foreach Keyword\n - Modifying the container while iterating\n - results in container being copied\n - iteration continues in unmodified version\n - Not possible to modify item\n - iterator variable is a const reference.\n - It is a macro, feels like a keyword\n<c>\nforeach ( variable, container ) statement\nforeach (QString str, list) {\nif (str.isEmpty())\nbreak;\nqDebug() << str;\n}\n</c>\n\nAlgorithms\n * STL-style iterators are compatible with the STL algorithms\n * Defined in the STL <algorithm> header\n * Qt has own algorithms\n * Defined in <QtAlgorithms> header\n * If STL is available on all your supported platforms you can choose to use the STL algorithms\n * The collection is much larger than the one in Qt.\n\n * qSort(begin, end) sort items in range\n * qFind(begin, end, value) find value\n * qEqual(begin1, end1, begin2) checks two ranges\n * qCopy(begin1, end1, begin2) from one range to another\n * qCount(begin, end, value, n) occurrences of value in range Counting 1\'s in list\n<c>\nQList<int> list;\nlist << 1 << 2 << 3 << 1;\nint count = 0;\nqCount(list, 1, count); // count the 1\'s\nqDebug() << count; // 2 (means 2 times 1)\n</c>\n * For parallel (ie. multi-threaded) algorithms\nImplicitly Sharing and Containers\nImplicit Sharing\nIf an object is copied, then its data is copied only when the data of one of the objects is changed\n * Shared class has a pointer to shared data block\n * Shared data block = reference counter and actual data\n * Assignment is a shallow copy\n * Changing results into deep copy (detach)\n<c>\nQList<int> l1, l2; l1 << 1 << 2;\nl2 = l1; // shallow-copy: l2 shares date with l1\nl2 << 3; // deep-copy: change triggers detach from l1\n</c>\nImportant to remember when inserting items into a container, or when returning a container.\n\n<h>\n*Advanced Container Classes\n</h>\n\n* QVarLengthArray<T, Prealloc> provides a low-level variable-length array.\n  Used instead of QVector in places where speed is particularly important.\n* QCache<Key, T> provides a cache to store objects of a certain type T\n  associated with keys of type Key.\n* QContiguousCache<T> provides an efficient way of caching data that is\n  typically accessed in a contiguous way.\n* QPair<T1, T2> stores a pair of elements.\n\n* QVarLengthArray<T, Prealloc> provides a low-level variable-length array.\n  Used instead of QVector in places where speed is particularly important.\n* QCache<Key, T> provides a cache to store objects of a certain type T\n  associated with keys of type Key.\n* QContiguousCache<T> provides an efficient way of caching data that is\n  typically accessed in a contiguous way.\n* QPair<T1, T2> stores a pair of elements.\n\nNon-template types are QBitArray, QByteArray, QString, and QStringList.\n\n<h>\n*File I/O\n</h>\n\n- Working With Files\n - For portable file access do not use the native functions like open() or CreateFile(), but Qt classes instead.\n\n -File Handling\n  * QFile\n  * Interface for reading from and writing to files\n  * Inherits QIODevice (base interface class of all I/O devices)\n\n - QTextStream\n  * Interface for reading and writing text\n\n - QDataStream\n  * Serialization of binary data\n\n- Additional\n  * QFileInfo - System-independent file information\n  * QDir - Access to directory structures and their contents\n\nFile Convenient Methods\n  * Media methods: load(fileName), save(fileName)\n  * for QPixmap, QImage, QPicture, QIcon\n  * QFileDialog\n  * QFileDialog::getExistingDirectory()\n  * QFileDialog::getOpenFileName()\n  * QFileDialog::getSaveFileName()\n  * QDesktopServices::storageLocation(type)\n  * returns default system directory where files of type belong\n\nFile operations\n  * QFile::exists(fileName)\n  * QFile::rename(oldName, newName)\n  * QFile::copy(oldName, newName)\n  * QFile::remove(fileName)\n  * Directory Information\n  * QDir::tempPath()\n  * QDir::home()\n  * Qdir::drives()\n\nVariants\n  * QVariant\n  * Acts like a union for the most common Qt data types\n  * Resides in QtCore (can\'t know outside types)\n  * For QtCore types\n<c>\nQVariant variant(42);\nint value = variant.toInt(); // read back\nqDebug() << variant.typeName(); // int\n</c>\n\n  * For none QtCore types\n<c>\nvariant.setValue(QColor(Qt::red));\nQColor color = variant.value<QColor>(); // read back\nqDebug() << variant.typeName(); // QColor\n</c>\n\nQVariant and Custom Types\n - Custom Type\n<c>\nclass Contact {\npublic:\nvoid setName(const QString &name);\nQString name() const;\n  ...\n};\n// make Contact known to meta-type system\nQ_DECLARE_METATYPE(Contact);\n</c>\n\n - Usage with QVariant\n<c>\nContact c; c.setName("Peter");\nQVariant variant = QVariant::fromValue(c);\nqDebug() << variant.typeName(); // Contact\nContact c2 = variant.value<Contact>();\nqDebug() << c2.name(); // "Peter\n</c>\n\nEXAMPLE:\n<cs>\n<QT += core TARGET = coreclass TEMPLATE = app SOURCES += coreclass.cpp>\n<c><coreclass.cpp></c>\n#include <QCoreApplication>\n#include <QtAlgorithms>\n#include <QFile>\n#include <QList>\n#include <QVector>\n#include <QTextStream>\n#include <QDataStream>\n#include <QColor>\n#include <QString>\n#include <QDebug>\nclass Contact {\nQString _name;\npublic:\nvoid setName(const QString &name){_name = name;}\nQString name() const{return _name;}\n};\nQ_DECLARE_METATYPE(Contact);\nint main(int argc, char *argv[]) {\nQCoreApplication a(argc,argv);\nQFile tfile("textfile.txt");\nQFile dfile("mydatafile.data");\nQTextStream tstream;\nQDataStream dstream;\nif(tfile.open(QIODevice::WriteOnly)) {\n tstream.setDevice(&tfile);\n}\nif(dfile.open(QIODevice::WriteOnly)) {\n dstream.setDevice(&dfile);\n}\nQList<QString> slist;\nslist<<"one"<<"two"<<"three";\nQVector<QString> svec(3);\nqCopy(slist.begin(),slist.end(),svec.begin());\nfor(QVector<QString>::iterator it=svec.begin();it!=svec.end();++it)\ntstream<<*it;\ndstream<<(QList<QString>)slist;\ntfile.close();\ndfile.close();\nQVariant variant("42");\nint value = variant.toInt(); // read back\nqDebug() << value << variant.typeName(); // int\nvariant.setValue(QColor(Qt::red));\nQColor color = variant.value<QColor>(); // read back\nqDebug() << color.name()<< variant.typeName(); // QColor\n// make Contact known to meta-type system\nContact c; c.setName("Peter");\nQVariant variant1 = QVariant::fromValue(c);\nqDebug() << variant1.typeName(); // Contact\nContact c2 = variant1.value<Contact>();\nqDebug() << c2.name(); // "Peter"\nreturn a.exec();\n}\n</cs>\nOUTPUT\n<c>\n$./coreclass\n42 QString\n"#ff0000" QColor\nContact\n"Peter"\n</c>\n\n<h>\n*Memory Mapped Files\n</h>\n\n* To map a file into memory on Unix mmap system function is used.\n - On Windows with CreateFileMapping.\n - Qt QFileDevice provides map() and unmap() that provide the ability to map files into memory.\n\n<c>\nQFile file("foo");\nfile.open(QFile::ReadOnly);\nuchar *memory = file.map(0, file.size());\nif (memory) {\n   // have some fun with the data\nfile.unmap();\n}\n</c>'
'3!ABS SBA!Memory Management!ABS SBA!*Object creation deletion\n*Object lifetime!ABS SBA!<h>\n*Qt Object Model\n</h>\nQObjectis base class of all Qt classes which supports\n- Signals and slots\n- Dynamic Properties\n- Event handling\n- Memory Management\n- Timer\n- Thread\n- Qt meta-object system\n\nQObjecthas no visual representation\n\nObjectTree\n- QObjects organize themselves in object trees\n- Based on parent-child relationship\n\nQObject(QObject*parent=0)\n- Parent adds object to set of children\n- Parent owns children\n- Construction/Destruction\n- Tree be constructured in any order\n- Tree be destroyed in any order\n- if object has parent: object first removed from parent\n- if object has children: deletes each child first\n- No object is deleted twice\nNote:Parent-child relationship is NOT inheritance\n<h>\n*ObjectLife cycle\n- Stack allocation\n- Heap allocation\n- Deleting objects\n- Object reference and Object lifetime\n</h>\n*QObject follows heap and stack life cycle.\n*Children destroyed by Parents at the time of their destruction.\n\nOnHeap - Classes inheriting from QObject\nQLabel*label = new QLabel("Some Text", parent);\n- Parent takes ownership\n- Copy is disabled\n\nOnstack - All other classes\nQStringListlist;\nQColorcolor;\n- Cheap to copy\n- Exceptions:\n\nQFile, QApplication (inheriting QObject)\nUsually allocated on the stack\nModal dialogs are often allocated on stack\n\n-QPointer(Smart Pointer in Qt)\nThe QPointer class is a template class that provides guarded pointers to Qobject. A guarded pointer, QPointer<T>, behaves like a normal C++ pointer T * except that it is automatically set to 0 when the referenced object is destroyed (unlike normal C++ pointers, which become "dangling pointers" in such cases).\n<c>\nQPointer<QLabel>label = new QLabel;\nlabel->setText("&Status:");\n...\nif (label)\nlabel->show();\n</c>\n\n-QScopePointer(Auto Pointer in Qt)\n<c>\nvoidmyFunction(bool useSubClass)\n{\nMyClass*p = useSubClass ? new MyClass() : new MySubClass;\nQIODevice*device = handsOverOwnership();\n\nif(m_value > 3) {\ndeletep;\ndeletedevice;\nreturn;\n}\ntry{\nprocess(device);\n}\ncatch(...) {\ndeletep;\ndeletedevice;\nthrow;\n}\ndeletep;\ndeletedevice;\n}\n</c>\n\nQSharedPointer\nTheQSharedPointer class holds a strong reference to a shared pointer. The QSharedPointer is an automatic, shared pointer in C++. It behaves exactly like a normal pointer for normal purposes, including respect  for constness.\nQSharedPointerwill delete the pointer it is holding when it goes out of scope, provided no other QSharedPointer objects are referencing it.\nAQSharedPointer object can be created from a normal pointer, another SharedPointer object or by promoting a QWeakPointer object to a strong reference.\n\nQWeakPointer\n- The QWeakPointer class holds a weak reference to a shared pointer. The QWeakPointer is an automatic weak reference to a pointer in C++.\n- It cannot be used to dereference the pointer directly, but it can be used to verify\nif the pointer has been deleted or not in another context.\nQWeakPointer objects can only be created by assignment from a QSharedPointer.\n<h>\n*Qtclass relationships\n- Association\n- Containment(Aggregation and Composition)\n- Parent/Child relationships\n- Inheritance\n- Polymorphism\n</h>\n- Association\nWhen a class keeps pointers to other class, class is said to be associated. QWidget keeps pointers to QObject its parent class then QWidget is associated to its parent.\n\n- Containment\nWhen one Qt class contains other as member property.\n\n-Aggregation\nOther class object is instantiated externally and its life cycle is not dependent upon container.\n\n-Composition\nOther class object is instantiated internally and its life cycle is dependent upon container. QWindow has QMenuBar, QMenu, QToolBar created internally.\n\n-Inheritance\nWhen a Qt class inherit other class. Parent class properties and methods becomes visible to derived class depends upon parent class access controls and derivation type (public, protected, private). Class public is visible to external world.\n\n- Polymorphism\nIts a type of inheritance where compile time method invocation on base class pointer can be replaced to method invocation on derived class objects. This is possible with non static methods declared with virtual keyword.\n<cb>\n<g>classB</g>{\n <l>public</l>:\n  virtualfunc(){cout<<"B::func"<<endl;}\n};\n<g>classD</g>:<g>class B</g> {\n <l>public</l>:\n  virtualfunc(){count<<"D::func"<<endl;}\n}\nvoiddraw(B* b){\n b->func();\n}\nB*b=new D;\ndraw(b);\n</cb>\n<h>\n*GarbageCollection\n</h>'
'4!ABS SBA!Event Management!ABS SBA!*Custom event\n*Event filtering\n*Signal & Slot, Signal Mapper!ABS SBA!<h>\n*Event flow and Handling\n- Event handling through callback and polymorphism\n- Event handling through message map\n</h>\nEvent Processing\n - Qt is an event driven UI toolkit\n - QApplication::exec() runs the event loop\n\n1. Generate Events\n - By input devices: keyboard, mouse, etc.\n - By Qt itself (e.g. timers)\n2 Queue Events\n - By event loop\n3 Dispatch Events\n - By QApplication to receiver: QObject\n - Key events sent to widget with focus\n - Mouse events sent to widget under cursor\n4 Handle Events\n - By QObject event handler methods\n\n<c>\n------------------        ------------       ---------------------------------\n|hardware signals| -----> | X Server | ----> | Application thread            |\n------------------        ------------       | Event queue with display open |\n                                             ---------------------------------\n                                                            |\n                                                            | exec()\n                                                            v\n                                              ------------------------------\n                                              | Window handling the event  |\n                                              ------------------------------\n                                                            |\n                                                            V\n                                                           ---\n                                  ---------    Yes      /       \\\n                                  |process|    <-----  /  Pass   \\\n                                  ---------            \\ through /\n                                                        \\event  /\n                                                         \\filter/\n                                                           ---\n                                                            | NO\n                                                            v\n                                                      ------------\n                                                      | reject   |\n                                                      ------------\n</c>\n\n- Event Handling through callback and polymorphism\n<c> QObject::event(QEvent *event)</c>\n - Handles all event for this object\n\nQt\'s Widget Model - QWidget\n<m>http://minhinc.42web.io/image/qt-slide-qwidgethierarchy.png</m>\n\nDerived from QObject\n - Adds visual representation\n\nBase of user interface objects\n - Receives events e.g. mouse, keyboard events\n\nPaints itself on screen\n - Using styles\n\n* Specialized event handlers\n<cs>\nQWidget::mousePressEvent(QMouseEvent*) for mouse click\nQWidget::keyPressEvent(QKeyEvent)* for key presses\nQWidget::actionEvent(QActionEvent * event)\nQWidget::changeEvent(QEvent * event)\nQWidget::closeEvent(QCloseEvent * event)\nQWidget::contextMenuEvent(QContextMenuEvent * event)\nQWidget::dragEnterEvent(QDragEnterEvent * event)\nQWidget::dragLeaveEvent(QDragLeaveEvent * event)\nQWidget::dragMoveEvent(QDragMoveEvent * event)\nQWidget::dropEvent(QDropEvent * event)\nQWidget::enterEvent(QEvent * event)\nQWidget::focusInEvent(QFocusEvent * event)\nQWidget::focusOutEvent(QFocusEvent * event)\nQWidget::hideEvent(QHideEvent * event)\nQWidget::inputMethodEvent(QInputMethodEvent * event)\nQWidget::keyReleaseEvent(QKeyEvent * event)\nQWidget::leaveEvent(QEvent * event)\nQWidget::mouseDoubleClickEvent(QMouseEvent * event)\nQWidget::mouseMoveEvent(QMouseEvent * event)\nQWidget::mouseReleaseEvent(QMouseEvent * event)\nQWidget::moveEvent(QMoveEvent * event)\nQWidget::paintEvent(QPaintEvent * event)\nQWidget::resizeEvent(QResizeEvent * event)\nQWidget::showEvent(QShowEvent * event)\nQWidget::tabletEvent(QTabletEvent * event)\nQWidget::wheelEvent(QWheelEvent * event)\n</cs>\n\nFor all events\n<c>virtual bool event(QEvent * event)</c>\n\nAccepting an Event\n<c> - event->accept() / event->ignore()</c>\n - Accepts or ignores the event\n - Accepted is the default.\n\nEvent propagation\n - Happens if event is ignored\n - Might be propagated to parent widget\n\nExample of Event Handling\n* QCloseEvent delivered to top level widgets (windows)\n* Accepting event allows window to close\n* Ignoring event keeps window open\n\n<cb>\nvoid <g>MyWidget</g>::closeEvent(QCloseEvent *event) {\n if (maybeSave()) {\n  writeSettings();\n  event->accept(); // close window\n } else {\n  event->ignore(); // keep window\n }\n}\n</cb>\n\n- Event handling through message map\nEvents and Signals\nSignals and slots are used instead of events:\n* To communicate between components.\n* In cases where there is a well-defined sender and receiver.\n* For example: a button and a slot to handle clicks.\n* For some events, there is no sender in Qt.\n* For example: redraw, keyboard and mouse events.\n* To describe high level logic and control flow. Developers can create custom events if they need to.\n\n<m>http://minhinc.42web.io/image/qt-slide-signalslot.png</m>\n\nVariations of Signal&Slot Connections\n<c>\nSignal(s)                      Slot(s)\none                            many\nMany                           one\none                            another signal\n</c>\n\nSignal to Signal connection\n<c>connect(bt, SIGNAL(clicked()), this, SIGNAL(oksignal()));</c>\n\nMaking the Connection\nRule for Signal & Slot Connection\nCan ignore arguments, but not create values from nothing\n<c>\nSignal                                          Slot\nrangeChanged(int,int)                           setValue(int)\n                                                setRange(int,int)\n                                                updateUi()\n\nvalueChanged(int)                               setValue(int)\n                                                UpdateUi()\n                                x               setRange(int,int)\n                                x               setValue(float)\n\ntextChanged(QString)            x               setValue(int)\n\nClicked()                                       updateUi()\n                                x               setValue(int)\n</c>\n\n<h>\n*Synthetic and hardware events\n- Custom events\n- Sending and receiving custom events\n- Posting events\n</h>\n\n<m>https://www.youtube.com/embed/GVKHXRWX4Lk</m>\n\nEvents have mainly two types\na) User interface, ex, Keyboard, Mouse, Timer etc.. Processed through call backs, ex. paintEvent, processEvent etc.\nb) Synthetic events\n\nSynthetic Events\n* When calling postEvent(), the event must be allocated using new, and must not be deallocated (Qt takes ownership).\n* When calling sendEvent(), you must take care of deleting the instance afterwards (or allocate it on the stack).\n\n* You can create your own events by inheriting QEvent, and using an integer between QEvent::User (1000) and QEvent::MaxUser (65535).\n* The integer to use is best generated using the static method int QEvent::registerEventType(int hint = -1)\n* Naturally, Qt does not understand user events. You must therefore handle user events in inherited classes implementing QObject::customEvent() to deal with your custom events.\n* Alternatively, event filters can be used.\n\nDelayed Invocation\n* Sometimes, it is desirable to have some code invoked when the application is idle.\n* One way to do this is to post custom QEvent and put your code in the QObject::customEvent() handler of the receiving object.\n* Another way that is often easier and works when the code you want to invoke is available as a slot,\n\n<c>\nQMetaObject::invokeMethod() with the connection type\nQueuedConnection can be used instead:\nQMetaObject::invokeMethod(myobject, "doDelayedStuff", Qt::QueuedConnection);\n</c>\n\nInvokes doDelayedStuff() subroutine\n\nDelayed Invocation\n* A typical use of this is to make a delayed call from a constructor.\n* This can be used to emit signals after the object has been created and connected.\n* Another use is idle processing.\n\nPingPong\n<cs>\n<c><*.pro></c>\nQT+=core TEMPLATE = app TARGET = pingpong SOURCES += pingpong.cpp\n<c><main.cpp></c>\n#include <QtCore>\n#include <QDebug>\nclass PingEvent : public QEvent {\npublic:\nPingEvent() : QEvent(QEvent::Type(QEvent::User)){}\n};\nclass PongEvent : public QEvent{\npublic:\nPongEvent() : QEvent(QEvent::Type(QEvent::User+1)){}\n};\nclass Pinger : public QState{\npublic:\nPinger(QState *parent=0):QState(parent) {}\nprotected:\nvirtual void onEntry(QEvent *){\nqDebug()<<"Pinger::onEntry";\nmachine()->postDelayedEvent(new PingEvent(),30000);\n}\n};\nclass Ponger : public QState{\npublic:\nPonger(QState *parent=0):QState(parent) {}\nprotected:\nvirtual void onEntry(QEvent *){\nqDebug()<<"Ponger::onEntry";\nmachine()->postDelayedEvent(new PongEvent(),30000);\n}\n};\nclass PingTransition : public QAbstractTransition {\npublic:\nPingTransition() {}\nprotected:\nvirtual bool eventTest(QEvent *e) {\nqDebug()<<"PingTranstion::eventTest eventType :"<<e->type();\nreturn (e->type() == QEvent::User);\n}\nvirtual void onTransition(QEvent *) {\nqDebug()<<"PingTransition::onTransition";\n}\n};\nclass PongTransition : public QAbstractTransition{\npublic:\nPongTransition() {}\nprotected:\nvirtual bool eventTest(QEvent *e) {\nqDebug()<<"PingTranstion::eventTest eventType :"<<e->type();\nreturn (e->type() == QEvent::User+1);\n}\nvirtual void onTransition(QEvent *){\nqDebug()<<"PongTransition::onTransition";\n}\n};\nint main(int argc, char **argv)\n{\nQCoreApplication app(argc, argv);\nQStateMachine machine;\nPinger *pinger = new Pinger();\npinger->setObjectName("pinger");\nPonger *ponger = new Ponger();\nponger->setObjectName("ponger");\nQAbstractTransition *pingertranstion=new PingTransition();\npingertranstion->setTargetState(ponger);\npinger->addTransition(pingertranstion);\n\nQAbstractTransition *pongertransition=new PongTransition();\npongertransition->setTargetState(pinger);\nponger->addTransition(pongertransition);\n\nmachine.addState(pinger);\nmachine.addState(ponger);\nmachine.setInitialState(pinger);\nmachine.start();\nreturn app.exec();\n}\n</cs>\nOUTPUT\n<cs>\n./pingpong\nPinger::onEntry\nPingTranstion::eventTest eventType : QEvent::Type(None)\nPingTranstion::eventTest eventType : QEvent::Type(None)\nPingTranstion::eventTest eventType : QEvent::Type(User)\nPingTransition::onTransition\nPonger::onEntry\nPingTranstion::eventTest eventType : QEvent::Type(None)\nPingTranstion::eventTest eventType : QEvent::Type(None)\nPingTranstion::eventTest eventType : QEvent::Type(1001)\nPongTransition::onTransition\nPinger::onEntry\nPingTranstion::eventTest eventType : QEvent::Type(None)\nPingTranstion::eventTest eventType : QEvent::Type(None)\nPingTranstion::eventTest eventType : QEvent::Type(User)\nPingTransition::onTransition\nPonger::onEntry\nPingTranstion::eventTest eventType : QEvent::Type(None)\n^C\n</cs>\n\n<h>\n*Event loops\n- QCoreApplication\n- QEventDispatcher\n- exec()\n</h>\n*QEventLoop - The QEventLoop class provides a means of entering and leaving an event loop.\n*At any time, you can create a QEventLoop object and call exec() on it to start a local event loop. From within the event loop, calling exit() will force exec() to return.\n*QEventDispatcher - The QAbstractEventDispatcher class provides an interface to manage Qt\'s event queue.\n*An event dispatcher receives events from the window system and other sources. It then sends them to the QCoreApplication or QApplication instance for processing and delivery. QAbstractEventDispatcher provides fine-grained control over event delivery.\n\n<c>\n          |                |                                     QWidgets\n          |                |                                   -------------\n          |                |                        hardware   |::event() |\n          |                |                        events +-->|::mousePressEvent()|\n          |                |                               |   | .....             |\n|event    |                |                               |   ---------------------\n|arrival / \\   checks for / \\   send out                   |\n|       /   \\   priority /   \\  event to  ------------     |\n|      /event\\ -------> /event\\ --------> |checks for|     |\n--->   \\queue/          \\queue/ target    |installed |-----+\n        \\   /            \\   /  window    |filters   |  syn|ev   QObject\n         \\ /              \\ /             ------------  the|ents-----------------\n          |                |                            tic|--->|::customEvent()|\n          |                |                               |    -----------------\n          |                |                               |\n          |                |                           sign|     QObject\n          |                |                           als |     ----------\n                                                           |---->| slots  |\n                                                                 ----------\n</c>\n\n<h>\n*Event filters\n- Registering event filter\n- Installing event filter\n</h>\n<m>https://www.youtube.com/embed/uAaxbROmymI</m>\n\nEvent Filters\n - The usual way to do this is to subclass each widget and implement the event.\n - The alternative is to install an event filter for each instance.\n\nEvent Filters\n* Subclass from QObject (or any subclass of QObject), and reimplement the method:\n<c>\nbool QObject::eventFilter(QObject* receiver, QEvent* event);\n                 --------------\n                 |  Qobject   | virutal eventfilter(QObject *receiver, Qevent *e)\n                 --------------\n                       / \\\n                        -\n                        |\n               ---------------------\n               | EventFilterObject|virutal eventfilter(QObject *receiver, Qevent *e)\n               ---------------------\n</c>\n<d2> The first parameter is the object for whom the event was intended, and the second argument is the event itself.\n<d2> If this method returns true, then the event is considered "handled", otherwise it will be sent on to the next event filter, or the object itself, if no more event filters are installed.\n<d2> Install the event filter for an object by invoking the method installEventFilter(). As the argument, pass an instance of the class you have created in the previous step.\n\n<d>Event Filters\n <d2> Installing an event filter on the QApplication instance will install a global event filter.\n <d2> Event filters can be removed again by using the method\n<c>\nremoveEventFilter(const QObject*)\n</c>\n* When multiple event filters are installed, the order they are called in is the reverse of the order in which they are installed, i.e., the most recent installed filter is the first one invoked.\n\n<cs>\n<c><*.pro></c>\nQT += core\n\n<c><entity.h></c>\n#ifndef ENTITY_H\n#define ENTITY_H\n#include <QEvent>\n#include <QDebug>\nclass entity2;\nclass event1:public QEvent {\npublic:\nevent1():QEvent(QEvent::Type(QEvent::User)){}\n};\nclass event2:public QEvent {\npublic:\nevent2():QEvent(QEvent::Type(QEvent::User+1)){}\n};\nclass entity1:public QObject {\nQ_OBJECT\npublic:\nentity1(QObject *p=0);\nprotected:\nvoid customEvent(QEvent *);\npublic:\nvoid start();\nvoid setpartner(entity2*);\nprivate:\nentity2 *ent;\n};\nclass entity2:public QObject {\nQ_OBJECT\npublic:\nentity2(QObject *p=0);\nvoid setpartner(entity1* e);\nprotected:\nvoid customEvent(QEvent *);\nprivate:\nentity1 *ent;\n};\nclass event1filter:public QObject {\nQ_OBJECT\nprotected:\nbool eventFilter(QObject *obj, QEvent *event);\n};\nclass event2filter:public QObject {\nQ_OBJECT\nprotected:\nbool eventFilter(QObject *obj, QEvent *event);\n};\n#endif\n<c><entity.cpp></c>\n#include <QCoreApplication>\n#include "entity.h"\nentity1::entity1(QObject *p):QObject(p) {\n}\nvoid entity1::start() {\nqDebug()<<"entity1::start()";\nQCoreApplication::instance()->postEvent(ent, new event1());\n}\nvoid entity1::customEvent(QEvent *e) {\nqDebug()<<"entity1::customevent(), received event type->"<<e->type();\nQCoreApplication::instance()->postEvent(ent, new event1());\nQCoreApplication::instance()->postEvent(ent, new event2());\n}\nvoid entity1::setpartner(entity2 *part) {\nent=part;\n}\nentity2::entity2(QObject *p):QObject(p) {}\nvoid entity2::customEvent(QEvent *e) {\nqDebug()<<"entity2::customevent, received custom event id"<<e->type();\nQCoreApplication::instance()->postEvent(ent, new event1());\nQCoreApplication::instance()->postEvent(ent, new event2());\n}\nvoid entity2::setpartner(entity1 *part) {\nent=part;\n}\nbool event1filter::eventFilter(QObject *obj, QEvent *event) {\nif(event->type() == QEvent::User)\nreturn true;\nelse\nreturn QObject::eventFilter(obj,event);\n}\nbool event2filter::eventFilter(QObject *obj, QEvent *event) {\nif(event->type() == QEvent::User+1)\nreturn true;\nelse\nreturn QObject::eventFilter(obj, event);\n}\n<c><main.cpp></c>\n#include <QCoreApplication>\n#include "entity.h"\nint main(int argc, char *argv[]) {\nQCoreApplication a(argc,argv);\nint r;\nentity1 *ent1=new entity1;\nentity2 *ent2=new entity2;\nevent1filter *ent1filter=new event1filter;\nevent2filter *ent2filter=new event2filter;\nent1->setpartner(ent2);\nent2->setpartner(ent1);\nent1->installEventFilter(ent1filter);\nent2->installEventFilter(ent2filter);\nent1->start();\nr=a.exec();\nreturn r;\n}\n</cs>\nOUTPUT\n<cs>\n./entity12\nentity1::start()\nentity2::customevent, received custom event id QEvent::Type(User)\nentity1::customevent(), received event type-> QEvent::Type(1001)\nentity2::customevent, received custom event id QEvent::Type(User)\nentity1::customevent(), received event type-> QEvent::Type(1001)\nentity2::customevent, received custom event id QEvent::Type(User)\nentity1::customevent(), received event type-> QEvent::Type(1001)\nentity2::customevent, received custom event id QEvent::Type(User)\nentity1::customevent(), received event type-> QEvent::Type(1001)\nentity2::customevent, received custom event id QEvent::Type(User)\nentity1::customevent(), received event type-> QEvent::Type(1001)\nentity2::customevent, received custom event id QEvent::Type(User)\nentity1::customevent(), received event type-> QEvent::Type(1001)\nentity2::customevent, received custom event id QEvent::Type(User)\nentity1::customevent(), received event type-> QEvent::Type(1001)\nentity2::customevent, received custom event id QEvent::Type(User)\nentity1::customevent(), received event type-> QEvent::Type(1001)\nentity2::customevent, received custom event id QEvent::Type(User)\nentity1::customevent(), received event type-> QEvent::Type(1001)\nentity2::customevent, received custom event id QEvent::Type(User)\n</cs>\n\n<h>\n*Timer event\n</h>\nThere are mainly two types of timers.\nQTimer  based\n Single Shot\n Periodic\nEvent based\n QObject::startTimer()\ncallback\n QOjbect::timerEvent()\n\nsignal-slottimer\n<c>\nQTimer *timer = new QTimer(this);\nconnect(timer, SIGNAL(timeout()), this, SLOT(update()));\ntimer->start(1000);\n\nQTimer::singleShot(200, this, SLOT(updateCaption()));\n\n<<eventtimer.cpp>>\nclass MyObject : public QObject{\nQ_OBJECT\npublic:\nMyObject(QObject *parent = 0);\nprotected:\nvoid timerEvent(QTimerEvent *event);\n};\n\nMyObject::MyObject(QObject *parent):QObject(parent){\nstartTimer(50);     // 50-millisecond timer\nstartTimer(1000);   // 1-second timer\nstartTimer(60000);  // 1-minute timer\n}\nvoid MyObject::timerEvent(QTimerEvent *event){\n    qDebug() << "Timer ID:" << event->timerId();\n}\n</c>\n\n<h>\n*Signal & Slots communication & delivery\n</h>\nSignals & Slots\n - Object Communication\n - Signal - emitted to notify other objects\n - Slot - method called in response to signal\n - Provides type-safe callbacks\n - After getting used to it, they are\n - easier to use than message maps,\n - more secure than callbacks,\n - more flexible than virtual methods\n - Fosters component-based programming\n<cb>\n<g>QMetaObject</g>::Connection QObject::connect(const QObject * sender, const char * signal, const QObject * receiver, const char * method, Qt::ConnectionType type = Qt::AutoConnection) [static]\nQObject::disconnect(...);\n</cb>\n\n<cs>\n<c><*.pro></c>\nQT += widgets\n\n<c><lwidget.h></c>\n#include <QWidget>\n#include <QPushButton>\n#include <QLabel>\n#include <QColorDialog>\n#include <QColor>\n\nclass lwidget:public QWidget {\nQ_OBJECT;\npublic:\nlwidget(QWidget* parent=0);\nprivate slots:\nvoid on_buttonclicked();\nvoid on_colorselected(QColor);\nprivate:\nQPushButton button;\nQLabel label1;\nQLabel label2;\nQColorDialog colord;\n};\n\n<c><lwidget.cpp></c>\n#include "lwidget.h"\nlwidget::lwidget(QWidget* parent):QWidget(parent), button("Select Color", this), label1("color is :", this),label2("", this) {\nlabel1.setGeometry(40,40,70,15);\nlabel2.setGeometry(140,40,100,15);\nbutton.setGeometry(40,100,100,35);\nconnect(&button,SIGNAL(clicked()),this,SLOT(on_buttonclicked()));\n}\nvoid lwidget::on_buttonclicked() {\ncolord.open(this,SLOT(on_colorselected(QColor)));\n}\nvoid lwidget::on_colorselected(QColor color) {\nlabel2.setText(color.name());\n}\n\n<c><sigslot.cpp></c>\n#include <QApplication>\n#include "lwidget.h"\nint main(int argc, char *argv[]) {\nQApplication a(argc,argv);\nlwidget container;\ncontainer.show();\nreturn a.exec();\n}\n</cs>\nOUTPUT\n<m>http://minhinc.42web.io/image/qt-slide-signalslotcd.png</m>\n\n<h>\n*Data passing and Signal mapper\n</h>\n\n* The QSignalMapper class bundles signals from identifiable senders.\n* This class collects a set of parameterless signals, and re-emits them with integer, string or widget parameters corresponding to the object  that sent the signal.\n* The class supports the mapping of particular strings or integers with  particular objects using setMapping(). The objects\' signals can then be connected to the map() slot which will emit the mapped() signal with the string or integer associated with the original signalling object. Mappings can be removed later using removeMappings().\n<c>\nsignalMapper = new QSignalMapper(this);\nsignalMapper->setMapping(taxFileButton, QString("taxfile.txt"));\nsignalMapper->setMapping(accountFileButton, QString("accountsfile.txt"));\nsignalMapper->setMapping(reportFileButton, QString("reportfile.txt"));\n\nconnect(taxFileButton, &QPushButton::clicked, signalMapper, &QSignalMapper::map);\nconnect(accountFileButton, &QPushButton::clicked, signalMapper, &QSignalMapper::map);\nconnect(reportFileButton, &QPushButton::clicked, signalMapper, &QSignalMapper::map);\n</c>\nConnect the mapped() signal to readFile() where a different file will be opened, depending on which push button is pressed.\n<c>\nconnect(signalMapper, SIGNAL(mapped(QString)), this, SLOT(readFile(QString)));\nsignalmapper\nclass ButtonWidget : public QWidget\n{\nQ_OBJECT\npublic:\nButtonWidget(QStringList texts, QWidget *parent = 0);\nsignals:\nvoid clicked(const QString &text);\nprivate:\nQSignalMapper *signalMapper;\n};\nButtonWidget::ButtonWidget(QStringList texts, QWidget *parent) : QWidget(parent){\nsignalMapper = new QSignalMapper(this);\nQGridLayout *gridLayout = new QGridLayout;\nfor (int i = 0; i < texts.size(); ++i) {\nQPushButton *button = new QPushButton(texts[i]);\nconnect(button, SIGNAL(clicked()), signalMapper, SLOT(map()));\nsignalMapper->setMapping(button, texts[i]); gridLayout->addWidget(button, i / 3, i % 3);\n}\nconnect(signalMapper, SIGNAL(mapped(QString)), this, SIGNAL(clicked(QString)));\nsetLayout(gridLayout);\n}\n</c>'
'5!ABS SBA!Widgets!ABS SBA!*QMainWindow QMenu, QMenuBar, QToolBar,\nQStatusBar\n*Parent and Child Window!ABS SBA!<h>\n*Introduction to Widgets\n</h>\n\n<m>https://www.youtube.com/embed/FaOlt-M1UL0</m>\n\n<m>http://minhinc.42web.io/image/qt-slide-qwidgethierarchy.png</m>\n\n* Derived from QObject\n - Adds visual representation\n* Base of user interface objects\n* Receives events\n - e.g. mouse, keyboard events\n* Paints itself on screen\n - Using styles\n\nObject Tree and QWidget\nnew QWidget(0)\n - Widget with no parent is window\nQWidgets children\n - Displayed in parent coordinate system\n - Clipped by parents boundaries\nQWidget parent\n - Propagates state changes\n - hides/shows them when it is hidden/shown itself\n - enables/disables them when it is enabled/disabled itself\nTristate mechanism\n - For hide/show and enable/disable, ensures that e.g. an explicitly hidden child is not shown when the parent is shown.\n\nWidgets that contain other widgets\n* Container Widgets\n* Aggregates other child-widgets\n* Use layouts for aggregation\n* In this example: QHBoxLayout and\nQVBoxLayout\n* Note: Layouts are not widgets\n* Layout Process\n* Add widgets to layout\n* Layouts may be nested\n* Set layout on container widget\n\n<h>\n*Writing custom widget\n</h>\n\n* Drivation\n * Drive from QWidget or children\n * Override QPaintEvent\n<m>https://www.youtube.com/embed/-HaMWJVYAzE</m>\n<c>\n-----------\n| QWidget |\n---------------------\n|virtual QPaintEvent|\n---------------------\n        / \\\n         -\n         |\n---------------\n|customwidget|\n---------------\n|QpaintEvent()|\n----------------\n</c>\n\n* Containment\n * QWidget object contains other QWidgets\n<m>https://www.youtube.com/embed/lIQSvW_aD2g</m>\n<c>\n-----------               *  ---------\n| QWidget |<>--------------->|QWidget|\n---------------------        ---------\n|virtual QPaintEvent|\n---------------------\n</c>\n\n<h>\n*QPainter and capabilites\n- Drawing curves\n- Drawing Pixmap\n- Drawing Fonts\n</h>\n\n<m>https://www.youtube.com/embed/W8Q39V3RBhw</m>\n\nThe QPainter class performs low-level painting on widgets and other paint devices.\nQPainter provides highly optimized functions to do most of the drawing GUI\nprograms require. It has three drawing capabilities.\na) Pen\nb) Brush\nc) Font\n\nQPainter can operate on any object that inherits the QPaintDevice class.\nQPainter generaly operates on virtual function paintEvent(...)  update() funciton in\nQWidget calls repainting, calling paintEvent()\n\nPixmap being QPaintDevice, QPainter works on that.\n\n<h>\n*Event Processing and Paint Engine\n</h>\n\n<m>http://minhinc.42web.io/image/qt-slide-paintengine.png</m>\nThe QPaintEngine class provides an abstract definition of how QPainter draws to a given device on a given platform.\nQPaintEngine is created and owned by the QPaintDevice that created it.\nQPainter provides abstract function for drawing to the user, internally it uses specific QPaintEngine, tied to a target PaintDevice, algorithms.\n<cb>\nenum QPaintEngine::Type\nConstant                     Value           Description\n<g>QPaintEngine</g>::X11             0\n<g>QPaintEngine</g>::Windows         1\n<g>QPaintEngine</g>::MacPrinter      4\n<g>QPaintEngine</g>::CoreGraphics    3    Mac OS X\'s Quartz2D (CoreGraphics)\n<g>QPaintEngine</g>::QuickDraw       2    Mac OS X\'s QuickDraw\n<g>QPaintEngine</g>::QWindowSystem   5    Qt for Embedded Linux\n<g>QPaintEngine</g>::PostScript      6    (No longer supported)\n<g>QPaintEngine</g>::OpenGL          7\n<g>QPaintEngine</g>::Picture         8    QPicture format\n<g>QPaintEngine</g>::SVG             9   Scalable Vector Graphics XML format\n<g>QPaintEngine</g>::Raster          10\n<g>QPaintEngine</g>::Direct3D        11  Windows only, Direct3D based engine\n<g>QPaintEngine</g>::Pdf             12  Portable Document Format\n<g>QPaintEngine</g>::OpenVG          13\n<g>QPaintEngine</g>::User            50  First user type ID\n<g>QPaintEngine</g>::MaxUser         100 Last user type ID\n<g>QPaintEngine</g>::OpenGL2         14\n<g>QPaintEngine</g>::PaintBuffer     15\n<g>QPaintEngine</g>::Blitter         16\n</cb>\n\nGUI events are placed to eventQueue and finally processed by paintEvent Functions.\n<cs>\nQT += core\n\n<c><main.cpp></c>\n#include <QApplication>\n#include "widget.h"\n\nint main(int argc, char *argv[]) {\nQApplication a(argc, argv);\nint r;\nwidget *w=new widget;\nw->show();\nr=a.exec();\nreturn r;\n}\n\n<c><widget.h></c>\n#include <QPainter>\n#include <QPaintEvent>\n#include <QRadialGradient>\n#include <QTimer>\n#include <QTransform>\n#include "widget.h"\nwidget::widget(QWidget *parent):QWidget(parent){\nQTimer *sunroundtimer=new QTimer(this);\nconnect(sunroundtimer,SIGNAL(timeout()),this,SLOT(sunround()));\nsunroundangle=0;\nearthownaxisangle=0;\nearthroundangle=0;\nsunroundmarsangle=0;\nmarsround1angle=0;\nmarsround2angle=0;\nupdate();\nsunroundtimer->start(500);\n}\nvoid widget::paintEvent(QPaintEvent *pe) {\nint side=qMin(width(),height());\nQWidget::paintEvent(pe);\nQPainter *p=new QPainter(this);\np->setViewport((width()-side)/2,(height()-side)/2,side,side);\np->setWindow(-50,-50,100,100);\n\nQTransform transformearth;\nQTransform transformmoon;\ntransformearth.rotate(sunroundangle);\ntransformearth.translate(30,0);\ntransformmoon.rotate(earthroundangle);\ntransformmoon.translate(7.5,0);\nQRadialGradient rg(0,0,SUN,0,0);\nrg.setColorAt(0.0,Qt::white);\nrg.setColorAt(0.5,Qt::yellow);\nrg.setColorAt(1,Qt::red);\np->setPen(Qt::NoPen);\np->setBrush(rg);\np->drawEllipse(-SUN,-SUN,SUN*2,SUN*2);\np->save();\n\nQRadialGradient erg(0,0,EARTH,-EARTH+1,0);\nerg.setColorAt(0.0,Qt::white);\nerg.setColorAt(0.7,Qt::blue);\nerg.setColorAt(1.0,Qt::black);\np->setPen(Qt::NoPen);\np->setBrush(erg);\n//p->rotate(sunroundangle);\n//p->translate(+30,0);\np->setWorldTransform(transformearth,true);\np->save();\np->rotate(earthownaxisangle);\np->drawEllipse(-EARTH,-EARTH,EARTH*2,EARTH*2);\np->restore();\np->setBrush(Qt::black);\n//p->rotate(earthroundangle);\n//p->translate(7.5,0);\np->setWorldTransform(transformmoon,true);\np->drawEllipse(-MOON,-MOON,MOON*2,MOON*2);\np->restore();\n\n\np->save();\nQRadialGradient mrg(0,0,MARS,-MARS+1,0);\nmrg.setColorAt(0.0,Qt::white);\nmrg.setColorAt(1,Qt::red);\np->setPen(Qt::NoPen);\np->setBrush(mrg);\np->rotate(sunroundmarsangle);\np->translate(+40,-40);\np->drawEllipse(-MARS,-MARS,MARS*2,MARS*2);\n\np->save();\np->setBrush(Qt::green);\np->rotate(marsround1angle);\np->translate(4.5,0);\np->drawEllipse(-MARSMOON1,-MARSMOON1,MARSMOON1*2,MARSMOON1*2);\np->restore();\n\np->save();\np->setBrush(Qt::blue);\np->rotate(marsround2angle);\np->translate(5.5,0);\np->drawEllipse(-MARSMOON2,-MARSMOON2,MARSMOON2*2,MARSMOON2*2);\np->restore();\np->restore();\n}\n\nvoid widget::sunround() {\nif((sunroundangle+=1)==360) sunroundangle=0;\nif((earthownaxisangle+=90)==360) earthownaxisangle=0;\nif((earthroundangle+=18)==360) earthroundangle=0;\nif((sunroundmarsangle+=0.5)==360) sunroundmarsangle=0;\nif((marsround1angle+=18)==360) marsround1angle=0;\nif((marsround2angle+=36)==360) marsround2angle=0;\nupdate();\n}\n\n<c><widget.h></c>\n#ifndef WIDGET_H\n#define WIDGET_H\nclass QPainter;\nclass QPaintEvent;\nclass QTimer;\n#include <QWidget>\nclass widget: public QWidget {\nQ_OBJECT\npublic:\nwidget(QWidget *parent=0);\nprotected:\nvoid paintEvent(QPaintEvent *);\nprivate slots:\nvoid sunround();\nprivate:\nQTimer *sunroundtimer;\nQTimer *earthownaxistimer;\nQTimer *earthroundtimer;\nfloat sunroundangle;\nfloat earthownaxisangle;\nfloat earthroundangle;\nfloat sunroundmarsangle;\nfloat marsround1angle;\nfloat marsround2angle;\nQPainter *p;\nstatic const float SUN=8.0;\nstatic const float EARTH=5.0;\nstatic const float MARS=3.0;\nstatic const float MOON=1.5;\nstatic const float MARSMOON1=1;\nstatic const float MARSMOON2=1.5;\n};\n#endif\n</cs>\nOUTPUT\n<m>http://minhinc.42web.io/image/qt-slide-widget_solar.png</m>\n\n<h>\n*MainWindow Widget\n</h>\n\n<m>http://minhinc.42web.io/image/qt-slide-qmainwindow.png</m>\n\n<cb>\n                   <g>Qwidget</g>\n                     / \\\n                      -\n                      |\n                 <g>QMainWindow</g>\n</cb>\n-It provides a framework for building an application\'s user interface.\n-It has its own layout to which QToolBars, QDockWidgets, QMenuBar and QStatusBar\ncan be added.\n-It\'s layout has a center area that can be occupied by any kind of widget,i.e QTextEdit or QGraphicsView\n\n<c>\nQMainWindow::setCentralWidget( widget )\n</c>\n\n<c>\n* QAction: menu items added to QMenu\nvoid MainWindow::setupMenuBar() {\nQMenuBar* bar = menuBar();\nQMenu* menu = bar->addMenu(tr("&File"));\nmenu->addAction(action);\nmenu->addSeparator();\nmenu->addMenu("Sub Menu");\n  ...\n\nQMainWindow::addToolbar( toolbar )\n</c>\n\n* Adds toolbar to main window\n* QMainWindow::addToolBarBreak()\n\n* Adds section splitter\n* QToolBar::addAction( action )\n\n* Adds action to toolbar\n* QToolBar::addWidget(widget)\n\n* Adds widget to toolbar\n<cb>\nvoid <g>MainWindow</g>::setupToolBar() {\n<g>QToolBar</g>* bar = addToolBar(tr("File"));\nbar->addAction(action);\nbar->addSeparator();\nbar->addWidget(new QLineEdit("Find ..."));\n...\n\nQToolButton: Quick-access button to commands or options\nQToolButton* button = new QToolButton(this);\nbutton->setAction(action);\n// Can have a menu\nbutton->setMenu(menu);\n// Shows menu indicator on button\nbutton->setPopupMode(QToolButton::MenuButtonPopup);\n// Control over text + icon placements\nbutton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);\n...\n\nvoid <g>MainWindow</g>::createStatusBar() {\nQStatusBar* bar = statusBar();\nbar->showMessage(tr(<r>"Ready"</r>));\nbar->addWidget(new QLabel(<r>"Label on StatusBar"</r>));\n...\n\n<g>QmainWindow</g>::setDockOptions(options)\n</cb>\n\nSpecifies docking behavior (animated, nested, tabbed, ...)\n<cb>\nvoid MainWindow::createDockWidget() {\nQDockWidget *dock = new QDockWidget(tr("Title"), this);\ndock->setAllowedAreas(Qt::LeftDockWidgetArea);\nQListWidget *widget = new QListWidget(dock);\ndock->setWidget(widget);\naddDockWidget(Qt::LeftDockWidgetArea, dock);\n  ...\n</cb>\n\n<b>MDIAREA EXAMPLE</b>\n<cs>\n<c><*.pro></c>\nQT+=widgets\n<c><widget.h></c>\n#ifndef WIDGET_H\n#define WIDGET_H\n#include <QWidget>\n#include <QPainter>\n#include <QString>\nclass QPaintEvent;\n\nclass widget:public QWidget {\nQ_OBJECT\npublic:\nwidget(QWidget *p=0,const QString& textp=""):QWidget(p),text(textp){}\nvoid settext(const QString tp) {\ntext=tp;\n}\nprivate:\nQString text;\nprotected:\nvoid paintEvent(QPaintEvent *e) {\nQWidget::paintEvent(e);\nQPainter p(this);\np.drawText(rect().width()/2,rect().height()/2,text);\n}\n};\n#endif\n<c><mainwindow.h></c>\n#ifndef MAINWINDOW_H\n#define MAINWINDOW_H\n#include <QMainWindow>\nclass QMdiArea;\nclass QListWidget;\n\nclass mainwindow:public QMainWindow {\nQ_OBJECT\npublic:\nmainwindow(QMainWindow *p=0);\nprivate slots:\nvoid itemclck();\nprivate:\nQMdiArea *ma;\nQListWidget *lw;\n};\n#endif\n<c><mainwindow.c></c>\n#include <QWidget>\n#include <QListWidget>\n#include <QDockWidget>\n#include <QMdiArea>\n#include <QDebug>\n#include "mainwindow.h"\n#include "widget.h"\n\nmainwindow::mainwindow(QMainWindow *p):QMainWindow(p){\nma=new QMdiArea;\nlw=new QListWidget(this);\nQDockWidget *dw=new QDockWidget;\ndw->setAllowedAreas(Qt::LeftDockWidgetArea|Qt::RightDockWidgetArea);\ndw->setWidget(lw);\naddDockWidget(Qt::LeftDockWidgetArea,dw);\n\nlw->addItem(new QListWidgetItem(tr("one")));\nlw->addItem(new QListWidgetItem(tr("two")));\nlw->addItem(new QListWidgetItem(tr("three")));\n\nma->addSubWindow(new widget(ma,"first"));\nma->addSubWindow(new widget(ma,"second"));\nma->addSubWindow(new widget(ma,"third"));\n\nma->tileSubWindows();\n//ma->cascadeSubWindows();\nsetCentralWidget(ma);\nsetFixedSize(width(),height());\nconnect(lw,SIGNAL(itemClicked(QListWidgetItem*)),this,SLOT(itemclck()));\n}\nvoid mainwindow::itemclck() {\nqDebug()<<lw->currentRow();\nma->setActiveSubWindow(ma->subWindowList().at(lw->currentRow()));\n}\n<c><main.cpp></c>\n#include <QApplication>\n#include "mainwindow.h"\n\nint main(int argc, char *argv[]) {\nQApplication a(argc, argv);\nmainwindow m;\nm.show();\nreturn a.exec();\n}\n</cs>\nOUTPUT\n<m>http://minhinc.42web.io/image/qt-slide-qmainwindow_mdi.png</m>\n\n<b>STACKED EXAMPLE</b>\n<cs>\n<c><*.pro></c>\nQT += widgets\n\n<main.cpp>\n#include <QApplication>\n#include "mainwindow.h"\n\nint main(int argc, char *argv[]) {\nQApplication a(argc, argv);\nmainwindow m;\nm.show();\nreturn a.exec();\n}\n\n<c><mainwindow.cpp></c>\n#include <QWidget>\n#include <QListWidget>\n#include <QDockWidget>\n#include <QStackedLayout>\n#include <QDebug>\n#include "mainwindow.h"\n#include "widget.h"\n\nmainwindow::mainwindow(QMainWindow *p):QMainWindow(p){\nQDockWidget *dw=new QDockWidget;\nlw=new QListWidget(dw);\ndw->setAllowedAreas(Qt::LeftDockWidgetArea|Qt::RightDockWidgetArea);\ndw->setWidget(lw);\naddDockWidget(Qt::LeftDockWidgetArea,dw);\n\nlw->addItem(new QListWidgetItem(tr("one")));\nlw->addItem(new QListWidgetItem(tr("two")));\nlw->addItem(new QListWidgetItem(tr("three")));\n\nsl= new QStackedLayout;\nsl->addWidget(new widget(this,"first"));\nsl->addWidget(new widget(this,"second"));\nsl->addWidget(new widget(this,"third"));\n\nQWidget *w=new QWidget;\nw->setLayout(sl);\nsetCentralWidget(w);\nconnect(lw,SIGNAL(itemClicked(QListWidgetItem*)),this,SLOT(itemclck()));\n}\nvoid mainwindow::itemclck() {\nqDebug()<<lw->currentRow();\nsl->setCurrentIndex(lw->currentRow());\n}\n\n<c><mainwindow.h></c>\n#ifndef MAINWINDOW_H\n#define MAINWINDOW_H\n#include <QMainWindow>\nclass QListWidget;\nclass QStackedLayout;\n\nclass mainwindow:public QMainWindow {\nQ_OBJECT\npublic:\nmainwindow(QMainWindow *p=0);\nprivate slots:\nvoid itemclck();\nprivate:\nQListWidget *lw;\nQStackedLayout *sl;\n};\n#endif\n<c><widget.h></c>\n#ifndef WIDGET_H\n#define WIDGET_H\n#include <QWidget>\n#include <QPainter>\n#include <QString>\nclass QPaintEvent;\nclass widget:public QWidget {\nQ_OBJECT\npublic:\nwidget(QWidget *p=0,const QString& textp=""):QWidget(p),text(textp){}\nprivate:\nQString text;\nprotected:\nvoid paintEvent(QPaintEvent *e) {\nQWidget::paintEvent(e);\nQPainter p(this);\np.drawText(rect().width()/2,rect().height()/2,text);\n}\n};\n#endif\n</cs>\nOUTPUT\n<m>http://minhinc.42web.io/image/qt-slide-qmainwindow_stacklyt.png</m>\n\n<h>\n*Dialog widget\n</h>\n\nThe QDialog class is the base class of dialog windows.\n\nA dialog window is a top-level window mostly used for short-term tasks and brief\ncommunications with the user. QDialogs may be modal or modeless. QDialogs can\nprovide a return value, and they can have default buttons. QDialogs can also have a\nQSizeGrip in their lower-right corner, using setSizeGripEnabled().\n\n\n<h>\n*Tabify dock widget\n</h>\n\nA dock widget can be tabified on other dock widget with tabifyDockWidget function in QMainWindow.\n\n<h>\n*Drag and drop\n</h>\n\n  - Drag and Drop is done through a drag and a drop site.\n  - Drop site has to implement dragEnterEvent, dragMoveEvent and dropEvent\n  - Dtag site has to implement mousePressEvent and MoseMoveEvent\n  - Dragable data is encapsulated in QMideData and finaly in QDrag widget\n<c>\n ------------------\n  |                |\n  |                |------() mousePressEvent\n  |                |------() mouseMoveEvent\n  |                |------() dragEnterEvent\n  |   <DragDrop    |------() dragMoveEvent\n  |    widge>      |------() dropEvent\n  |                |\n  |                |\n  ------------------\n</c>\n  <<listwidget.h>>\n<cs>\n<c><*.pro></c>\nQT+=widgets\nRESOURCES = resource.qrc\n<c><resource.qrc></c>\n<!DOCTYPE RCC><RCC version="1.0">\n<qresource>\n<file>qt-slide-widget_drgdrpicon.png</file>\n</qresource>\n</RCC>\n<c><listwidget.h></c>\n#ifndef LISTWIDGET_H\n#define LISTWIDGET_H\n#include <QListWidget>\nstruct QDragEnterEvent;\nstruct QDropEvent;\nstruct QMouseEvent;\nstruct QDragMoveEvent;\n\nclass listwidget:public QListWidget{\nQ_OBJECT\npublic:\nlistwidget(QListWidget *p=0);\nprotected:\nvoid mousePressEvent(QMouseEvent *e);\nvoid mouseMoveEvent(QMouseEvent *e);\nvoid dragEnterEvent(QDragEnterEvent *e);\nvoid dragMoveEvent(QDragMoveEvent *e);\nvoid dropEvent(QDropEvent *e);\nprivate:\nQPoint spos;\n};\n#endif\n<c><listwidget.cpp></c>\n#include <QPixmap>\n#include <QListWidgetItem>\n#include <QPoint>\n#include <QDragEnterEvent>\n#include <QDragMoveEvent>\n#include <QDropEvent>\n#include <QMouseEvent>\n#include <QDrag>\n#include <QMimeData>\n#include <QApplication>\n#include "listwidget.h"\n\nlistwidget::listwidget(QListWidget *p):QListWidget(p){\naddItems(QStringList()<<"one"<<"two"<<"three");\nsetAcceptDrops(true);\n}\nvoid listwidget::mousePressEvent(QMouseEvent *e) {\nif(e->button() == Qt::LeftButton) spos=e->pos();\nQListWidget::mousePressEvent(e);\n}\n\nvoid listwidget::mouseMoveEvent(QMouseEvent *e){\nQMimeData *mimedata;\nQDrag *drag;\nQListWidgetItem *item;\nif(e->buttons() & Qt::LeftButton)\nif((e->pos()-spos).manhattanLength() >= QApplication::startDragDistance()){\nitem=currentItem();\nif(item) {\nmimedata=new QMimeData;\nmimedata->setText(item->text());\ndrag=new QDrag(this);\ndrag->setMimeData(mimedata);\ndrag->setPixmap(QPixmap(":/qt-slide-widget_drgdrpicon.png"));\nif(drag->exec(Qt::MoveAction) == Qt::MoveAction) delete item;\n}\n}\nQListWidget::mouseMoveEvent(e);\n}\n\nvoid listwidget::dragEnterEvent(QDragEnterEvent* e){\nlistwidget* source=qobject_cast<listwidget*>(e->source());\nif(source && source != this){\ne->setDropAction(Qt::MoveAction);\ne->accept();\n}\n}\n\nvoid listwidget::dragMoveEvent(QDragMoveEvent* e){\nlistwidget* source=qobject_cast<listwidget*>(e->source());\nif(source && source != this) {\ne->setDropAction(Qt::MoveAction);\ne->accept();\n}\n}\n\nvoid listwidget::dropEvent(QDropEvent *e){\nlistwidget* source=qobject_cast<listwidget*>(e->source());\nif(source && source!= this){\naddItem(e->mimeData()->text());\ne->setDropAction(Qt::MoveAction);\ne->accept();\n}\n}\n<c><main.cpp></c>\n#include <QApplication>\n#include "listwidget.h"\n\nint main(int argc, char *argv[]){\nQApplication a(argc,argv);\nlistwidget l1;\nlistwidget l2;\nl1.show();\nl2.show();\nreturn a.exec();\n}\n</cs>\nOUTPUT\n<m>http://minhinc.42web.io/image/qt-slide-widget_drgdrpicon.png</m>\n<m>http://minhinc.42web.io/image/qt-slide-widget_drgdrp.png</m>\n\n<h>\n*Applying Qt style sheet on Widgets\n</h>\n\nStyles sheets are textual specifications that can be set on the whole application using\nQApplication::setStyleSheet() or on a specific widget (and its children) using\nQWidget::setStyleSheet(). If several style sheets are set at different levels, Qt derives the\neffective style sheet from all of those that are set. This is called cascading.\n\nEx.\n\nQLineEdit { background: yellow }\nQCheckBox { color: red }\n\n<cs>\n<c><.pro></c>\nQT+=widgets\n# Input\nRESOURCES += resource.qrc\n\n<c><main.cpp></c>\n#include <QApplication>\n#include "mainwindow.h"\n\nint main(int argc, char* argv[]){\nQApplication a(argc, argv);\nmainwindow mw;\nmw.show();\nreturn a.exec();\n}\n\n<c><mainwindow.h></c>\n#ifndef MAINWINDOW_H\n#define MAINWINDOW_H\n#include <QMainWindow>\nstruct QDockWidget;\nstruct stylewidget;\n\nstruct mainwindow:QMainWindow{\nmainwindow();\nstylewidget* sw;\nQDockWidget *ldw,*rdw;\nprivate:\nQ_OBJECT\n};\n#endif\n\n<c><stylewidget.h></c>\nfndef STYLEWIDGET_H\n#define STYLEWIDGET_H\n#include <QWidget>\n#include <QString>\nstruct QLineEdit;\nstruct QComboBox;\nstruct QPushButton;\nstruct QListWidget;\n\nstruct stylewidget:QWidget{\nstylewidget();\nQComboBox* scb;\nQComboBox* sscb;\nQLineEdit* le;\nQPushButton* pb;\nQListWidget* lw;\nprivate slots:\nvoid slotscbactivated(const QString&);\nvoid slotsscbactivated(const QString&);\nprivate:\nQ_OBJECT\n};\n#endif\n\n<c><mainwindow.cpp></c>\n#include <QDockWidget>\n#include "mainwindow.h"\n#include "stylewidget.h"\n\nmainwindow::mainwindow(){\nsetCentralWidget(sw=new stylewidget);\naddDockWidget(Qt::LeftDockWidgetArea,ldw=new QDockWidget);\naddDockWidget(Qt::RightDockWidgetArea,rdw=new QDockWidget);\nldw->setAllowedAreas(Qt::LeftDockWidgetArea|Qt::RightDockWidgetArea);\nrdw->setAllowedAreas(Qt::RightDockWidgetArea|Qt::LeftDockWidgetArea);\nldw->setWindowTitle("Left");\nrdw->setWindowTitle("Right");\n}\n<c><stylewidget.cpp></c>\n#include <QLineEdit>\n#include <QPushButton>\n#include <QListWidget>\n#include <QLabel>\n#include <QComboBox>\n#include <QFile>\n#include <QVBoxLayout>\n#include <QHBoxLayout>\n#include <QApplication>\n#include <QStyleFactory>\n#include <QDebug>\n#include "stylewidget.h"\n\nstylewidget::stylewidget(){\nQVBoxLayout* vlt=new QVBoxLayout;\nQHBoxLayout* chlt=new QHBoxLayout;\nchlt->addWidget(scb=new QComboBox);\nchlt->addWidget(sscb=new QComboBox);\nvlt->addLayout(chlt);\nQHBoxLayout* hlt=new QHBoxLayout;\nhlt->addWidget(le=new QLineEdit);\nhlt->addWidget(pb=new QPushButton("click"));\nvlt->addLayout(hlt);\nvlt->addWidget(lw=new QListWidget);\nlw->addItem("one");\nlw->addItem("two");\nlw->addItem("three");\nsetLayout(vlt);\nlw->setCurrentRow(0);\nQRegExp regex(".(.*)\\+?Style");\nQString defaultstyle=QApplication::style()->metaObject()->className();\nqDebug()<<defaultstyle;\nif(regex.exactMatch(defaultstyle))\ndefaultstyle=regex.cap(1);\nqDebug()<<defaultstyle;\n\nscb->addItems(QStyleFactory::keys());\nscb->setCurrentIndex(scb->findText(defaultstyle, Qt::MatchContains));\n\nsscb->addItems(QStringList()<<"Default"<<"Style");\n\nsscb->setCurrentIndex(sscb->findText("Default"));\nconnect(scb,SIGNAL(activated(QString)),this,SLOT(slotscbactivated(QString)));\nconnect(sscb,SIGNAL(activated(QString)),this,SLOT(slotsscbactivated(QString)));\n}\nvoid stylewidget::slotscbactivated(const QString& stylename){\nqApp->setStyle(stylename);\n}\nvoid stylewidget::slotsscbactivated(const QString& stylesheetname){\nQFile file(":/"+stylesheetname.toLower() + ".qss");\nfile.open(QIODevice::ReadOnly);\nqApp->setStyleSheet(file.readAll());\n}\n<c><default.css></c>\n/* empty stylesheet */\n\n\n<c>style.qss</c>\nQLineEdit {\nbackground-color : palegoldenrod;\n}\nQLabel {\nfont:\'Tw Cen Mt\';\n}\nQPushButton {\nbackground-color : wheat;\n}\nQListWidget {\nbackground-color : wheat;\n}\n<c>resource.qrc</c>\n<!DOCTYPE RCC><RCC version="1.0">\n <qresource>\n  <file>style.qss</file>\n  <file>default.qss</file>\n </qresource>\n</RCC>\n</cs>\nOUTPUT\n<m>http://minhinc.42web.io/image/qt-slide-widget_style.png</m>\n<m>http://minhinc.42web.io/image/qt-slide-widget_stylesheet.png</m>\n<m>http://minhinc.42web.io/image/qt-slide-widget_stylesheet2.png</m>\n\n<h>\n*Scrolling, QScrollArea\n</h>\n\n<m>https://www.youtube.com/embed/aF1SszSlq9E</m>'
'6!ABS SBA!QPainter and Image management!ABS SBA!*QPainter\n*Transformation Matrix!ABS SBA!<h>\n*QPainter and capabilities\n</h>\n\n<m>https://www.youtube.com/embed/W8Q39V3RBhw</m>\n\nQPainter provides highly optimized functions to do most of the drawing GUI programs require. It has three drawing capabilities.\na) Pen\n   QPen(const QBrush & brush, qreal width, Qt::PenStyle style = Qt::SolidLine,\n   Qt::PenCapStyle cap = Qt::SquareCap, Qt::PenJoinStyle join = Qt::BevelJoin)\nb) Brush\n   QBrush(const QColor & color, Qt::BrushStyle style = Qt::SolidPattern)\nc) Font\n   QFont(const QString & family, int pointSize=-1, int weight = -1, bool italic=false)\n\n<h>\n*Using QPainter with OpenGL functions\n</h>\n\n- OpenGL gl library functions can be called along with 2D QPainter painting. Derive from QGLWidget or QOpenGLWidget which inturn creates OpenGL Context.\n- Use paintGL() function for QPainter to draw its primitive within begin() and end() function.\n- Call opengl function in paintGL() within beginNativePainting() and endNativePainting().\n- Other than initilizeGL(), resizeGL() and paintGL() opengGL context has to be mentioned explicitly by calling makeCurrent() and doneCurrent().\n\n<cs>\n<c><.pro></c>\nQT+= widgets opengl\n\n<c><main.cpp></c>\n#include <QApplication>\n#include "cube.h"\n\nint main(int argc, char *argv[]){\nQApplication a(argc, argv);\n\ncube vc;\nvc.show();\nreturn a.exec();\n}\n\n<c><cube.h></c>\n#ifndef CUBE_H\n#define CUBE_H\n\n#include <QRadialGradient>\nclass QMouseEvent;\nclass QWheelEvent;\nclass QPainter;\n\n#include <QGLWidget>\nclass cube : public QGLWidget\n{\n Q_OBJECT\npublic:\n cube(QWidget *parent = 0);\n ~cube();\nprotected:\n void paintEvent(QPaintEvent *event);\n void mousePressEvent(QMouseEvent *event);\nprivate:\n void createGradient();\n void createGLObject();\n void drawBackground(QPainter *painter);\n void drawCube();\n void drawLegend(QPainter *painter);\n GLuint glObject;\n QRadialGradient gradient;\n GLfloat rotationX;\n GLfloat rotationY;\n GLfloat rotationZ;\n GLfloat scaling;\n QPoint lastPos;\n};\n#endif\n<c><cube.cpp></c>\n#include <qmath.h>\n#include <QTextDocument>\n#include <QPainter>\n#include <QWheelEvent>\n#include <QMouseEvent>\n#include "cube.h"\n\ncube::cube(QWidget *parent)\n: QGLWidget(parent) {\nsetFormat(QGLFormat(QGL::SampleBuffers));\nrotationX = -38.0;\nrotationY = -58.0;\nrotationZ = 0.0;\nscaling = 1.0;\ncreateGradient();\ncreateGLObject();\n}\n\ncube::~cube() {\nmakeCurrent();\nglDeleteLists(glObject, 1);\n}\n\nvoid cube::paintEvent(QPaintEvent * /* event */) {\nQPainter painter(this);\ndrawBackground(&painter);\npainter.beginNativePainting();\ndrawCube();\npainter.endNativePainting();\ndrawLegend(&painter);\n}\n\nvoid cube::drawBackground(QPainter *painter)\n{\npainter->setPen(Qt::NoPen);\npainter->setBrush(gradient);\npainter->drawRect(rect());\n}\n\nvoid cube::drawCube() {\nglPushAttrib(GL_ALL_ATTRIB_BITS);\nglMatrixMode(GL_PROJECTION);\nglPushMatrix();\nglLoadIdentity();\nGLfloat x = 3.0 * GLfloat(width()) / height();\nglOrtho(-x, +x, -3.0, +3.0, 4.0, 15.0);\nglMatrixMode(GL_MODELVIEW);\nglPushMatrix();\nglLoadIdentity();\nglTranslatef(0.0, 0.0, -10.0);\nglScalef(scaling, scaling, scaling);\nglRotatef(rotationX, 1.0, 0.0, 0.0);\nglRotatef(rotationY, 0.0, 1.0, 0.0);\nglRotatef(rotationZ, 0.0, 0.0, 1.0);\nglEnable(GL_MULTISAMPLE);\nsetFont(QFont("Times", 24));\nqglColor(QColor(255, 223, 127));\nglCallList(glObject);\n\nglMatrixMode(GL_MODELVIEW);\nglPopMatrix();\nglMatrixMode(GL_PROJECTION);\nglPopMatrix();\nglPopAttrib();\n}\n\nvoid cube::createGradient() {\ngradient.setCoordinateMode(QGradient::ObjectBoundingMode);\ngradient.setCenter(0.45, 0.50);\ngradient.setFocalPoint(0.40, 0.45);\ngradient.setColorAt(0.0, QColor(105, 146, 182));\ngradient.setColorAt(0.4, QColor(81, 113, 150));\ngradient.setColorAt(0.8, QColor(16, 56, 121));\n}\n\nvoid cube::createGLObject() {\nmakeCurrent();\nglShadeModel(GL_FLAT);\nglObject = glGenLists(1);\nglNewList(glObject, GL_COMPILE);\nqglColor(QColor(255, 239, 191));\nglLineWidth(1.0);\nglBegin(GL_LINES);\nglVertex3f(1.0,1.0,-1.0);\nglVertex3f(-1.0,1.0,-1.0);\nglVertex3f(-1.0,1.0,-1.0);\nglVertex3f(-1.0,-1.0,-1.0);\nglVertex3f(-1.0,-1.0,-1.0);\nglVertex3f(1.0,-1.0,-1.0);\nglVertex3f(1.0,-1.0,-1.0);\nglVertex3f(1.0,1.0,-1.0);\n\nglVertex3f(-1.0,1.0,-1.0);\nglVertex3f(-1.0,1.0,1.0);\nglVertex3f(-1.0,1.0,1.0);\nglVertex3f(-1.0,-1.0,1.0);\nglVertex3f(-1.0,-1.0,1.0);\nglVertex3f(-1.0,-1.0,-1.0);\nglVertex3f(-1.0,-1.0,-1.0);\nglVertex3f(-1.0,1.0,-1.0);\n\nglVertex3f(-1.0,1.0,1.0);\nglVertex3f(-1.0,-1.0,1.0);\nglVertex3f(-1.0,-1.0,1.0);\nglVertex3f(1.0,-1.0,1.0);\nglVertex3f(1.0,-1.0,1.0);\nglVertex3f(1.0,1.0,1.0);\nglVertex3f(1.0,1.0,1.0);\nglVertex3f(-1.0,1.0,1.0);\nglVertex3f(1.0,1.0,1.0);\nglVertex3f(1.0,-1.0,1.0);\nglVertex3f(1.0,-1.0,1.0);\nglVertex3f(1.0,-1.0,-1.0);\nglVertex3f(1.0,-1.0,-1.0);\nglVertex3f(1.0,1.0,-1.0);\nglVertex3f(1.0,1.0,-1.0);\nglVertex3f(1.0,1.0,1.0);\n\nglEnd();\nglEndList();\ndoneCurrent();\n}\n\nvoid cube::drawLegend(QPainter *painter) {\nconst int Margin = 11;\nconst int Padding = 6;\nQTextDocument textDocument;\ntextDocument.setDefaultStyleSheet("* { color: #FFEFEF }");\ntextDocument.setHtml("<h4 align="center">OpenGL + QPainter</h4>"\n"<p align="center">This example issustrates OpenGL and QPainter drawing together</p>");\ntextDocument.setTextWidth(textDocument.size().width());\nQRect rect(QPoint(0, 0), textDocument.size().toSize()\n+ QSize(2 * Padding, 2 * Padding));\npainter->translate(width() - rect.width() - Margin,0);\n//height() - rect.height() - Margin);\npainter->setPen(QColor(255, 239, 239));\npainter->setBrush(QColor(255, 0, 0, 31));\npainter->drawRect(rect);\npainter->translate(Padding, Padding);\ntextDocument.drawContents(painter);\n}\nvoid cube::mousePressEvent(QMouseEvent* e){\n    QGLWidget::mousePressEvent(e);\n    rotationX+=10;\n    rotationY+=10;\n    rotationZ+=10;\n    update();\n}\n</cs>\nOUTPUT\n<m>http://minhinc.42web.io/image/qt-slide-qpainteropengl.gif</m>\n\n<h>\n*Image handling Qt\n*Classes for Image Handling (QImage, QPixmap,\nQBitMap etc)\n</h>\n\n- The QImage class provides a hardware-independent image representation which is designed and optimized for I/O, and for direct pixel access and manipulation.\n- The QPixmap class is an off-screen image representation which is designed and optimized for showing images on screen. Unlike QImage, the pixel data in a pixmap is internal and is managed by the underlying window system.\n- The QBitmap is only a convenience class that inherits QPixmap, ensuring a depth of 1.\n- The QPicture class is a paint device that records and replays QPainter commands.\n\n<cb\n// Specfiy semi-transparent red\n<g>painter</g>.setBrush(QColor(255, 0, 0, 127));\n<g>painter</g>.drawRect(0, 0, width()/2, height());\n// Specify semi-transparent blue\n<g>painter</g>.setBrush(QColor(0, 0, 255, 127));\n<g>painter</g>.drawRect(0, 0, width(), height()/2);\n</cb\n\n<m>http://minhinc.42web.io/image/qt-slide-qtblending.png</m>\n\n<h>\n*I/O with Image Files\n</h>\n\nQImage provides several ways of loading an image file:\nThe file can be loaded when constructing the QImage object,\nor by using the load() or loadFromData() functions later on.\n\nQImage also provides the static fromData() function,\nconstructing a QImage from the given data.\n\nCall the save() function to save a QImage object.\n\n<h>\n*Pixel Handling\n</h>\n\n<cs>\nQImage::QImage(int width, int height, Format format)\n\nConstant\tValue\tDescription\nQImage::Format_Invalid\t0\tThe image is invalid.\nQImage::Format_Mono\t1\tThe image is stored using 1-bit per pixel. Bytes are packed with the\n                                  most significant bit (MSB) first.\nQImage::Format_MonoLSB\t2\tThe image is stored using 1-bit per pixel. Bytes are packed with the\n                                  less significant bit (LSB) first.\nQImage::Format_Indexed8\t3\tThe image is stored using 8-bit indexes into a colormap.\nQImage::Format_RGB32\t4\tThe image is stored using a 32-bit RGB format (0xffRRGGBB).\nQImage::Format_ARGB32\t5\tThe image is stored using a 32-bit ARGB format (0xAARRGGBB).\nQImage::Format_ARGB32_Premultiplied\t6\tThe image is stored using a premultiplied 32-bit\n                                  ARGB format (0xAARRGGBB), i.e. the red, green, and blue channels are\n                                  multiplied by the alpha component divided by 255. (If RR, GG, or BB has a\n                                  higher value than the alpha channel, the results are undefined.) Certain\n                                  operations (such as image composition using alpha blending) are faster\n                                  using premultiplied ARGB32 than with plain ARGB32.\nQImage::Format_RGB16\t7\tThe image is stored using a 16-bit RGB format (5-6-5).\nQImage::Format_ARGB8565_Premultiplied\t8\tThe image is stored using a premultiplied 24-bit ARGB format (8-5-6-5).\nQImage::Format_RGB666\t9\tThe image is stored using a 24-bit RGB format (6-6-6). The unused most significant\n                                  bits is always zero.\nQImage::Format_ARGB6666_Premultiplied\t10\tThe image is stored using a premultiplied 24-bit ARGB format (6-6-6-6).\nQImage::Format_RGB555\t11\tThe image is stored using a 16-bit RGB format (5-5-5). The unused most\n                                  significant bit is always zero.\nQImage::Format_ARGB8555_Premultiplied\t12\tThe image is stored using a premultiplied 24-bit ARGB format (8-5-5-5).\nQImage::Format_RGB888\t13\tThe image is stored using a 24-bit RGB format (8-8-8).\nQImage::Format_RGB444\t14\tThe image is stored using a 16-bit RGB format (4-4-4). The unused bits are always zero.\nQImage::Format_ARGB4444_Premultiplied\t15\tThe image is stored using a premultiplied 16-bit ARGB format (4-4-4-4).\nQImage::Format_RGBX8888\t16\tThe image is stored using a 32-bit byte-ordered RGB(x) format (8-8-8-8). This is\n                                  the same as the Format_RGBA8888 except alpha must always be 255.\nQImage::Format_RGBA8888\t17\tThe image is stored using a 32-bit byte-ordered RGBA format (8-8-8-8). Unlike ARGB32\n                                  this is a byte-ordered format, which means the 32bit encoding differs between big\n                                  endian and little endian architectures, being respectively (0xRRGGBBAA) and\n                                  (0xAABBGGRR). The order of the colors is the same on any architecture if read as\n                                  bytes 0xRR,0xGG,0xBB,0xAA.\nQImage::Format_RGBA8888_Premultiplied\t18\tThe image is stored using a premultiplied 32-bit byte-ordered\n                                   RGBA format (8-8-8-8).\n</cs>\n\nValue Based\n<cb>\n<g>QImage</g> image(3, 3, QImage::Format_RGB32);\nQRgb value;\n\nvalue = qRgb(189, 149, 39); // 0xffbd9527\nimage.setPixel(1, 1, value);\n\nvalue = qRgb(122, 163, 39); // 0xff7aa327\nimage.setPixel(0, 1, value);\nimage.setPixel(1, 0, value);\n\nvalue = qRgb(237, 187, 51); // 0xffedba31\nimage.setPixel(2, 1, value);\n</cb>\n\n<m>http://minhinc.42web.io/image/qt-slide-qimage.png</m>\n\nIndex Based\n<cb>\n<g>QImage</g> image(3, 3, QImage::Format_Indexed8);\nQRgb value;\n\nvalue = qRgb(122, 163, 39); // 0xff7aa327\nimage.setColor(0, value);\n\nvalue = qRgb(237, 187, 51); // 0xffedba31\nimage.setColor(1, value);\n\nvalue = qRgb(189, 149, 39); // 0xffbd9527\nimage.setColor(2, value);\n\nimage.setPixel(0, 1, 0);\nimage.setPixel(1, 0, 0);\nimage.setPixel(1, 1, 2);\nimage.setPixel(2, 1, 1);\n</cb>\n\n<m>http://minhinc.42web.io/image/qt-slide-qpixmap.png</m>\n\n<h>\n*Image Transformation\n</h>\n\n<m>https://www.youtube.com/embed/hNYWlT9rADg</m>\n\n<m>https://www.youtube.com/embed/QcvBbsjSLZA</m>\n\nTransforming the original image\ncreateAlphaMask() function builds and returns a 1-bpp mask from the alpha buffer in this image\n\ncreateHeuristicMask() function creates and returns a 1-bpp heuristic mask for this image.\n\nmirrored() function returns a mirror of the image in the desired direction\nscaled() returns a copy of the image scaled to a rectangle of the desired measures\nrgbSwapped() function constructs a BGR image from a RGB image.\n\nscaledToWidth() and scaledToHeight() functions return scaled copies of the image.\n\ntransformed() function returns a copy of the image that is transformed with the given\n  transformation matrix and transformation mode\n\ntrueMatrix() function returns the actual matrix used for transforming the image.\n\nThere are also functions for changing attributes of an image in-place:\n<cb>\n<l>Function</l>                           <l>Description</l>\n<g>setDotsPerMeterX()</g> Defines the aspect ratio by setting the number of pixels that fit horizontally in a physical meter.\n<g>setDotsPerMeterY()</g> Defines the aspect ratio by setting the number of pixels that fit vertically in a physical meter.\n<g>fill()</g>                      Fills the entire image with the given pixel value.\n<g>invertPixels()</g>     Inverts all pixel values in the image using the given InvertMode value.\n<g>setColorTable()</g>    Sets the color table used to translate color indexes. Only monochrome and 8-bit formats.\n<g>setColorCount()</g>    Resizes the color table. Only monochrome and 8-bit formats.\n</cb>\n\n<h>\n*OpenGL 3D Painting\n</h>\n\nOpenGL in Qt\nIt used for 3D drawing, developed and maintained by silicon graphics.\nIn Qt provided through libOpenGL.\nIt can be implemented through QGLWidget, deriving from QWindow and\nQOpenGLFunction and through QGraphics views architecture.\n\nQGLContext creates context and contains all buffers details. Many gl context\ncan be created and only one can be active at a time with context->makeCurrent()\nfunciton call.\n\nQOpenGL returns its context with context().\nQOpenGL provides three functions for initializing, resizing and drawing.\n       initializeGL(), resizeGL(), paintGL()\n\nProcedures\n          - Position the camera, fix the scene\n          - Place the model (object)\n          - Set the projection\n          - Viewport\n<cs>\n<c><*.pro></c>\nQT += opengl\n\n<c><main.cpp></c>\n#include <QApplication>\n#include "myglwidget.h"\nint main(int argc, char *argv[])\n{\nQApplication a(argc, argv);\nMyGLWidget w;\nw.resize(800,600);\nw.show();\nreturn a.exec();\n}\n\n<c><myglwidget.h></c>\n#ifndef MYGLWIDGET_H\n#define MYGLWIDGET_H\n#include <QGLWidget>\nclass MyGLWidget : public QGLWidget{\n//signal slot\nQ_OBJECT\npublic:\nMyGLWidget(QWidget *parent = NULL)\n: QGLWidget(parent) {}\nprotected:\n// Set up the rendering context, define display lists etc.:\nvoid initializeGL();\n// draw the scene:\nvoid paintGL();\n// setup viewport, projection etc.:\nvoid resizeGL (int width, int height);\n};\n#endif\n<c><myglwidget.cpp></c>\n#include "myglwidget.h"\n//first funciton to be called\nvoid MyGLWidget::initializeGL(){\nglClearColor(0.0,1.0,0.0,0.0);\nglShadeModel(GL_FLAT);\nglEnable(GL_DEPTH_TEST);\n}\n// setup viewport and projection\nvoid MyGLWidget::resizeGL (int width, int height){\nglViewport( 0, 0, (GLint)width, (GLint)height );\nglMatrixMode(GL_PROJECTION);\nglLoadIdentity();\nglFrustum( -1.0, 1.0, -1.0, 1.0, 5.0, 30.0);\n//glOrtho( -2.0, 2.0, -2.0, 2.0, 5.0, 30.0);\nglMatrixMode( GL_MODELVIEW );\n}\n\nvoid MyGLWidget::paintGL(){\nglClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\nglMatrixMode(GL_MODELVIEW);\nglLoadIdentity();\nglTranslatef(0.0f,0.0f,-20.0f);\nglRotatef(30.0,0.0,1.0,0.0);\nglRotatef(15.0,1.0,0.0,0.0);\nglBegin(GL_QUADS);\nglColor3f(0.0,1.0,0.0);\nglVertex3f(1.0,1.0,-1.0);\nglVertex3f(-1.0,1.0,-1.0);\nglVertex3f(-1.0,-1.0,-1.0);\nglVertex3f(1.0,-1.0,-1.0);\n\nglColor3f(1.0,1.0,0.0);\nglVertex3f(-1.0,1.0,1.0);\nglVertex3f(-1.0,-1.0,1.0);\nglVertex3f(-1.0,-1.0,-1.0);\nglVertex3f(-1.0,1.0,-1.0);\n\n\nglColor3f(1.0,0.0,0.0);\nglVertex3f(1.0,1.0,1.0);\nglVertex3f(-1.0,1.0,1.0);\nglVertex3f(-1.0,-1.0,1.0);\nglVertex3f(1.0,-1.0,1.0);\n\nglColor3f(1.0,0.0,1.0);\nglVertex3f(1.0,1.0,1.0);\nglVertex3f(1.0,-1.0,1.0);\nglVertex3f(1.0,-1.0,-1.0);\nglVertex3f(1.0,1.0,-1.0);\n\nglColor3f(0.0,0.0,1.0);\nglVertex3f(-1.0,1.0,1.0);\nglVertex3f(1.0,1.0,1.0);\nglVertex3f(1.0,1.0,-1.0);\nglVertex3f(-1.0,1.0,-1.0);\n\nglColor3f(0.0,1.0,1.0);\nglVertex3f(1.0,-1.0,1.0);\nglVertex3f(1.0,-1.0,-1.0);\nglVertex3f(-1.0,-1.0,-1.0);\nglVertex3f(-1.0,-1.0,1.0);\n\nglEnd();\n}\n</cs>\nOUTPUT\n<m>http://minhinc.42web.io/image/qt-slide-3daliased.gif</m>'
'7!ABS SBA!Layout Management!ABS SBA!*Box Layout\n*Grid Layout\n*Stack Layout!ABS SBA!<h>\n*Layout Concepts\n</h>\n\nGoal of Layout:\n - Positioning of child widgets.\n - Sensible default sizes for windows.\n - Sensible minimum sizes for windows.\n - Resize handling.\n - Automatic updates when contents change:\n   Font size, text or other contents of child widgets.\n    Hiding or showing a child widget.\n   Removal of child widgets.\n\nVarious Layout related classes\nQWidget layouts\n- QLayout The base class of geometry managers\n -+ QBoxLayout Lines up child widgets horizontally or vertically\n    +QHBoxLayout Lines up widgets horizontally\n    +QVBoxLayout Lines up widgets vertically\n  +QStackedLayout Stack of widgets where only one widget is visible at a time\n  +QFormLayout Manages forms of input widgets and their associated labels\n  +QGridLayout Lays out widgets in a grid\nQLayoutItem Abstract item that a QLayout manipulates\nQSpacerItem Blank space in a layout\nQWidgetItem Layout item that represents a widget\n\nQGraphicsViews Layouts\nQGraphicsAnchorLayout Layout where one can anchor widgets together in Graphics View\nQGraphicsAnchor Represents an anchor between two items in a QGraphicsAnchorLayout\nQLinearLayout\n\nQSizePolicy Layout attribute describing horizontal and vertical resizing policy\nQButtonGroup Container to organize groups of button widgets\nQGroupBox Group box frame with a title\nQStackedWidget Stack of widgets where only one widget is visible at a time\n\n<h>\n*Laying Rows and Columns\n</h>\n\n\nQBoxLayout takes the space it gets (from its parent layout or from the\nparent Widget()), divides it up into a row of boxes, and makes each managed widget fill\none box.\n\nIf the QBoxLayout\'s orientation is Qt::Horizontal the boxes are placed in a row.\n\nIf the QBoxLayout\'s orientation is Qt::Vertical, the boxes are placed in a column.\n\n<h>\n*Vertical and Horizontal Layout\n</h>\n\n\nA QHBoxLayout lays out widgets in a horizontal row, from left to right (or right to left for\nright-to-left languages).\n\n<m>http://minhinc.42web.io/image/qt-slide-qhboxlayout.png</m>\nA QVBoxLayout lays out widgets in a vertical column, from top to bottom.\n<m>http://minhinc.42web.io/image/qt-slide-qvboxlayout.png</m>\n<cs>\n// QT(+core gui widgets) TARGET(container) TEMPLATE(app) SOURCES(+container.cpp)/*\n       +-------------------------------+\n       |  ---------------------------  |\n       |  | <LABEL>                 |  |\n       |  | ....................... |  |\n       |  | .<Text>               . |  |\n       |  | .                     . |  |\n       |  | .                     . |  |\n       |  | .                     . |  |\n       |  | .                     . |  |\n       |  | .                     . |  |\n       |  | ....................... |  |\n       |  |                         |  |\n       |  | ----------------------- |  |\n       |  | | <BUTTON>  <BUTTON>  | |  |\n       |  | ----------------------- |  |\n       |  ---------------------------  |\n       +-------------------------------+\n*/\n\n#include <QApplication>\n#include <QWidget>\n#include <QHBoxLayout>\n#include <QVBoxLayout>\n#include <QLabel>\n#include <QTextEdit>\n#include <QPushButton>\n\nint main(int argc, char *argv[]) {\nQApplication a(argc, argv);\n//container object is a container widget containing other widgets.\nQWidget* container=new QWidget;\nQLabel* label=new QLabel("Note",container);\nQTextEdit* text=new QTextEdit(container);\nQPushButton* clear=new QPushButton("clear",container);\nQPushButton* save=new QPushButton("save",container);\n//QVBoxLayout and QHBoxLayout are non widget layouts\nQVBoxLayout* outer=new QVBoxLayout;\nouter->addWidget(label);\nouter->addWidget(text);\nQHBoxLayout* inner=new QHBoxLayout;\ninner->addWidget(clear);\ninner->addWidget(save);\n//push QHBoxLayout in QVBoxLayout as another entity in vertical order\nouter->addLayout(inner);\ncontainer->setLayout(outer);\ncontainer->show();\nreturn a.exec();\n}\n</cs>\nOUTPUT\n<m>http://minhinc.42web.io/image/qt-slide-layout.gif</m>\n\n<h>\n*Grid Layout\n</h>\n\n\nThe QGridLayout class lays out widgets in a grid.\nQGridLayout takes the space made available to it (by its parent layout or by the\nparentWidget()), divides it up into rows and columns, and puts each widget it\nmanages into the correct cell.\n\nColumns and rows behave identically; we will discuss columns, but there are equivalent\nfunctions for rows.\n\nEach column has a minimum width and a stretch factor. The minimum width is the\ngreatest of that set using setColumnMinimumWidth() and the minimum width of\neach widget in that column. The stretch factor is set using setColumnStretch() and\ndetermines how much of the available space the column will get over and above its\nnecessary minimum.\n\n<m>http://minhinc.42web.io/image/qt-slide-qformlayout.png</m>\n<cb>\n<g>QFormLayout</g> *formLayout = new QFormLayout;\nformLayout->addRow(tr("&Name:"), nameLineEdit);\nformLayout->addRow(tr("&Email:"), emailLineEdit);\nformLayout->addRow(tr("&Age:"), ageSpinBox);\nsetLayout(formLayout);\n</cb>\nSame in Grid Layout\n<cb>\nnameLabel = new <g>QLabel</g>(tr("&Name:"));\nnameLabel->setBuddy(nameLineEdit);\nemailLabel = new <g>QLabel</g>(tr("&Name:"));\nemailLabel->setBuddy(emailLineEdit);\nageLabel = new <g>QLabel</g>(tr("&Name:"));\nageLabel->setBuddy(ageSpinBox);\n<g>QGridLayout</g> *gridLayout = new QGridLayout;\ngridLayout->addWidget(nameLabel, 0, 0);\ngridLayout->addWidget(nameLineEdit, 0, 1);\ngridLayout->addWidget(emailLabel, 1, 0);\ngridLayout->addWidget(emailLineEdit, 1, 1);\ngridLayout->addWidget(ageLabel, 2, 0);\ngridLayout->addWidget(ageSpinBox, 2, 1);\nsetLayout(gridLayout);\n</cb>\n\n<h>\n*Form Layout\n</h>\n\n\n<h>\n*Stacked Layout\n</h>\n\n\nThe QStackedLayout class provides a stack of widgets where only one widget is\nvisible at a time.\nQStackedLayout can be used to create a user interface similar to the one provided by\nQTabWidget. There is also a convenience QStackedWidget class built on top of\nQStackedLayout.\n\nA QStackedLayout can be populated with a number of child widgets ("pages").\nFor example:\n<cb>\n<g>QWidget</g> *firstPageWidget = new <g>QWidget</g>;\n<g>QWidget</g> *secondPageWidget = new <g>QWidget</g>;\n<g>QWidget</g> *thirdPageWidget = new <g>QWidget</g>;\n\n<g>QStackedLayout</g> *stackedLayout = new <g>QStackedLayout</g>;\nstackedLayout->addWidget(firstPageWidget);\nstackedLayout->addWidget(secondPageWidget);\nstackedLayout->addWidget(thirdPageWidget);\n\n<g>QVBoxLayout</g> *mainLayout = new <g>QVBoxLayout</g>;\nmainLayout->addLayout(stackedLayout);\nsetLayout(mainLayout);\n</cb>\n\n<h>\n*Anchor Layout\n</h>\n\n\nThe QGraphicsAnchorLayout class provides a layout where one can anchor widgets\ntogether in Graphics View.\n\nThe anchor layout allows developers to specify how widgets should be placed relative\nto each other, and to the layout itself. The specification is made by adding anchors to\nthe layout by calling addAnchor(), addAnchors() or addCornerAnchors().\n\nExisting anchors in the layout can be accessed with the anchor() function. Items\nthat are anchored are automatically added to the layout, and if items are removed, all\ntheir anchors will be automatically removed.\n<m>http://minhinc.42web.io/image/qt-slide-qanchorlayout.png</m>\nAnchors are always set up between edges of an item, where the "center"\nis also considered to be an edge. Consider the following example:\n\n<cb>\nlayout->addAnchor(b, <g>Qt</g>::AnchorLeft, a, <g>Qt</g>::AnchorRight);\nlayout->addAnchor(b, <g>Qt</g>::AnchorTop, a, <g>Qt</g>::AnchorBottom);\n</cb>\n\nHere, the right edge of item a is anchored to the left edge of item\nb and the bottom edge of item a is anchored to the top edge of item b,\nwith the result that item b will be placed diagonally to the right and\nbelow item b.\n\nThe addCornerAnchors() function provides a simpler way of anchoring\nthe corners of two widgets than the two individual calls to addAnchor()\nshown in the code above. Here, we see how a widget can be anchored\nto the top-left corner of the enclosing layout:\n\nlayout->addCornerAnchors(a, Qt::TopLeftCorner, layout, Qt::TopLeftCorner);'
'8!ABS SBA!Model View Controller(MVC)!ABS SBA!*Custom Model\n*Custom Delegate!ABS SBA!<h>\n*Qt model view architecture\n- QTableWidget and QTableView\n- QAbstractItemModel QAbstractItemView\n</h>\n\nThe difference between standard and model/view widgets\nThe standard widgets involves widgets which include internal containers for storing data.\n\n<m>http://minhinc.42web.io/image/qt-slide-qwithoutmodelview.png</m>\n  Model/view widgets do not maintain internal data containers. They access\n  external data through a standardized interface and therefore avoid data duplication.\n\n<m>http://minhinc.42web.io/image/qt-slide-qmodelview.png</m>\n- View has to implement QAbstractItemView\n- View has to aggregate QAbstractItemModel interface.\n- Any instance of a class that implements QAbstractItemModel is said to be a model\n- A delegate do the index ways rendering of the view and editing to the model.\n  Delegate has to implement QAbstractItemDelegate\n\n<m>http://minhinc.42web.io/image/qt-slide-qmodelviewdelegate.png</m>\nQTableWidget - Ready Made widget view that has a default internal Model. It can not take extern model.\n\n<c>\ntableWidget = new QTableWidget(12, 3, this);\nor\ntableWidget = new QTableWidget(this);\ntableWidget->setRowCount(10);\ntableWidget->setColumnCount(5);\n\n\nQTableWidgetItem *newItem = new QTableWidgetItem(tr("%1").arg(\n(row+1)*(column+1))); tableWidget->setItem(row, column, newItem);\n\nQTableWidgetItem *cubesHeaderItem = new QTableWidgetItem(tr("Cubes"));\ncubesHeaderItem->setIcon(QIcon(QPixmap(":/Images/cubed.png")));\ncubesHeaderItem->setTextAlignment(Qt::AlignVCenter);\n</c>\n\n\nQTableView - An QAbstractItemView class where delegatee and model can be set externally.\n<c>\nQStandardItemModel model(4, 2);\nQTableView tableView;\ntableView.setModel(&model);\n\nfor (int row = 0; row < 4; ++row) {\n        for (int column = 0; column < 2; ++column) {\n            QModelIndex index = model.index(row, column, QModelIndex());\n            model.setData(index, QVariant((row + 1) * (column + 1)));\n        }\n}\n</c>\n\n- QAbstractItemModel, QAbstractItemView, QAbstractItemDelegate\n<c>\n-----------------------\n|                     |\n|                     |--------() rowCount\n|                     |--------() columnCount\n|                     |--------() data()\n| QAbstractTableModel |--------() setData()\n|                     |--------() flags\n|                     |\n|                     |\n|                     |\n-----------------------\n\n\n-----------------------\n|                     |\n|                     |----() createEditor() // Editor, index widget for view\n|                     |----() setEditorData()//set view editor data,view rendering\n|                     |----() setModelData() // set Model data, model editring\n|QAbstractItemDelegate|----() updateEditorGeometry() // Change editor geometry\n|                     |\n|                     |\n|                     |\n-----------------------\n</c>\n\n<h>\n*Predefined Model\n</h>\n\n<m>http://minhinc.42web.io/image/qt-slide-qlisttabletree.png</m>\nList Models, QAbstractListModel\n-Table Models are subclassed from QAbstractListModel.\n- Various Tree Model available are QFileSystemModel.\n<c>\n   QFileSystemModel *model=new QFileSuystemModel;\n   model-><setRootPath(QDir::currentPath());\n   QListView *list=new QTableView(splitter);\n   list->setModel(model);\n</c>\n\nTable Models, QAbstractTableModel\n-Table Models are subclassed from QAbstractTableModel.\n- Various Tree Model available are QFileSystemModel.\n<c>\n   QFileSystemModel *model=new QFileSuystemModel;\n   model-><setRootPath(QDir::currentPath());\n   QTableView *table=new QTableView(splitter);\n   table->setModel(model);\n</c>\n\nTree Models\n-Tree Models are subclassed from QAbstractItemModel.\n- Various Tree Model available are QFileSystemModel.\n<c>\n   QFileSystemModel *model=new QFileSuystemModel;\n   model-><setRootPath(QDir::currentPath());\n   QTreeView *tree=new QTreeView(splitter);\n   tree->setModel(model);\n</c>\n\nOther predefined Models\n- QStringListModel\n\n<h>\n*Predefined Views\n</h>\n\n- Predefined Views\n  - QColumnView\n  - QHeaderView\n  - QListView\n  - QTableView\n  - QTreeView\n\n<h>\n*Proxy Model\n</h>\n\nCustom Models\n- Custom models need to be subclassed from QAbstractItemModel.\n- For QListView or QTableView QAbstractListModel or QAbstractTableModel needs to be subclassed.\n- QAbstractItemModel is basic has a table with rows and coloumns. Each entity in table is idenfiied as item and has itemIndex assisciated.\n- Hierarchy of tables is possible and each itemIndex can have siblings, parent and children.\n- Each item has number of data elemeents associated with it and they can be retrieved by specifying a role to the model\'s data() function.\n- Model has row count and column count for eacy level of hierarchy.\n- When subclassing QAbstractItemModel, index(), parent(), rowCount(), columnCount() and data() must be implemented.\n- For Model/View architecture perspective where modifcation in model reflects at all views requires\n\n<c>\n> insertRows()      beginInsertRows()        endInsertTows()\n> insertColumn()    beginInsertColumns()     endInsertColumns()\n> removeRows()      beginRemoveRows()        endRemoveRows()\n> removeColumns()   beginRemoveColumns()     endRemoveColumns()\n\n\n-----------------------\n|                     |\n|                     |--------() rowCount\n|                     |--------() columnCount\n|                     |--------() data()\n| QAbstractTableModel |--------() setData()\n|                     |--------() flags\n|                     |\n|                     |\n|                     |\n-----------------------\n</c>\n\n<cs>\n<c><.pro></c>\nQT+=core widgets\nTARGET=mv\nTEMPLATES=app\nSOURCES+=main.cpp model.cpp\nHEADERS+=model.h\n\n<c><main.cpp></c>\n#include <QApplication>\n#include <QTableView>\n#include "model.h"\n\nint main(int argc, char *argv[]) {\nQApplication a(argc, argv);\nQTableView tv;\nQTableView tv1;\nQTableView tv2;\nmodel mdl;\ntv.setModel(&mdl);\ntv1.setModel(&mdl);\ntv2.setModel(&mdl);\ntv.show();\ntv1.show();\ntv2.show();\nreturn a.exec();\n}\n\n<c><model.h></c>\n#ifndef MODEL_H\n#define MODEL_H\n#include <QAbstractTableModel>\n#include <QString>\nclass model: public QAbstractTableModel{\nQ_OBJECT\npublic:\nmodel(QObject *parent=0);\nint rowCount(const QModelIndex &parent=QModelIndex()) const;\nint columnCount(const QModelIndex &parent = QModelIndex()) const;\nQVariant data(const QModelIndex &index, int role=Qt::DisplayRole) const;\nbool setData(const QModelIndex & index, const QVariant & value, int role = Qt::EditRole);\nQt::ItemFlags flags(const QModelIndex& index) const;\nstatic const int ROWS=2;\nstatic const int COLS=3;\nQString dt[ROWS][COLS];\n};\n#endif\n\n<c><model.cpp></c>\n#include <QString>\n#include <QVariant>\n#include "model.h"\nmodel::model(QObject *parent):QAbstractTableModel(parent){}\nint model::rowCount(const QModelIndex &)const{\nreturn ROWS;\n}\nint model::columnCount(const QModelIndex &) const{\nreturn COLS;\n}\nQVariant model::data(const QModelIndex &index, int role)const {\nif (role == Qt::DisplayRole)\nreturn dt[index.row()][index.column()];\nreturn QVariant();\n}\nbool model::setData(const QModelIndex & index, const QVariant & value, int role){\nif(role==Qt::EditRole)\n  dt[index.row()][index.column()]=value.toString();\n  emit dataChanged(index,index);\n  return true;\n}\nQt::ItemFlags model::flags(const QModelIndex& index) const{\n return Qt::ItemIsEditable | QAbstractTableModel::flags(index);\n}\n</cs>\nOUTPUT\n<m>http://minhinc.42web.io/image/qt-slide-mvc.gif</m>\n\n<h>\n*Implementing custom delegates\n</h>\n\n<c>\n-----------------------\n|                     |\n|                     |----() createEditor() // Editor, index widget for view\n|                     |----() setEditorData()//set view editor data, view rendering\n|                     |----() setModelData() // set Model data, model editring\n|QAbstractItemDelegate|----() updateEditorGeometry() // Change editor geometry\n|                     |\n|                     |\n|                     |\n-----------------------\n</c>\n\n<cs>\n<c><*.pro></c>\nQT+=widgets\n<c><delegate.h></c>\n#ifndef DELEGATE_H\n#define DELEGATE_H\n#include <QStyledItemDelegate>\nclass spinboxdelegate : public QStyledItemDelegate{\nQ_OBJECT\npublic:\nspinboxdelegate(QObject *parent = 0);\nQWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &index) const;\nvoid setEditorData(QWidget *editor, const QModelIndex &index) const;\nvoid setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &index) const;\nvoid updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &option, const QModelIndex &index) const;\n};\n#endif\n<c><delegate.cpp></c>\n#include <QSpinBox>\n#include <QDebug>\n#include "delegate.h"\nspinboxdelegate::spinboxdelegate(QObject *parent)\n    : QStyledItemDelegate(parent) {\n}\nQWidget *spinboxdelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &, const QModelIndex &) const {\nQSpinBox *editor = new QSpinBox(parent);\neditor->setFrame(false);\neditor->setMinimum(0);\neditor->setMaximum(100);\nreturn editor;\n}\nvoid spinboxdelegate::setEditorData(QWidget *editor, const QModelIndex &index) const{\n(static_cast<QSpinBox*>(editor))->setValue(index.model()->data(index, Qt::EditRole).toInt());\n}\nvoid spinboxdelegate::setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &index) const {\nQSpinBox *spinBox = static_cast<QSpinBox*>(editor);\nspinBox->interpretText();\nmodel->setData(index, spinBox->value(), Qt::EditRole);\n}\nvoid spinboxdelegate::updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &option, const QModelIndex &) const {\neditor->setGeometry(option.rect);\n}\n<c><model.h></c>\n#ifndef MODEL_H\n#define MODEL_H\n#include <QAbstractTableModel>\n#include <QString>\nclass model: public QAbstractTableModel{\nQ_OBJECT\npublic:\nmodel(QObject *parent=0);\nint rowCount(const QModelIndex &parent=QModelIndex()) const;\nint columnCount(const QModelIndex &parent = QModelIndex()) const;\nQVariant data(const QModelIndex &index, int role=Qt::DisplayRole) const;\nbool setData(const QModelIndex & index, const QVariant & value, int role =Qt::EditRole);\nQt::ItemFlags flags(const QModelIndex& index) const;\nstatic const int ROWS=2;\nstatic const int COLS=3;\nQString dt[ROWS][COLS];\n};\n#endif\n<c><model.cpp></c>\n#include <QString>\n#include <QVariant>\n#include <QDebug>\n#include "model.h"\n\nmodel::model(QObject *parent):QAbstractTableModel(parent){\nint i=0,j=0;\nfor (i=0;i<ROWS;i++)\n for (j=0;j<COLS;j++)\n  dt[i][j]=QString("%1").arg(0);\n}\nint model::rowCount(const QModelIndex &)const{\n return ROWS;\n}\nint model::columnCount(const QModelIndex &) const{\n return COLS;\n}\nQVariant model::data(const QModelIndex &index, int role)const {\nif (role == Qt::DisplayRole || role== Qt::EditRole)\n return dt[index.row()][index.column()];\nreturn QVariant();\n}\nbool model::setData(const QModelIndex & index, const QVariant & value, int role){\nif(role==Qt::EditRole)\n dt[index.row()][index.column()]=value.toString();\nemit dataChanged(index,index);\nreturn true;\n}\n\nQt::ItemFlags model::flags(const QModelIndex& index) const{\n return Qt::ItemIsEditable | QAbstractTableModel::flags(index);\n}\n<c><main.cpp></c>\n#include <QApplication>\n#include <QTableView>\n#include "model.h"\n#include "delegate.h"\n\nint main(int argc, char *argv[]) {\nQApplication a(argc, argv);\nQTableView tv,tv1;\nspinboxdelegate dlg,dlg1;\nmodel mdl;\ntv.setModel(&mdl);\ntv.setItemDelegate(&dlg);\ntv1.setModel(&mdl);\ntv1.setItemDelegate(&dlg1);\ntv.show();\ntv1.show();\nreturn a.exec();\n}\n</cs>\nOUTPUT\n<m>http://minhinc.42web.io/image/qt-slide-delegate.gif</m>'
'9!ABS SBA!Plugin Architecture!ABS SBA!*Extending existing plugin\nWriting Plugin from scratch!ABS SBA!<h>\n*Library concepts\n- Static linking\n- Dynamic linking (late binding)\n- Runtime linking (late late binding)\n</h>\n\n<m>https://www.youtube.com/embed/yCaFuT_JIyc</m>\n\n- Static linking, liking to library is achieved at  compile-link time.  Executable binary contans the library code. Following ompiler directive used to create the library\n\n<<calc_mean.c>>\n<c>\n//#include <stdio.h>\ndouble mean(double a, double b){\nreturn (a+b)/2;\n}\n</c>\n\n<<calc_mean.h>>\n<c>\ndouble mean(double, double);\n\n<<calc.c>>\n#include <stdio.h>\n#include "calc_mean.h"\nint main(){\nprintf("mean of 3, 6 is %f\n", mean(3,6));\nreturn 0;\n}\n\n$gcc -c calc_mean.c -o calc-mean.o\n$ar rcs libmean.a calc_mean.o // create archive file\n                              // (static library) *.a file\n$gcc -c calc.c -o calc.o //  create binary file\n$gcc  -o calc calc.o -L.  -lmean\n\n\n$ nm libmean.a\n  calc_mean.o:\n  0000000000000000 T mean\n\n +--------------+\n |              | <-------\n |  libmean.a   |        |  libmean.a is inside the binary file\n ----------------        |\n |  code & data | o-------\n +--------------+\n calc binary file\n</c>\n\n- Dynamic linking (late binding), linking to library is achieved at run time.\n<m>https://www.youtube.com/embed/9plgeE9gCWo</m>\n\n<c>\n$gcc -c -fPIC calc_mean.c -o calc_mean.o\n$gcc -c calc.c -o calc.o\n$gcc -shared -fPIC -o libmean.so calc_mean.o\n$ldd libmean.so\n linux-vdso.so.1 =>  (0x00007fffadffe000)\n libc.so.6 => /lib64/libc.so.6 (0x00007f546f7ed000)\n /lib64/ld-linux-x86-64.so.2 (0x00007f546fdc4000)\n\n$gcc -o calc calc.o -L. -lmean\n$ldd calc\n linux-vdso.so.1 =>  (0x00007fffa58de000)\n libmean.so => not found\n libc.so.6 => /lib64/libc.so.6 (0x00007f4e10d70000)\n /lib64/ld-linux-x86-64.so.2 (0x00007f4e11146000)\n\n\n  +--------------+            +--------------+\n  |              |   ------>  |  libmean.a   |\n  |  code & data |   |        +--------------+\n  +--------------+   |\n     calc binary     |         libmean library\n                     |\n                     |\n     Libmean.so is external to calc binary\n\n\n\n  +--------------+                            |               |\n  |              | <---libmean.so mapped -->  |               |\n  |  libmean.so  |     from shared memory     | libmean.so    |\n  ----------------                            |               |\n  |  code & data |                            |               |\n  +--------------+\n    calc process                                shared memory\n\n$export LD_LIBRARY_PATH=.\n$./calc\nmean of 3, 6 is 4.500000\nIn order to avoid LD_LIBRARY_PATH programmer can add\n-Wl,rpath,<lib path> to the command link line\n</c>\n\n- Runtime linking (late late binding)\n Library is not loaded when binary executes, rather than it is loaded on demand at run time. C function libraries are loaded through Qlibrary class method load() or resolve().\n<m>https://www.youtube.com/embed/Pguk9gwiGqs</m>\n\nQLibrary myLib("mylib");\ntypedef void (*MyPrototype)();\nMyPrototype myFunction = (MyPrototype) myLib.resolve("mysymbol");\nif (myFunction)\nmyFunction();\n\n<h>\n*Extending qt with existing plugin\n - Plugin macros\n - Style sheets\n</h>\n\nPlugins are class based shared libraries which are loaded through QPluginLoader class rather than Qlibrary.\n\nQt provides two APIs for creating plugins.\n  - A higher-level API for writing extensions to Qt itself: custom database drivers, image formats, text codecs, custom styles, etc.\n  - Lower level API where plgin is written from scratch. Base classes of higher level API plugins are written through low level API plugins.\n\n\nHigher-level plugins are achieved through deriving achieved through deriving existing plugin interfaces, example\n\n<c>\nBase Class                         Directory Name             Key Case Sensitivity\nQAccessibleBridgePlugin accessiblebridge      Case Sensitive\nQAccessiblePlugin       accessible            Case Sensitive\nQDecorationPlugin       decorations           Case Insensitive\nQFontEnginePlugin       fontengines           Case Insensitive\nQIconEnginePlugin       iconengines           Case Insensitive\nQImageIOPlugin          imageformats          Case Sensitive\nQInputContextPlugin     inputmethods          Case Sensitive\nQKbdDriverPlugin        kbddrivers            Case Insensitive\nQMouseDriverPlugin      mousedrivers          Case Insensitive\nQScreenDriverPlugin     gfxdrivers            Case Insensitive\nQScriptExtensionPlugin  script                Case Sensitive\nQSqlDriverPlugin        sqldrivers            Case Sensitive\nQStylePlugin            styles                Case Insensitive\nQTextCodecPlugin        codecs                Case Sensitive\n</c>\n\nPlugin macros are declared in QstylePlugin dervice class as\n<c>\n Q_PLUGIN_METADATA(IID "org.qt-project.Qt.QStyleFactoryInterface" FILE "simplestyle.json")\n</c>\nJson file contains the key. QStylePlugin create function is called against the key.\n<c>\n                        -------------\n                        |  QObject  |\n                        -------------\n                             / \\\n                              -\n                              |\n        --------------- -------------  --------------------\n        | QStylePlugin| |  QObject  |  | QSqlDriverPlugin | . . .\n        --------------- -------------  --------------------\n                             / \\\n                              -\n                              |\n                     ---------------------\n                     | simplestyleplugin |\n                     ---------------------\n                     | o create():QStyle*|\n                     ---------------------\n                       Plugin interface\n\n\n\n                     ----------------       --------        ---------\n                     |  QCommonStyle| ---|> |QStyle| ---|>  |QObject|\n                     ----------------       --------        ---------\n                            / \\\n                             -\n                             |\n                     ---------------\n                     | QProxyStyle |\n                     ---------------\n                            / \\\n                             -\n                             |\n                    ---------------------\n                    | simplestyleplugin |\n                    ---------------------\n                    | o polish(QPalette)|\n                    ---------------------\n                    Plugin implementation\n</c>\n<<styleplugin.pro>>\n<c>\nTEMPLATE = subdirs\nSUBDIRS = app plugin\n</c>\n\n<<app/app.pro>>\n<c>\nQT += widgets\nSOURCES += main.cpp\nTARGET = styleplugin\nwin32 {\ndebug:DESTDIR = ../debug/\nrelease:DESTDIR = ../release/\n} else {\n    DESTDIR    = ../\n}\n</c>\n\n<<app/main.cpp>>\n<c>\n#include <QtWidgets>\nint main(int argv, char *args[]) {\nQApplication app(argv, args);\nQApplication::setStyle(QStyleFactory::create("simplestyle"));\nQPushButton pb("clickme");\npb.show();\nreturn app.exec();\n}\n</c>\n\n<<plugin/plugin.pro>>\n<c>\nTEMPLATE    = lib\nCONFIG     += plugin\nQT         += widgets\nHEADERS     = simplestyle.h\n              simplestyleplugin.h\nSOURCES     = simplestyle.cpp\n              simplestyleplugin.cpp\nTARGET      = simplestyleplugin\nwin32 {\n    CONFIG(debug, release|debug):DESTDIR = ../debug/styles/\n    CONFIG(release, release|debug):DESTDIR = ../release/styles/\n} else {\n    DESTDIR = ../styles/\n}\nEXAMPLE_FILES += simplestyle.json\n\n<<plugin/simplestyle.json>>\n{\n    "Keys": [ "simplestyle" ]\n}\n</c>\n\n<<plugin/simplestyle.h>>\n<c>\n#ifndef SIMPLESTYLE_H\n#define SIMPLESTYLE_H\n#include <QProxyStyle>\nQT_BEGIN_NAMESPACE\nclass QPalette;\nQT_END_NAMESPACE\nclass SimpleStyle : public QProxyStyle{\nQ_OBJECT\npublic:\nSimpleStyle() {};\nvoid polish(QPalette &palette);// Q_DECL_OVERRIDE;\n};\n#endif\n\n\n<<plugin/simplestyle.cpp>>\n#include <QtWidgets>\n#include "simplestyle.h"\nvoid SimpleStyle::polish(QPalette &palette) {\n    palette.setBrush(QPalette::Button, Qt::red);\n}\n</c>\n\n<<plugin/simplestyleplugin.h>>\n<c>\n#ifndef SIMPLESTYLEPLUGIN_H\n#define SIMPLESTYLEPLUGIN_H\n#include <QStylePlugin>\nQT_BEGIN_NAMESPACE\nclass QStringList;\nclass QStyle;\nQT_END_NAMESPACE\nclass SimpleStylePlugin : public QStylePlugin{\n Q_OBJECT\n Q_PLUGIN_METADATA(IID "org.qt-project.Qt.QStyleFactoryInterface" FILE "simplestyle.json")\npublic:\n SimpleStylePlugin() {}\n// QStringList keys() const;\n QStyle *create(const QString &key) Q_DECL_OVERRIDE;\n};\n#endif\n</c>\n\n<<plugin/simplestyleplugin.cpp>>\n<c>\n#include <QtWidgets>\n#include "simplestyleplugin.h"\n#include "simplestyle.h"\n//QStringList SimpleStylePlugin::keys() const{\n//    return QStringList() << "SimpleStyle";\n//}\nQStyle *SimpleStylePlugin::create(const QString &key){\n    if (key.toLower() == "simplestyle")\n        return new SimpleStyle;\n    return 0;\n}\n</c>\n\n<m>http://minhinc.42web.io/image/qt-slide-qpluginextended.png</m>\n\n\n<c>\n  ------+  Application\n  |                 +----- All QStylePlugin must be in dirctory named styles\n  |                 |\n  ------+  styles   |\n        |           V\n        |\n        +------ libstyleplugin.so\n        |\n        +------ libxxxx.so\n        |\n        +------ libyyyy.so\n</c>\n\nPlugin .so libraries can be located with funciton QcoreApplication::addLibraryPath(). It is similar to adding path to LD_LIBRARY_PATH environment variable. Styles plugin must be in the directory "styles" in the path provided through QcoreApplication::addLibraryPath()\n\n<h>\n*Creating plugin from scratch\n</h>\n\n<m>https://www.youtube.com/embed/wOMcuH0kQqY</m>\n\nLower level plugin has three parts.\na) Interface classes.\nb) Plugin interfaces extending the intefaces.\nc) Application instantiating the plugin and accessing it through inteface (plugin extending the interface).\n\na) Interface class\nMaking an application extensible through plugins involves the following steps:\n  -  Define a set of interfaces (classes with only pure virtual functions) used to talk to the plugins.\n  -  Use the Q_DECLARE_INTERFACE() macro to tell Qt\'s meta-object system about the interface.\n\n b) Plugin interface\n  - Declare a plugin class that inherits from QObject and from the interfaces that the plugin wants to provide.\n  - Use the Q_INTERFACES() macro to tell Qt\'s meta-object system About the interfaces.\n  - Export the plugin using the Q_PLUGIN_METADATA() macro.\n  - Build the plugin using a suitable .pro file.\n\nc) Application instantiating the plugin and using it through interfaces.\n  -  Use QPluginLoader in the application to load the plugins.\n  -  Use qobject_cast() to test whether a plugin implements a given interface.\n\nA plugin is loaded through QLoadPlugin::load() api which retruns the base class pointer and respective pointer is achieved through qObject_cast macro.\n<m>https://www.youtube.com/embed/cNLofeat7Ec</m>\n\na) Interface class\n<<plugin/textart.pro>>\n<c>\nTEMPLATE = lib\nCONFIG += plugin\nTARGET = textart\nHEADERS += basiceffectsplugin.h textartinterface.h\nSOURCES += basiceffectsplugin.cpp\nDESTDIR = .\n</c>\n\n<<plugin/textartinterface.h>>\n<c>\n#ifndef TEXTARTINTERFACE_H\n#define TEXTARTINTERFACE_H\n#include <QPixmap>\n#include <QString>\n#include <QStringList>\n#include <QFont>\n#include <QPen>\n#include <QBrush>\nclass TextArtInterface {\npublic:\n virtual ~TextArtInterface(){}\n virtual QStringList effects() const=0;\n virtual QPixmap applyEffect(const QString &effect,const QString& text, const QFont &font,\n         const QSize &size, const QPen& pen, const QBrush& brush)=0;\n};\nQ_DECLARE_INTERFACE(TextArtInterface,"com.software-inc.TextArt.TextArtInterface/1.0")\n#endif\n</c>\n\nb)Plugin interfae\n<<plugin/basiceffectsplugin.h>>\n<c>\n#ifndef BASICEFFECTSPLUGIN_H\n#define BASICEFFECTSPLUGIN_H\n#include <QObject>\n#include "textartinterface.h"\nclass BasicEffectsPlugin : public QObject, public TextArtInterface{\nQ_OBJECT\nQ_INTERFACES(TextArtInterface)\n/*Q_PLUGIN_METADATA(IID "com.software-inc.TextArt.TextArtInterface/1.0"\n            FILE "mymetadata.json") */\nQ_PLUGIN_METADATA(IID "com.software-inc.TextArt.TextArtInterface/1.0")\npublic:\n QStringList effects() const;\n QPixmap applyEffect(const QString &effect, const QString &text,\n                          const QFont &font, const QSize &size,\n                          const QPen &pen, const QBrush &brush);\n};\n#endif\n</c>\n\n<<plugin/basiceffectsplugin.cpp>>\n<c>\n#include <QStringList>\n#include <QFontMetrics>\n#include <QPainter>\n#include <QPainterPath>\n#include "basiceffectsplugin.h"\nQStringList BasicEffectsPlugin::effects() const{\n return QStringList()<< "Plain" << "Outline" << "Shadow";\n}\nQPixmap BasicEffectsPlugin::applyEffect(const QString &effect,\n const QString &text, const QFont &font, const QSize &size,\n const QPen &pen, const QBrush &brush){\n QFont myFont = font;\n QFontMetrics metrics(myFont);\n while ((metrics.width(text) > size.width() || metrics.height() > size.height())\n                      && myFont.pointSize() > 9) {\n  myFont.setPointSize(myFont.pointSize() - 1);\n  metrics = QFontMetrics(myFont);\n }\n QPixmap pixmap(size);\n QPainter painter(&pixmap);\n painter.setFont(myFont);\n painter.setPen(pen);\n painter.setBrush(brush);\n painter.setRenderHint(QPainter::Antialiasing, true);\n painter.setRenderHint(QPainter::TextAntialiasing, true);\n painter.setRenderHint(QPainter::SmoothPixmapTransform, true);\n painter.eraseRect(pixmap.rect());\n if (effect == "Plain")\n  painter.setPen(Qt::NoPen);\n else if (effect == "Outline") {\n  QPen pen(Qt::black);\n  pen.setWidthF(2.5);\n  painter.setPen(pen);\n } else if (effect == "Shadow") {\n  QPainterPath path;\n  painter.setBrush(Qt::darkGray);\n  path.addText(((size.width() - metrics.width(text)) / 2) + 3, (size.height() -\n                           metrics.descent()) + 3, myFont, text);\n  painter.drawPath(path);\n  painter.setBrush(brush);\n }\n QPainterPath path;\n path.addText((size.width() - metrics.width(text)) / 2, size.height() -\n                           metrics.descent(), myFont, text);\n painter.drawPath(path);\n return pixmap;\n}\n</c>\nc) Application instantiating the plugin\n<<app.pro>>\n<c>\nQT += widgets\nTEMPLATE = app\nTARGET = textartdialog\nINCLUDEPATH += . plugin\nHEADERS += tdialog.h\nSOURCES += main.cpp tdialog.cpp\n</c>\n\n<<tdialog.h>>\n<c>\n#ifndef TDIALOG_H\n#define TDIALOG_H\n#include <QDialog>\nstruct TextArtInterface;\nclass tdialog:public QDialog {\nQ_OBJECT\npublic:\n tdialog(QDialog *p=0);\nprivate:\n QList<TextArtInterface*> interfaces;\n};\n#endif\n</c>\n\n<<tdialog.cpp>>\n<c>\n#include <QApplication>\n#include <QVBoxLayout>\n#include <QListWidget>\n#include <QDir>\n#include <QPluginLoader>\n#include <QFont>\n#include <QListWidgetItem>\n#include <QPixmap>\n#include <QLinearGradient>\n#include "tdialog.h"\n\n#include "textartinterface.h"\ntdialog::tdialog(QDialog *p):QDialog(p){\n QString text="Qt Everywhere";\n QListWidget *listwidget;\n QDir plugindir;\n QVBoxLayout *vlt=new QVBoxLayout;\n vlt->addWidget(listwidget=new QListWidget);\n setLayout(vlt);\n listwidget->setViewMode(QListWidget::IconMode);\n listwidget->setMovement(QListWidget::Static);\n listwidget->setIconSize(QSize(200,60));\n (plugindir=QApplication::applicationDirPath()).cd("./plugin");\n foreach(QString filename, plugindir.entryList(QDir::Files)) {\n  QPluginLoader loader(plugindir.absoluteFilePath(filename));\n  if( TextArtInterface *interface=qobject_cast<TextArtInterface*>(loader.instance()))\n  interfaces.append(interface);\n }\n QLinearGradient gradient(0,0, listwidget->iconSize().width()/2,\n       listwidget->iconSize().height()/2);\n gradient.setColorAt(0.0, QColor("darkolivegreen"));\n gradient.setColorAt(1.0, QColor("lightgreen"));\n\n foreach(TextArtInterface *interface, interfaces) {\n  foreach (QString effect, interface->effects()) {\n   QListWidgetItem *item=new QListWidgetItem(effect, listwidget);\n   item->setData(Qt::DecorationRole, interface->applyEffect(effect,"Qt Everywhere",\n     QFont("Tw Cen Mt",listwidget->iconSize().height(),Qfont::Bold),\n      listwidget->iconSize(),QColor("darkseagreen"),gradient));\n  }\n }\n listwidget->setCurrentRow(0);\n}\n\n<<main.cpp>>\n#include <QApplication>\n\n#include "tdialog.h"\n\nint main(int argc, char* argv[]){\n QApplication a(argc, argv);\n tdialog td;\n td.show();\n return a.exec();\n}\n</c>\n\n<m>http://minhinc.42web.io/image/qt-slide-qpluginscratch.png</m>\n\n<h>\n*Linking to a plugin statically\n- creating static plugin\n- linking static plugin to application\n*Making application plugin-aware\n</h>\n\n- Creating static plugin\nStatic plugin can be created with CONFIG+=static entry in .pro file of the plugin.\n<<plugin/plugin.pro>>\n<c>\nTEMPLATE = lib\nCONFIG += plugin static\nDESTDIR = .\nTARGET = textart\nHEADERS += basiceffectsplugin.h textartinterface.h\nSOURCES += basiceffectsplugin.cpp\n</c>\n\nThis will generate libtextart.a library file.\n\n-linking static plugin to application\nApplication linking to the user static plugin library has to provide the library path and library name against LIBS config variable.\n\n<<app.pro>>\n<c>\nQT += widgets\nTEMPLATE = app\nTARGET = textartdialog\nLIBS += -Lplugin -ltextart\nINCLUDEPATH += . plugin\nHEADERS += tdialog.h\nSOURCES += main.cpp tdialog.cpp\n</c>\n\nIf library is Qt specific (i.e qjpeg) then it can be added through QTPLUGIN config variable.\n<c>\nQTPLUGIN += qjpeg\n            qgif\n            qkrcodecs\n</c>\n\nApplication has to include Q_IMPORT_PLUGIN in global space taking parameter of plugin class name\n\n<<main.cpp >>\n<c>\n#include <QtPlugin>\n#include <QApplication>\n#include "tdialog.h"\n\nQ_IMPORT_PLUGIN(BasicEffectsPlugin)\nint main(int argc, char* argv[]){\n QApplication a(argc, argv);\n tdialog td;\n td.show();\n return a.exec();\n}\n</c>\n\nFor Qt secific plugins (i.e qjpeg), Q_IMPORT_PLUGIN is implicitly added to the source file when QTPLUGIN is added to the .pro file\n\nSource code has to list the plugin through QPluginLoader::staticInstances() funciton\n<<tdialog.cpp>>\n<c>\n#include <QApplication>\n#include <QVBoxLayout>\n#include <QListWidget>\n#include <QDir>\n#include <QPluginLoader>\n#include <QFont>\n#include <QListWidgetItem>\n#include <QPixmap>\n#include <QLinearGradient>\n#include "tdialog.h"\n\n#include "textartinterface.h"\ntdialog::tdialog(QDialog *p):QDialog(p){\n QString text="Qt Everywhere";\n QListWidget *listwidget;\n QDir plugindir;\n QVBoxLayout *vlt=new QVBoxLayout;\n vlt->addWidget(listwidget=new QListWidget);\n setLayout(vlt);\n listwidget->setViewMode(QListWidget::IconMode);\n listwidget->setMovement(QListWidget::Static);\n listwidget->setIconSize(QSize(200,60));\n  foreach(QObject *plugin, QPluginLoader::staticInstances()){\n  if( TextArtInterface *interface=qobject_cast<TextArtInterface*>(plugin))\n  interfaces.append(interface);\n }\n QLinearGradient gradient(0,0, listwidget->iconSize().width()/2, listwidget->iconSize().height()/2);\n gradient.setColorAt(0.0, QColor("darkolivegreen"));\n gradient.setColorAt(1.0, QColor("lightgreen"));\n foreach(TextArtInterface *interface, interfaces) {\n  foreach (QString effect, interface->effects()) {\n   QListWidgetItem *item=new QListWidgetItem(effect, listwidget);\n   item->setData(Qt::DecorationRole, interface->applyEffect(effect,"Qt Everywhere",QFont("Tw Cen Mt",listwidget->iconSize().height(),QFont::Bold),listwidget->iconSize(),QColor("darkseagreen"),gradient));\n  }\n }\n listwidget->setCurrentRow(0);\n}\n</c>'
'10!ABS SBA!Graphics Views!ABS SBA!*Add custom item\n*Implement drag & drop on the item!ABS SBA!<h>\n*Graphics Views concept\n- Graphics scene\n- Graphics View\n- Graphics Items\n</h>\n\nGraphics View provides an item-based approach to model-view programming Several views can observe a single scene, and the scene contains items of varying geometric shapes.\n\nQGraphicsScene provides the Graphics View scene. The scene has the following responsibilities:\n - Providing a fast interface for managing a large number of items\n - Propagating events to each item\n - Managing item state, such as selection and focus handling\n - Providing untransformed rendering functionality; mainly for printing\n<c>\nQGraphicsScene scene;\nQGraphicsRectItem *rect = scene.addRect(QRectF(0, 0, 100, 100));\n\nQGraphicsItem *item = scene.itemAt(50, 50);\n// item == rect\n</c>\n\nScene Coordinate\nQGraphicsView provides the view widget, which visualizes the contents of a scene. You can attach several views to the same scene, to provide several viewports into the same data set.\n<c>\nQGraphicsScene scene;\nmyPopulateScene(&scene);\n\nQGraphicsView view(&scene);\nview.show();\n</c>\n\nQGraphicsItem is the base class for graphical items in a scene. Graphics View provides several standard items for typical shapes, such as rectangles (QGraphicsRectItem), ellipses (QGraphicsEllipseItem) and text items (QGraphicsTextItem),\n\nView Coordinate\n\nQGraphicsItem supports the following features:\n - Mouse press, move, release and double click events, as well as mouse hover events, wheel events, and context menu events.\n - Keyboard input focus, and key events\n - Drag and drop\n - Grouping, both through parent-child relationships, and with QGraphicsItemGroup\n - Collision detection\n\n<c>\nQGraphicsItem\n\n     / \\\n      -\n      |\n\n\nvirtual void paint(QPainter* painter,const QStyleOptionGraphicsItem* option,QWidget* widget=0)=0\n</c>\n\nItem coordinate\n\nQGraphicsWidget\nThe QGraphicsWidget class is the base class for all widget items in a  QGraphicsScene.\n\nQGraphicsWidget is an extended base item that provides extra functionality over QGraphicsItem. It is similar to QWidget in many ways:\n\n - Provides a palette, a font and a style().\n  - Has a defined geometry().\n  - Supports layouts with setLayout() and layout().\n  - Supports shortcuts and actions with grabShortcut() and insertAction()\n\nQGraphicsLayout\nCoordinate Mapping\n - Inorder to find item in view cordinate\n QGraphicsView::mapToScene(),followed by GraphicsScene::itemAt()\n -In order to know where in the viewport an item is located,  QGraphicsItem::mapToScene() on the item, then QGraphicsView::mapFromScene() on the view\n -In order to find what items are inside a view ellipse, pass a QPainterPath to mapToScene(), and then pass the mapped path to QGraphicsScene::items()\n\n<h>\n*Creating custom items\n</h>\n\n<h>\n*OpenGL scene project model/view architecture\n</h>\n\n1. set up your tripod and point the camera at the scene (viewing transformation).\n2. Arrange the scene to be photographed into the desired component (modeling transformation).\n3. choose the camera lens or adjust the zoom (projection transformation).\n4. Determine how large you want the final photograph to be - for example, you might want it enlarged (viewport transformation).\n\n<c>\n                                                       ( )\n                                                   . .\n                                                 .  .\n                                          .   .   .\n     Viewing                        .   .  .    .   Positioning the\n                             .      .   .     .     viewing volume in\n                      .         .    .      .       the world\n               .             .   .        .\n              -------------------       .\n              |       .         |     .\n              |    .            |   .\n              | .               | .\n              -------------------\n\n\n                                                       ( )\n                                                   . .\n                                               . .  .\n                                          .   .   .\n                                    .   .  .    .\n    Modeling                 .      .   .     . Positiioning the\n                      .         .    .      .   models in the world\n               .             .    .       .\n              -------------------       .\n              |        /xx     |     .\n              |    .  xxxx/    |   .\n              | .      xx/     | .\n              -------------------\n\n                                                       ( )\n                                                   . .\n                                                 .  .\n                                          .   .   .\n                                   ----------   .\n    Projection               -      |   -   | .\n                      -         -   |-      |\n               -             -   -  ---------\n              -------------------       -      Determining the\n              |       -         |     -        shape of the\n              |    -            |   -          viewing volume\n              | -               | -\n              -------------------\n\n\n\n\n    Viewport\n              ----------------------------\n              |              .           |\n              |          . xxxxx .       |\n              |       . xxxxxxxxxxx .    |\n              |     . xxxxxxxxxxxxxxx .  |\n              |       . xxxxxxxxxxx .    |\n              |          . xxxxx .       |\n              |              .           |\n              ----------------------------\n</c>\n<h>\n*Image based rendering with graphics views\n</h>'
'11!ABS SBA!XML and JSON Parsing!ABS SBA!*Implement writing and reading\n through xml file!ABS SBA!<h>\n*Basic XML APIs, QXmlStreamReader,\n  QXmlStreamWriter\n</h>\n\n<h>\n*XML Patterns : XPath, XQuery,\n  QtXmlPatterns and XML Schema\n</h>\n\n</h>\n*JSON\n</h>\n\n<h>\n*Implement writing and reading\n through xml file\n</h>'
'12!ABS SBA!Inter process Communication(IPC)!ABS SBA!*Create and read data from subprocess\n*Use QSharedMemory to make singleton process!ABS SBA!<h>\n*Running processes\n - Parent/Child relationships\n - Message passing\n - popen\n</h>\n\nclass\n<c>\n-----\nQProcess\n----\n\n  QObject\n    / \\\n     -\n     |\n QIODevice\n    / \\\n     -\n     |\n <b>QProcess</b>\n</c>\n\n\n - Parent Child relationship\nQProcess is a QIODevice which can be written and read through QTextStream and QDataStream.\nQProcess maintains states\n<c>\n                   +-----------+<cc>Emits finished() and</cc>\n                   |Not Running|<cc>stateChanged(NotRunning)</cc>\n                   +-----------+<cc>after running</cc>\n                      ^      ^\n                      |      |\n           <cc> process terminates</cc>|      |<cc>starts</cc>\n                      |      |\n                      |      |\n             +--------+      +------------+\n             |                            |\n             v                            v\n        +-------+      <cc>process start up</cc>       +--------+<cc>Emits</cc>\n        |Running|<|--------------------|Starting|<cc>stateChanged(Starging)</cc>\n        +-------+                      +--------+\n        <cc>Emits started</cc>\n        <cc>and</cc>\n        <cc>StateChanged(Running)</cc>\n</c>\nQProcess start with start() system call where it can be monitored.\n\n<c>\nQProcess process;\nprocess.start( "command" );\nprocess.waitForFinished();\nQTextStream stream( &process );\nQString output = stream.readAll();\n</c>\n\n<b>Signals</b>\n<c>\nvoid finished(int exitCode, QProcess::ExitStatus exitStatus)\nvoid readyReadStandardError()\nvoid readyReadStandardOutput()\nvoid started()\nvoid stateChanged(QProcess::ProcessState newState)\n</c>\n\n<b>Important functions</b>\n<c>\nvoid kill()\nvoid terminate()\nint exitCode() const\nQProcess::ExitStatus exitStatus() const\nvirtual qint64 bytesAvailable() const\nvirtual bool canReadLine() const\n</c>\n\n<b>Synchronous functions</b>\n<c>\nbool waitForStarted(int msecs = 30000) //returns when the started() signal has been emitted, i.e., the process has started successfully (or has failed to start)\nvirtual bool waitForReadyRead(int msecs = 30000)\nvirtual bool waitForBytesWritten(int msecs = 30000)\nbool waitForFinished(int msecs = 30000)\n</c>\n\n<b>Static functions</b>\n<c>\nint execute(const QString &program, const QStringList &arguments)\nint execute(const QString &command)\n</c>\nIf you are not interested in processing the output of the external process, nor in supplying input to it, use the static convenience method QProcess::execute() that starts the process, waits for its termination, and returns:\n<cc>\nQStringList arguments;\narguments << "Argument1" << "Argument2";\nQProcess::execute("do_it_now", arguments);\n// won\'t get here until do_it_now terminates\n</cc>\n\n<c>\nbool startDetached(const QString &program, const QStringList &arguments, const QString &workingDirectory = QString(), qint64 *pid = Q_NULLPTR)\nbool startDetached(const QString &command)\n</c>\nUse QProcess::startDetached() instead if you want the child process to detach from the current one. This method will not wait for termination, and the child process will not be terminated when the current process terminates ("fire and forget").\n\n<c>\nQString nullDevice()\nQStringList systemEnvironment()\n</c>\n\n - Message passing\nsince QProcess is child of current process message can be passed to the child with writeData\n<c>\nqint64 QProcess::writeData(const char *data, qint64 len)\n</c>\nin synchronous call parent can wait for data written through\n<c>\nvirtual bool waitForBytesWritten(int msecs = 30000)\n</c>\n\nsimilarily data can be read back through\n<c>\nvirtual qint64 readData(char *data, qint64 maxlen)\n</c>\ncomplete data can be read from the channel with\n<c>\nQByteArray readAllStandardOutput()\n</c>\n\n - popen\nLike popen in unix when parent process can read stdout/stderr child data through FILE* and can also write through FILE*, in QProcess different channels like\n<c>\nQProcess::StandardOutput\nQProcess::StandardError\n</c>\nof child can be read in parent process.\n\n<b>channel mixing</b>\nchild\'s stdout/stderr channels can be mixed to stdout\n<c>\nvoid QProcess::setProcessChannelMode(ProcessChannelMode mode)\n</c>\nmode can be <c>QProcess::MergedChannels</c>\n\n<h>\n*Shared memory with Qt\n</h>\n<c>\n                      -----------------\n          +-----------| Shared Memory |--------+\n          |           -----------------        |\n          |                                    |\n          |<cc>Mapped into </cc>                             |<cc>Mapped into</cc>\n          |                                    |\n    ------------------                  --------------------\n    |Process Address1|                  | Process Address 2|\n    ------------------                  --------------------\n</c>\nclass\n------\n<c>\nQSharedMemory\nQSystemSemaphore\n</c>\n-----\n      QObject         QSystemSemaphore\n        / \\\n          -\n         |\n   <b>QSharedMemory</b>\nA shared memory segment is identified by a QString key. This key can be set in the constructor or via\nQSharedMemory::setKey() .\nAn attempt to create() a shm segment that already exists, or to attach() to a segment that does not exist will result in\nan error.\nThe only way to check if a memory segment with a given key exists is to try to attach to it.\n\nNote:- In HP-UX only one attachement is allowed per process so \tQSharedMemory can not be used accross multiple threads\n\n<b>Creation</b>\n<c>\nQSharedMemory shm;\nshm.setKey("MyShm");\nif( !shm.create( 4242 /*bytes*/, QSharedMemory::ReadWrite ) ) {\n/* failure, error details available in shm.error()/shm.errorString() */\n}\n/* create() also attaches to memory, so we can use it right away */\nshm.lock();\nvoid* data = shm.data();\n/* ... do interesting stuff with data... */\nshm.unlock();\n</c>\n\n<b>Destruction</b>\n<c>\n/* Detach from memory, if we\'re the last process to do so, the memory is released */\nshm.detach();\n</c>\nThe QSharedMemory instance should be kept around as long as we want to keep the memory.\n\n<b>Attach</b>\n<c>\nQSharedMemory shm;\nshm.setKey("MyShm");\nif( !shm.attach( QSharedMemory::ReadWrite ) ) {\n/* failure, error details available in shm.error()/shm.errorString() */\n}\nshm.lock();\nvoid* data = shm.data();\n/* ... do interesting stuff with data... */\nshm.unlock();\nshm.detach()\n</c>'
'13!ABS SBA!Multithreading!ABS SBA!*Producer/Consumer with QWaitCondition,\nQSemaphore, QMutex\n*Passing object ownership among threads!ABS SBA!<h>\n*Multithreading primitives\n</h>\n\nmultithreading is young technique in Qt and still far from mainstream programming.\nmutlithreading is used when a programming can be broken into several independent tasks that needs to be executed asynchornously.\ndependent task needs synchronization to avoid data sharing, deadlock and race conditions issues.\n\nclass\n--------\n<c>\n\nQThread, QThreadPool, QRunnable // Parallel tasks\nQtConcurrent\n\nQThreadStorage //Thread storage\n\nQAtomicInt, QAtomicPonter,QWaitCondition, QMutex, QReadWriteLock, QSemaphore //Synchornization\n</c>\n-----\n<c>\n\n  QObject\n    / \\\n     -\n     |\n     +------------+\n     |            |\n<b>QThread</b> <b>QThreadpool</b>\n</c>\n\nThread model\n<c>\n        started() o------+\n       finished()o-----+ |\n                       | |\n                      -----------\n                      |         |----o start()\n                      |         |    .\n                      |         |    .<<calls>>\n                      | QThread |    .\n                      |         |    v\n                      |         |----o run() <--- Entry point function\n                      |         |\n                      -----------\n                         | | | |\n                         | | | +----o idealThreadCount()\n                         | | +-----o setThreadPrioriy()\n                         | +------o isFinished()/isRunning()\n                         +-------o wait()\n</c>\nsignals\n-------\n<c>\nvoid finished()\nvoid started()\n</c>\n\n<h>\n*Creating Thread\n</h>\n\n<b>Creating and Starting a thread</b>\n1)Subclass QThread\n ----------------\n                 | QThread     |<-- call start() to enter thread in ::run()\n                  ----------------\n                  | run=0;         |\n                  ----------------\n                            /\n                             _\n                             |\n                  --------------\n                 |    mythread |\n                 ------------------\n                  |   run()            | <--- call exec() in run to have event loop\n                  ------------------\n\n2)call start() method\n3)It creates another event queue, that can be run as exec()\n4)Implement code in run() function\n\n<c>\nQThread::run(){\n.\n.\nexec();\n}\n</c>\n\n<b>wait for threads to end</b>\n<c>\nbool isFinished() const\nbool isRunning() const\n</c>\n\ncall <c>wait</c> method to wait for thread to finish similar pthread_join\n<c>\nbool wait(unsigned long time = ULONG_MAX)\n</c>\n\nA thread can stop execution temporarily by calling\n<c>\nvoid msleep(unsigned long msecs)\nvoid sleep(unsigned long secs)\nvoid usleep(unsigned long usecs)\n</c>\nfrom within run().\n\nA thread can terminate by calling <c>exit()</c>\n<c>\nvoid exit(int returnCode = 0)\n</c>\n\nA object can be moved to another thread with\n<c>\nvoid QObject::moveToThread(QThread *targetThread)\n</c>\n\n<b>cross-Thread Signals/Slots</b>\n<c>\nQt::QueuedConnection:\nconnect( sender, SIGNAL(...), receiver, SLOT(...),\n<pre style="color:#ff00">Qt::QueuedConnection</pre> );\n</c>\n...\n// emit the signal on the sender thread as usual\nThis technique requires that the receiving thread (but not necessarily the sending one) has an event loop running.\nIf you do not specify Qt::QueuedConnection, the default is Qt::AutoConnection, which will do the right thing if emitter and receiver are on different threads.\n\nThere is one additional connect method, namely BlockingQueuedConnection. This will make the sender block until the receiving slots have been executed.\n-Warning: Overuse of this can easily result in deadlocks.\n\n<b>QThreadPool</b>\n<c>QThreadPool</c> is a low-level class for managing threads.\nA <c>QThreadPool</c> maintains a pool of up to <c>QThreadPool::maxThreadCount()</c> threads (default:\n<c>QThread::idealThreadCount()</c>\n\n--------------------\n                    | QRunnable     |\n                     -------------------\n                    |        run()=0      |\n                     -------------------\n                              /\n                                -\n                                |\n                    --------------------\n                    | task                    | <-- add this task to QThreadPool\n                    --------------------\n                    | run()                   |  <-- QThreadPool::start() would enter here\n                     --------------------\n<b>QRunnable</b>\nTasks that can be run on the thread pool implement:\n<c>\nclass QRunnable {\npublic:\nvirtual void run() = 0;\n};\n</c>\n\nThere is one global QThreadPool instance,\n<c>QThreadPool::globalInstance()</c>, which is also used by QtConcurrent to schedule its tasks.\nQRunnable tasks can be added to QThreadPool like\n\n<c>\nrunnabletask1 *task1 = new helloworldtask();\nrunnabletask2 *task2 = new helloearthtask();\nQThreadPool::globalInstance()->start(task1);\nQThreadPool::globalInstance()->start(task2);\n</c>\n\nexample\n-------\n<cs>\nconcepts.pro\nQT       += core\nTARGET = concepts\nTEMPLATE = app\nHEADERS += calculator.h workerthread.h threadcontroller.h runnabletask.h\nSOURCES += concepts.cpp\n\n<c><calculator.h></c>\n#ifndef CALCULATOR_H\n#define CALCULATOR_H\n#include <QObject>\n#include <QDebug>\n\nclass calculator : public QObject {\n Q_OBJECT\npublic:\nvoid factorial(int a) {qDebug()<<"emiting signal";emit sig_factorial(a);}\npublic slots:\nvoid on_sigfactorial(int a) {\nqDebug()<<"calculating factorial of"<<a;\n}\nsignals:\nvoid sig_factorial(int);\n};\n#endif\n\n<c><workerthread.h></c>\n#include "calculator.h"\n#include <QThread>\n#include <QDebug>\n#include <QCoreApplication>\nclass workerthread: public QThread {\nQ_OBJECT\npublic:\nworkerthread(calculator* calcp){calc=calcp;}\nvoid run() {\n qDebug()<<"workerthread started";\n calc->moveToThread(QCoreApplication::instance()->thread());\n /*calculator calc;\n QObject::connect(&calc, &calculator::sig_factorial,&calc,&calculator::on_sigfactorial);\n calc.factorial(10);*/\n // QThread::exec();\n }\n calculator* calc;\n};\n\n<c><threadcontroller.h></c>\n#include <QThread>\n#include "workerthread.h"\n\nclass threadcontroller {\n//QThread mythread;\nworkerthread mythread;\npublic:\n//    QThread& getthread() { return mythread;}\nworkerthread& getthread(){ return mythread;}\n~threadcontroller(){mythread.quit();mythread.wait();}\n};\n\n<c><runnabletask.h></c>\n#include <QRunnable>\n#include <QDebug>\n\nclass helloworldtask : public QRunnable {\npublic:\n void run() {\n  qDebug()<< "Hello world"<< QThread::currentThread();\n }\n};\nclass helloearthtask : public QRunnable {\npublic:\n void run() {\n  qDebug()<< "Hello Earth"<< QThread::currentThread();\n }\n};\n\n<c><concepts.cpp></c>\n//QT (+ core)TARGET (concepts) TEMPLATE (app) INCLUDES (+calcualtor.h) SOURCES (+concepts.cpp)\n#include <QCoreApplication>\n#include <QThread>\n#include <QThreadPool>\n#include "calculator.h"\n#include "threadcontroller.h"\n#include "runnabletask.h"\nint main(int argc, char *argv[]) {\nQCoreApplication a(argc,argv);\n//threadcontroller anotherthread;\ncalculator calc;\nworkerthread anotherthread(&calc);\n//calc.moveToThread(&anotherthread.getthread());\ncalc.moveToThread(&anotherthread);\nQObject::connect(&calc,&calculator::sig_factorial,&calc,&calculator::on_sigfactorial);\n//anotherthread.getthread().start();\nanotherthread.start();\ncalc.factorial(10);\n\n// ThreadPool\n/*qDebug()<<"ideal thread count"<<QThread::idealThreadCount();\nqDebug()<<"active thread count"<<QThreadPool::globalInstance()->activeThreadCount();\nhelloworldtask *task1 = new helloworldtask();\nhelloearthtask *task2 = new helloearthtask();\nQThreadPool::globalInstance()->start(task1);\nQThreadPool::globalInstance()->start(task2);*/\nreturn a.exec();\n}\n</cs>\n\n<b>QCuncurrent</b>\nThe QtConcurrent namespace make it possible to write multi-threaded programs without using low-level threading primitives such as mutexes, read-write locks, wait conditions, or semaphores.\nPrograms written with QtConcurrent automatically adjust the number of threads used according to the number of processor cores available. This means that applications written today will continue to scale when deployed on multi-core systems in the future.\n\n------------\nFunctions\n-----------\n<c>\nQtConcurrent::map() applies a function to every item in a container, modifying the items in-place.\nQtConcurrent::mapped() is like map(), except that it returns a new container with the modifications.\nQtConcurrent::mappedReduced() is like mapped(), except that the modified results are reduced or folded into a single result.\nQtConcurrent::filter() removes all items from a container based on the result of a filter function.\nQtConcurrent::filtered() is like filter(), except that it returns a new container with the filtered results.\nQtConcurrent::filteredReduced() is like filtered(), except that the filtered results are reduced or folded into a single result.\nQtConcurrent::run() runs a function in another thread.\nQFuture represents the result of an asynchronous computation.\nQFutureIterator allows iterating through results available via QFuture.\nQFutureWatcher allows monitoring a QFuture using signals-and-slots.\nQFutureSynchronizer is a convenience class that automatically synchronizes several QFutures.\n</c>\n\n\n <b>::run()</b>\n::run() function runs a function \'QString functionReturningAString()\' in another thread.\n<c>\nextern QString functionReturningAString();\nQFuture<QString> future = QtConcurrent::run(functionReturningAString);\n...\nQString result = future.result();\n</c>\nclass objects, first argument must be const refrence to class object or pointer to object. const refrenct is required for const members, pointer is for non const members.\n\nClass member Const reference;\n// call \'QList<QByteArray>  QByteArray::split(char sep) const\' in a separate thread\n<c>\nQByteArray bytearray = "hello world";\nQFuture<QList<QByteArray> > future = QtConcurrent::run(bytearray, &QByteArray::split, \',\');\n...\nQList<QByteArray> result = future.result();\n</c>\n\nPointers: -\n// call \'void QImage::invertPixels(InvertMode mode)\' in a separate thread\n<c>\nQImage image = ...;\nQFuture<void> future = QtConcurrent::run(&image, &QImage::invertPixels, QImage::InvertRgba);\n...\nfuture.waitForFinished();\n// At this point, the pixels in \'image\' have been inverted\n</c>\n\n\n <b>QFutureWatcher</b>\nQFutureWatcher class allows monitoring a QFuture using signals and slots.\n// Instantiate the objects and connect to the finished signal.\n<c>\nMyClass myObject;\nQFutureWatcher<int> watcher;\nconnect(&watcher, SIGNAL(finished()), &myObject, SLOT(handleFinished()));\n\n// Start the computation.\nQFuture<int> future = QtConcurrent::run(...);\nwatcher.setFuture(future);\n</c>\n\n <b>::map()</b>\nQtConcurrent::mapped() takes an input sequence and a map function. This map function is then called for each item in the sequence, and a new sequence containing the return values from the map function is returned.\nThe map function must be of the form:\n\nU function(const T &t);\nT and U can be any type (and they can even be the same type), but T must match the type stored in the sequence. The function returns the modified or mapped content.\n<c>\nQImage scaled(const QImage &image)\n{\n    return image.scaled(100, 100);\n}\nQList<QImage> images = ...;\nQFuture<QImage> thumbnails = QtConcurrent::mapped(images, scaled);\n</c>\n\n <b>QtConcurrent::mappedReduced()</b>\n QtConcurrent::mappedReduced() is similar to QtConcurrent::mapped(), but instead of returning a sequence with the new results, the results are combined into a single value using a reduce function.\n\nThe reduce function must be of the form:\n\nV function(T &result, const U &intermediate)\nT is the type of the final result, U is the return type of the map function. Note that the return value and return type of the reduce function are not used.\n\n<c>\nvoid addToCollage(QImage &collage, const QImage &thumbnail)\n{\n    QPainter p(&collage);\n    static QPoint offset = QPoint(0, 0);\n    p.drawImage(offset, thumbnail);\n    offset += ...;\n}\n\nQList<QImage> images = ...;\nQFuture<QImage> collage = QtConcurrent::mappedReduced(images, scaled, addToCollage);\n</c>\n\ncollage is result where as thumbnail in addToCollage is intermediate\n\n<h>\n*Synchronizing threads\n -QMutex\n -QWaitCondition\n -QSemaphore\n -QReadWriteLock\n -Producer/Consumer scenario\n</h>\n\nQMutex\n      ---------\n      |QMutex |---o lock/unlock()\n      |       |---o tryLock()\n      ---------\n\nQMutexLocker - autoPtr class\n      --------------\n      |QMutexLocker|----o lock(QMutex*)\n      --------------\n\nQWaitCondition\n       ----------------\n       |QWaitCondition|----o wait()\n       ----------------\n\nQWaitCondition::wait() lets a thread wait for a certain event.\n o You can specify a maximum waiting time.\n o You must pass a locked QMutex, to atomically go from locked state to wait state. The mutex will be automatically locked before the thread is woken.\n o Wake one (random) thread waiting on a wait condition with\n<c>QWaitCondition::wakeOne()</c> and all waiting threads with\n<c>QWaitCondition::wakeAll()</c>.\n\nexample\n<cs>\nQT+=core\nTEMPLATE = app\nTARGET = produceconsumer\nINCLUDEPATH += .\n\n# Input\nSOURCES += main.cpp\nCONFIG+=console\n\n<main.cpp>\n#include <QCoreApplication>\n#include <QThread>\n#include <QWaitCondition>\n#include <QMutex>\n#include <QDebug>\n\nQWaitCondition consumer;\nQWaitCondition producer;\nQMutex mutex;\nint count=0;\nint maxcount=4;\n\nclass workerthread:public QThread {\npublic:\n workerthread(QObject* parent=NULL):QThread(parent){};\nvoid run() {\n while(1) {\n  mutex.lock();\n  if(!count)\n   producer.wait(&mutex);\n  mutex.unlock();\n  QThread::msleep(1000);\n  mutex.lock();\n  count--;\n  qDebug()<<"worker consumed" << count;\n  consumer.wakeAll();\n  mutex.unlock();\n }\n}\n};\nclass masterthread:public QThread {\npublic:\n    masterthread(QObject* parent=NULL):QThread(parent){};\n void run() {\n  while(1){\n   mutex.lock();\n   if(count==maxcount)\n    consumer.wait(&mutex);\n   mutex.unlock();\n   QThread::msleep(1000);\n   mutex.lock();\n   count++;\n   qDebug()<<"master thread produced"<<count;\n   producer.wakeAll();\n   mutex.unlock();\n }\n}\n};\nint main(int argc, char *argv[]) {\nQCoreApplication a(argc,argv);\nmasterthread mthread;\nworkerthread wthread;\nmthread.start();\nwthread.start();\nmthread.wait();\nwthread.wait();\nreturn a.exec();\n}\n</cs>\n\n<b>Semaphore</b>\nSemaphores\n o Semaphores (QSemaphore) are generalized mutexes.\n o While a mutex can only be locked once at a time, a semaphore can be locked n times before it will refuse further locks. This is useful when protecting many identical resources.\n o The maximum number of locks ("resources") is specified in the constructor.\n o You lock a semaphore with QSemaphore::acquire(), specifying the number of resources (locks) you want. If not enough resources are available, the call will block until all requested resources can be locked.\n o release() frees the specified number of resources.\n o tryAcquire(int n=1) tries to get the specified number of resources; returns false if it does not succeed.\n o tryAcquire(int n, int timeout) will wait for timeout milliseconds before giving up on getting the resources.\n o available() returns the number of available resources (but remember that this can change at any time, so the result is not very useful).\n\n<cs>\nQT+=core\nTEMPLATE = app\nTARGET = produceconsumer\nINCLUDEPATH += .\n\n# Input\nSOURCES += main.cpp\nCONFIG+=console\n\n<c><main.cpp></c>\n#include <QCoreApplication>\n#include <QThread>\n#include <QSemaphore>\n#include <QMutex>\n#include <QDebug>\n\nint count=0;\nint maxcount=4;\nQSemaphore consumer;\nQSemaphore producer(maxcount);\n\nclass workerthread:public QThread {\npublic:\n workerthread(QObject* parent=NULL):QThread(parent){};\nvoid run() {\n while(1) {\nconsumer.acquire();\ncount--;\nqDebug()<<"worker thread consumed"<<count;\nQThread::msleep(1000);\nproducer.release();\n}\n}\n};\nclass masterthread:public QThread {\npublic:\n masterthread(QObject* parent=NULL):QThread(parent){};\n void run() {\n  while(1){\n   producer.acquire();\n   count++;\n   qDebug()<<"master thread produced"<<count;\n   QThread::msleep(1000);\n   consumer.release();\n  }\n }\n};\nint main(int argc, char *argv[]) {\nQCoreApplication a(argc,argv);\nmasterthread mthread;\nworkerthread wthread;\nmthread.start();\nwthread.start();\nmthread.wait();\nwthread.wait();\nreturn a.exec();\n}\n</cs>\n\n<b>Read/Write Locks</b>\n o Qt class for this scenario: QReadWriteLock, with methods lockForRead() and lockForWrite(), as well as unlock().\n o tryLockForRead() and tryLockForWrite() exist as well.  (also with an optional timeout).\n o QReadLocker and QWriteLocker are resource acquisition classes much like QMutexLocker.\n\n<h>\n*Thread local storage\n</h>\n\n<b>Thread-local data</b>\n o General rule: static variables are always global, local ("automatic") variables are always thread-local.\n o Sometimes, you may need to have data that is local to a thread, but you can\'t make it function-local. For this purpose, you can use QThreadStorage\n o QThreadStorage is a template class taking the data type to store as it\'s template argument, e.g.  QThreadStorage<int*>.\n\n o Use setLocalData() to store data, localData() to fetch data, and hasLocalData() to test if any data has been set.\n o Due to compiler limitations, QThreadStorage can currently only store pointers, and the data must be created on the heap, as QThreadStorage takes ownership of it and deletes it as necessary.\n\nCaveats\n\nThe QThreadStorage destructor does not delete per-thread data. QThreadStorage only deletes per-thread data when the thread exits or when setLocalData() is called multiple times.\nThe QThreadStorage can be used to store data for the main() thread. QThreadStorage deletes all data set for the main() thread when QApplication is destroyed, regardless of whether or not the main() thread has actually finished.'
'14!ABS SBA!Web Kit!ABS SBA!*Execute javascript through QWebView!ABS SBA!<h>\n*Qt Web-Kit Architecture\n</h>\n\n<h>\n*Views, Frame and Page\n</h>\n\n<h>\n*Qt graphics view framework in web-kit\n</h>\n\n<h>\n*Qml webkit objects\n</h>\n\n<h>\n*Execute javascript through QWebView\n</h>'
'15!ABS SBA!Databases!ABS SBA!*Create mysql database to add row!ABS SBA!<h>\n*Connecting to DB\n</h>\n\n<h>\n*Query, Viewing\n</h>\n\n<h>\n*Editing records\n</h>\n\n<h>\n*Tabular Data Presentation\n</h>\n\n<h>\n*Create mysql database to add row\n</h>'
'16!ABS SBA!Internationalization & Localization(I18N L10N)!ABS SBA!*Use languate tool to create\nlocale\n*Use I18N api to read user input\nlocale language!ABS SBA!<h>\n*I18N & L10N concepts\n</h>\n\n<h>\n*Working with Unicode\n</h>\n\n<h>\n*Multi language Support\n</h>\n\n<h>\n*Making Translation aware Applications\n</h>\n\n<h>\n*Dynamic Language Switching\n</h>\n\n<h>\n*Translating Applications\n</h>\n\n<h>\n*Qt supported tools on I18N an L10N\n</h>\n\n<h>\n*Use languate tool to create locale\n</h>\n\n<h>\n*Use I18N api to read user input\n locale language\n</h>'
'17!ABS SBA!Networking!ABS SBA!*Write ftp client using QNetworkAccessManager!ABS SBA!<h>\n*Socket programming\n - TCP/UDP sockets\n - SSL sockets\n</h>\n\n<h>\n*http ftp protocol\n</h>\n\n<h>\n*QNetworkAccessManager, QNetworkReply,\nQNetworkRequest\n</h>\n\n<h>\n*Write ftp client using QNetworkAccessManager\n</h>'
'18!ABS SBA!Drag & Drop!ABS SBA!*Implement drag and drop between \nQListWidgets!ABS SBA!<h>\n*Enabling Drag and Drop\n</h>\n\n<h>\n*Supporting Custom Drag Types\n</h>\n\n<h>\n*Clipboard Handling\n</h>\n\n<h>\n*Implement drag and drop between\nQListWidgets\n</h>'
'19!ABS SBA!Deployment and Testing!ABS SBA!!ABS SBA!<h>\n*Deployment\n</h>\nStatic Linking\nMechanics: Everything the application needs is pulled from the library into the binary.\n o No extra binary to ship.\n o Advantage: No version conflicts.\n o Disadvantage: Bugfixes in the library require recompilation\n o Disadvantage: Library code is not shared between different Qt applications.\n o Disadvantage: Qt plugins (codecs, styles, image formats, etc.) do not work.\n\nDynamic Linking against Private Library Copy\nMechanics: Qt code is stored in a separate binary, which is combined with the application at run time to form the final executable,i.e dll and so files\n\nTo avoid conflicts with other installed Qt libraries, use -rpath, or a wrapper script that sets LD_LIBRARY_PATH (Unix/Linux) or PATH (Windows) before calling the real application, e.g.:\n#!/bin/sh\nMYAPPDIR=/opt/myapp\nLD_LIBRARY_PATH=$MYAPPDIR/lib:$LD_LIBRARY_PATH\nexport LD_LIBRARY_PATH\nexec $MYAPPDIR/bin/myapp\n\nDynamic Linking Against System\'s Qt (Unix only)\n o Bugfixes in the library do not require recompilation.\n o Updates to Qt are shipped by the operating system vendor.\n o Library code is shared between different Qt applications (esp. useful when targeting the KDE desktop).\n o Disadvantage: Choice of Qt version and configuration constrained by lowest common denominator of what the target distributors provide (Linux distributors are pretty uniform, though).\n o Disadvantage: Some Unix vendors do not provide a system Qt.\n\n<h>\n*Development Tools of Linux\n</h>\n\nGDB - GNU Debugger\n o GDB is a free debugger for Linux and UNIX\n o GDB is a command-line tool, but GUI frontends exist (e.g., DDD and kdbg)\n  o Requirements\n  o Build Qt and application with debug information.\n  o Qmake projects:\n  CONFIG+=debug\n  o Rebuild project:\n  make clean && make && make install\n\n\nValgrind - Profiler\n  o Valgrind is a free high-quality debugger/profiler tool for Linux. It support X86, AMD64, PPC32, and PPC64\n  o Many "skins" available: memcheck, cachegrind, massif and helgrind\n  o Valgrind is easy to use - no recompilation, no relinking, and no modification of source code.\nexample\n  valgrind -tool=memcheck myapp\n  <command-line-argument> This will print out information about access to unallocated memory, mismatching new/delete etc. on the console.\n\n  o Consider the following piece of code\n<c>\nconst char* str = "Hello World!";\nchar* copy = (char*)new char[strlen(str)];\nstrcpy(copy,str);\ndelete copy;\n</c>\nThe array allocated for the copy of the string is one byte too short to contain the string plus the\ntrailing null. This code may or may not crash when writing one byte past the end of the char array. In some cases, it does not crash, but the code is clearly wrong anyway.\nThe other error is that memory allocated with new[] is deallocated with delete and not delete[], as it should have been!\n\nValgrind - an example\n o Valgrinding the code on the previous page yields:\n  ==12294== Invalid write of size 1\n  ==12294== at 0x4002178E: strcpy (mac_replace_strmem.c:174)\n  ==12294== by 0x8048672: main (main.cpp:5)\n  ...\n  ==12294== Mismatched free() / delete / delete []\n  ==12294== at 0x40028ED7: __builtin_delete (vg_replace_malloc.c:244)\n  ==12294== by 0x40028EF5: operator delete(void*) (vg_replace_malloc.c:253)\n  ==12294== by 0x8048680: main (main.cpp:6)\n  ...\n  ==12294== Address 0x43E9C43C is 0 bytes inside a block of size 12 alloc\'d\n  ==12294== at 0x40028D70: __builtin_vec_new (vg_replace_malloc.c:203)\n  ==12294== by 0x40028DC7: operator new[](unsigned) (vg_replace_malloc.c:216)\n  ==12294== by 0x804865E: main (main.cpp:4)\n\nSo valgrind finds both of our problems. "Invalid write of size 1" means that we write one byte into unallocated memory (the trailing null of the string), "Mismatched free()/delete/delete[]" means that we are freeing memory with a function or operator that does not match the one that was used to allocate it-and it even tells us where that particular piece of memory was allocated and which operator was used!\n\n<h>\n*QMake\n</h>\n\nQMake\n o QMake is a makefile generator.\n o Supports multiple platforms and multiple C++ compilers.\n o Automatically maintains dependencies.\n o Includes support for MOC, UI and QRC files.\n o Is very terse-you do not have to write much.\n o Supports compiling both applications and libraries.\n o Supports Unix-style Makefiles, nmake Makefiles, Visual C++ and VS.NET, and MacOS Xcode, among others.\n\nVARIABLES\n o All System Variables are written in capital letters.\n o You can also add your own variables.\n o Variables can be referenced using $$:\n  PARSER = myparser.cpp\n  SOURCES= main.cpp $$PARSER\n o Lines can be split using backslashes.\n o # is the comment character; comments extend till the end of the line.\n\nMost Common System Variables\n o TEMPLATE Defines the type of project. Must be one of:\n o app, vcapp Creates a binary.\n o lib, vclib Creates a library.\n o subdirs Invokes make recursively for subdirectories.\n o HEADERS List of header files.\n o SOURCES List of (C/C++) source files.\n o TARGET Name of the executable (adds .exe on Windows).\n  Defaults to the name of the .pro file/directory.\n\n o QT Specifies the Qt features to be included. Core and GUI are included by default. To make other feature available, use\n   QT += xml sql network\n  If you do not need the GUI classes (e.g., because you are building a server application), use\n   QT -= gui\n\nOther Useful System Variables\n o DEFINES List of C preprocessor macros (-D option).\n o LIBS List of additional libraries to be linked in.\n o INCLUDEPATH Sets the include search path (-I option).\n o DEPENDPATH Sets the dependency search path for QMake.\n o DESTDIR Specifies where to put the target file.\n o MOC_DIR Specifies directory to place moc files in.\n o OBJECT_DIR Specifies directory to place object files in.\n\nSystem Variables\n o LEXSOURCES Specifies a list of lex files.\n o YACCSOURCES Specifies a list of yacc sources.\n o SUBDIRS Specifies a list of directories to run make recursively in.\n o VERSION Specifies the version for the library template.\n o FORMS Specifies interfaces (.ui) files from Qt Designer.\n o RESOURCES Specifies resource collection (.qrc) files to include in build.\n\nThe CONFIG System Variable\n o The system variable CONFIG is a list of system configurations. The following options exist:\n o release Compile with optimization enabled, ignored if debug is specified.\n o debug Compile with debug options enabled.\n o warn_on The compiler should emit more warnings than normally, ignored if warn_off is specified.\n o warn_off The compiler should emit no warnings or as few as possible.\n o ordered Order subdirectories so parallelized builds work.\n o qt The target is a Qt application/library and requires Qt header files/library.\n o opengl The target requires the OpenGL (or Mesa) headers/libraries.\n o thread The target is a multi threaded application or library.\n o x11 The target is an X11 application or library.\n o windows The target is a Win32 window application.\n o console The target is a Win32 console application.\n o shared The target is a shared object/DLL.\n o static The target is a static library.\n o plugin The target is a plugin (requires TARGET=lib, and implies shared).\n o exceptions Turns on compiler exception support.\n o rtti Turns on compiler RTTI support.\n o stl Turns on Qt STL support.\n o flat only for TEMPLATE=vcapp; puts all sources files into one group and all header files into another group, independent of the directory structure.\n\nsubdirs template\n test.pro:\n TEMPLATE = subdirs\n SUBDIRS = dirA dirB dirC\n\n o If QMake is used in the subdirectories to generate the Makefiles, the project files in these directories should be called <dir-name>.pro.\n o Example: dirA/dirA.pro. This makes it possible for qmake to execute qmake in the subdirectories.\n\nModifying Variables\n o Variables can be modified in a number of ways:\n A = abc\n X = xyz\n A += abc def # A = abc abc def\n B = $$A # B = abc abc def\n B -= abc # B = def\n B *= abc def # B = abc def\n B ~= s/ab[xc]/xyz/ # B = xyz def\n o This can be used to modify variables from the command line:\n  qmake -after "LIBS+=-pg" "CONFIG+=debug" "CONFIG-=release"\n  Development Process QMake 393/478\n  Scopes\n o You can use scopes to conditionally assign to variables.\n o Scopes can be specified based on the following things:\n o OS mode (win32, unix, mac, . . . )\n o Patterns matching the platform (QMAKESPEC environment variable, or -platform command line option): solaris-cc or linux-* or *-g++* or *-64 etc.\n o Options appearing in the CONFIG variable, including your own.\n o The result of a function (described later)\n\nScopes\n o Scopes can be specified in "concatenation" syntax: scope1:scope2:. . . :scopen:var = value\n o Examples:\n  SOURCES = common.cpp\n  win32:SOURCES += win_hack.cpp # OS.\n  unix:profile:LIBS += -pg # profile is a user supplied\n  # option from the CONFIG\n  # variable.\n\n o Scopes can also be specified in groups using { . . . }:\n  win32 {\n  debug {\n  SOURCES += debug.cpp # win32 && debug\n  }\n  release {\n  SOURCES += release.cpp # win32 && release\n  }\n  }\n o Be aware that with the { . . . } syntax, the opening brace must be on the same line as the test, and the closing brace must be on a line by itself.\n\n o The two methods can be combined.\n  win32 {\n  debug:SOURCES += debug.cpp\n  release:SOURCES += release.cpp\n  }\n o Scopes can be negated with an exclamation mark:\n  network:SOURCES += network.cpp\n  !network:SOURCES += no_network.cpp\n o Alternatively you can use else.\n  Development Process QMake 397/478\n  Functions\n o A number of predefined functions exists, they are split in two categories:\n o test functions used as part of tests.\n o replacement functions used to create strings (i.e., right-hand-side values).\n o It is also possible to implement your own functions, which is beyond the scope of this course, please refer to the reference manual.\n\nTest Functions\n o isEmpty( variablename ) This function will succeed if the variable variablename is empty (same as count(variable, 0)).\n o CONFIG( config ) Like a scope qualifier, but allows mutual exclusions to be specified. Rarely needed, the specifiers that are useful here should not go into the .pro file anyway, but rather be specified on the command line.\n o count( variablename, number ) This function will succeed if the variable variablename contains number elements.\n o contains( variablename, value ) This function will succeed if variablename contains the value value.\n\n o system( command ) This function will execute the command in a secondary shell and will succeed if the command exits with an exit status of 0.\n o error( txt ) This function will never return. It will display the given string to the user, and then exit qmake.\n o message( txt ) This function will always succeed, and will display the given string to the user. warning() is a synonym.\n o infile( filename, var, val ) Succeeds if filename, as parsed by QMake, contains a variable var set to val. If val is not specified, it tests for the mere declaration of var.  Development Process QMake 400/478 Test functions\n o include( filename ) This function will include the contents of filename into the current project at the point it was included. The function succeeds if filename was included.\n o exists( filename ) Succeeds if filename exists. If you must have a certain file for proceeding further, you can use error() (see below) for terminating in case this file does not exist:\n  !exists( file.dat ):error( "file.dat missing" )\n  Development Process QMake 401/478\n  Replacement Functions\n o basename( file ) This function returns the basename of file, i.e., the filename stripped of the path and a possible extension. The path can be extracted with dirname().\n odirname( file ) Returns the path of the directory containing the file.\n o prompt(question) Displays question, waits for input from standard input, and returns that input. Warning: This will break automated builds, unless standard input is redirected.  It might be useful for very simple install scripts, though.\n o system( command ) This function will execute the command in a secondary shell and will return stdout and sdterr concatenated.\n o find( variablename, substr ) Returns all values in variablename that match the regular expression substr. See the QRegExp documentation for the regular expression syntax.\n o for( iterator, list ) Iterates over list, using the loop variable iterator. The syntax <num>..<num> is supported as well.\n o join( varname, glue, before, after ) Joins the value of variablename according to what QStringList::join() does.\n\n o member( varname, position ) Equivalent to QList::at().\n o quote( string ) Turns string into a single entity and returns that.\n o unique( varname ) Removes duplicate values from varname and returns the new list.\n o sprintf( string, arguments... ) Like QString::sprintf(), but uses %1-%9 for the placeholders.\n\n<h>\n*Qt Debugging Aids\n</h>\n\nQt Debugging Aids\n o You can output debugging messages with qDebug(),\n  qDebug( "Method computed: %d", myIntVariable );\n  qDebug() << "Mouse was clicked at " << mouseEvent->pos();\n o Setting the environment variable QT_FATAL_WARNINGS makes the application terminate on warnings.\n o Connecting a signal and a slot incorrectly is only shown if Qt is compiled with debug information.\n o Defining QT_NO_DEBUG_OUTPUT and/or QT_NO_WARNING_OUTPUT during compilation of your application, turns the messages in question off.\n o Q_ASSERT is like the good old assert, except that you can compile it out by compiling Qt with the QT_NO_DEBUG flag.\n o Q_ASSERT_X() is an assert that lets you specify a message to output on assertion failure.\n o To show a QString in MSVC++ you need to insert the following code into the file\n  ...Program FilesMicrosoft Visual Studio\n  Common7PackagesDebuggerAutoexp.dat (adjust\n  for your Visual Studio installation):\n  ; from Qt\n  QString=<d->data,su>\n\nPrinting QString in GDB\n o Insert the following code into your ~/.gdbinit, and you can do qs str (where str is a QString):\n  define qs\n  set $i=0\n  set $d = $arg0.d\n  while $i < $d->size\n  printf "%c", (char)($d->data[$i++] & 0xff)\n  end\n  printf "\n"\n  end\n o kdesdk/scripts/kde-devel-gdb contains many more of these functions.\n\n o You can pass a name to each Qt object with setObjectName().\n o This name can be retrieved with QObject::objectName().\n o As a lot of the debugging information is only really helpful if these names are set, it is good Qt programming style to do so.\n o QObject::dumpObjectInfo() dumps information about object internals, like signals/slots.\n o QObject::dumpObjectTree() dumps the parent/child relationships of all descendant objects.\n o Installing a global event filter can help you get information about your widgets.\n o Questions which can be answered include: "Which children does this widget have?" and "How far does this widget stretch?"\n o #include "shootabug.h" and insert the following into your\n  main:\n  qApp->installEventFilter( new ShootABug() );\n  Development Process Qt Debugging Aids\n  Shoot a Bug\n  class ShootABug :public QObject\n  {\n  Q_OBJECT\n  public:\n  bool eventFilter( QObject* recv, QEvent* event )\n  {\n  if ( event->type() != QEvent::MouseButtonPress )\n  return false; // pass it on\n  QMouseEvent* mevent = static_cast<QMouseEvent*>(event);\n  if ( (mevent->modifiers() & Qt::ControlModifier ) &&\n  (mevent->button() & Qt::LeftButton) ) { // Ctrl + left mouse click.\n  qDebug("----------------------------------------------------");\n  qDebug("Widget name : %s", qPrintable( recv->objectName() ) );\n  qDebug("Widget class: %s", recv->metaObject()->className() );\n  qDebug("\nObject info:");\n  recv->dumpObjectInfo();\n  qDebug("\nObject tree:");\n  recv->dumpObjectTree();\n  qDebug("----------------------------------------------------");\n  return true; // Block\n  }\n  return false;\n  Qt Debugging Aids\n o On X11 systems, the command-line switch -nograb prevents Qt from grabbing the mouse and keyboard and thus prevents the dreaded "debugger lock-ups".\n o On Linux, Qt even detects if it is running from within gdb and automatically turns off grabbing. This can be overridden with\n  -dograb. (Careful!)\n o Qt also supports the command-line switch -sync which makes all Xlib calls synchronous.\n\n<h>\n*QTestLib\n</h>\n\nIntroduction\n o Testing helps you gain confidence in your product, and makes paradigms like refactoring possible.\n o Test-driven development is (part of) a whole development methodology based entirely on unit tests.\n o At least two kind of test types exists: unit testing and black box testing.\n o QTestLib is about unit testing, while products like KD Executor and Squish are more about black box testing.\n\n o When writing unit tests, you write code that tests individual functions or methods.\n o These tests are compiled into a test binary, which is compiled against the functions of your classes that you want to test.\n o Since the tests are compiled into a separate binary, your final product will not contain any traces of test functions.\n o As an added bonus, unit testing can well improve the design of your application.\n\nQTestLib Facts\n o Lightweight 6000 lines of code, 60 exported symbols.\n o Self-contained Requires only a few symbols from Qt.\n o Rapid testing No special test-runners; No special registration for tests.\n o Data-driven testing A test can be executed multiple times with different test data.\n o Basic GUI testing Offers functionality for mouse and keyboard simulation.\n o Type-safety Extensive use of templates prevent errors introduced by implicit type casting.\n o Easily extendable Custom types can easily be added to the test data and test output.\n\nWriting a Simple Test\n o Test cases are implemented as functions in a class which must inherit QObject.\n o The macro QTEST_MAIN implements a main function and registers the test class at the same time.\n o Add CONFIG += qtestlib to your qmake file to compile QTestLib into a test binary.\n o A number of macros exist in order to verify your result, including QVERIFY and QCOMPARE\n\nData-Driven Testing\n o When testing a certain function it might be useful to test it with different parameters.\n o We could do this with a number of calls to e.g. QCOMPARE.\n o The alternative is to use QTestLib\'s capability for data-driven testing.\n o Here, one function is the actual test case, while another, with the postfix _data, contains the dataset. The test function is invoked for each data item in the data set.\n  Development Process Unit Testing with QTestLib 468/478\n  Data Driven Testing\n o In the _data function, you set up your data using the method\n  QTest::addColumn(), and create test data using\n  QTest::newRow():\n  QTest::addColumn<QString>( "input" );\n  QTest::addColumn<QString>( "result" );\n  QTest::newRow( "all lower" ) << "hello" << "hello";\n  QTest::newRow( "mixed" ) << "HellO" << "hello";\n o In the test case, you fetch the data using the QFETCH macro:\n  QFETCH( QString, input );\n  QFETCH( QString, result );\n  QCOMPARE( input.toLower(), result );\n  Development Process Unit Testing with QTestLib 469/478\n  Data Driven Testing\n o It is possible to use your own data types as long as they have\n  been registered using Q_DECLARE_METATYPE.\n o The macro QEXPECT_FAIL can be set up to expect failure\n  from a given data in the set:\n  QFETCH( QString, data );\n  QFETCH( int, result );\n  QEXPECT_FAIL( "expected error",\n  "To be fixed", Abort );\n  QCOMPARE( data.count(), result );\n o The first parameter is the name of the data value, the second a message to display, and the third tells whether the test case should continue. after an error.\n o See example unit-test/data-driven\n\nGUI Testing\n o Using QTestLib, you can simulate mouse and keyboard events.\n o Keyboard events: keyClick(), keyClicks(), keyEvent()\n o Mouse events: mouseClick(), mouseDClick(), mousePress(), mouseRelease(), mouseMove()\n Examples:\n  QTest::keyClicks( lineEdit, "Hello World" );\n  QTest::keyClick( lineEdit, Qt::Key_Backspace );\n  QTest::keyEvent( QTest::Press, lineEdit, \'a\',\n  Qt::ControlModifier );\n  QTest::mouseClick( lineEdit, Qt::LeftButton );\n\nGUI Testing\n o During testing, it can be useful to wait a few milliseconds, e.g.  when waiting for a remote server to respond.\n o This can be done using QTest::qSleep() or\n  QTest::qWait().\n o qSleep() is blocking, i.e. no event processing is done, while qWait() keeps the event loop running while waiting.\n o The methods keyPress(), keyClick(), . . . all take an optional argument specifying the amount of milliseconds to wait before continuing.\n o In addition, the command-line arguments -keydelay, -mousedelay, and -eventdelay can be used to insert a\n  delay after each key and/or mouse event.\n\nData-Driven GUI Testing\n o To support data driven GUI testing, the class QTestEventList can be used for storing key and mouse events.\n o The class has methods similar to those of QTest, namely addKeyPress(), addKeyClick(), addMouseClick(), . . . .\n o To playback the events, use QTestEventList::simulate(), which takes a widget on which the events are invoked.\n\nQSignalSpy\n o Unit testing is about stimulating an object, and verifying response.\n o QObjects can emit signals in response.\n o The class QSignalSpy is designed to verify emitted signals.\n o The class inherits QList< QList<QVariant> >, the outer list items each represent a signal emission, while the inner list items represent its argument.\n\nBenchmarking\n  Test functions can be benchmarked.\n o Apply the QBENCHMARK macro to parts of test functions.\n o Run the test case in the usual way.\n<c>\n  class MyFirstBenchmark: public QObject\n  {\n  Q_OBJECT\n  private slots:\n  void myFirstBenchmark()\n  {\n  QString string1;\n  QString string2;\n  QBENCHMARK {\n  string1.localeAwareCompare(string2);\n  }\n  }\n  };\n</c>\n\nDmarking Backends\n Backends measure and report performance in different ways:\n o These are selected via command line options.\n o The default "Walltime" backend measures and reports elapsed time.\n o -tickcounter selects the cross-platform CPU tick counter backend.\n o -eventcounter selects the cross-platform event counter backend.\n o -callgrind selects the Linux-specific Callgrind backend.\n o Some backends may run benchmarked code multiple times to ensure accurate timings.\n  See the QTestLib manual for more details.\n\n Project Task: Test the Compass Widget\n o Create unit tests for the compass widgets you implemented, alternatively use the one from solutions/compasswidget.\n o Discuss what you can do during development of your application, in order to better support unit testing.\n o Optional: Modify the compass widget according to the'
'20!ABS SBA!Embedded Qt and HMI!ABS SBA!!ABS SBA!<h>\n*Preparing cross compilation envrironment\n</h>\n\n<h>\n*Building Qt source code inorder to have libs\nin cross compliation envrionment\n</h>\n\n<h>\n*Building Qt application based on newly built\n Qt libraries\n</h>\n\n<h>\n*Font handling\n</h>\n\n<h>\n*Wayland, QtComposite integration\n</h>\n\n<h>\n*Setting up IDE for cross compilation\n</h>\n\n<h>\n*Testing the application on hardware\n</h>\n\n<h>\n*Developing HMI with Qt/Qt Quick\n</h>'
'21!ABS SBA!Qml/QtQuick Basics!ABS SBA!*Write a QML document\n*Import javascript code in QML\n*Define componet dynamically\n*Implement Ecllipse as Qml class type\n - do same and export in a Library\n*Implement List data model view through delegate!ABS SBA!<h>\n*Introduction QtQuick and QML\n</h>\n\n<h>\n*Qml Architecture\n</h>\n\n<h>\n*Qt Properties\n</h>\n\n<h>\n*Building Blocks of QML\n</h>\n\n<h>\n*Composing UIs\n</h>\n\n<h>\n*User Input\n</h>\n\n<h>\n*Structures\n - Components\n - Modules\n</h>\n\n<h>\n*Modules\n - Importing javascript code in QML\n</h>\n\n<h>\n*Dynamic creation of items\n</h>\n\n<h>\n*C++ Integration\n - Using custom type plugins\n - Building an applcation as a Library\n</h>\n\n<h>\n*Qt Quick Control\n</h>\n\n<h>\n*Presenting Data\n - Data Models\n - Using Views, Using Delegates\n</h>\n\n<h>\n*Write a QML document\n</h>\n\n<h>\n*Import javascript code in QML\n</h>\n\n<h>\n*Define componet dynamically\n</h>\n\n<h>\n*Implement Ecllipse as Qml class type\n - do same and export in a Library\n</h>\n\n<h>\n*Implement List data model view through delegate\n</h>'
'22!ABS SBA!Qt WebEngine!ABS SBA!None!ABS SBA!None'
'23!ABS SBA!Qt StateMachine!ABS SBA!* Animate two buttons using\n  - Parallel Animation\n  - Sequential Animation!ABS SBA!None'
'24!ABS SBA!Qt Multimedia!ABS SBA!None!ABS SBA!None'
'25!ABS SBA!Qt Charts!ABS SBA!None!ABS SBA!None'
'26!ABS SBA!Qt Speech!ABS SBA!None!ABS SBA!None'
'27!ABS SBA!Debugging Aids!ABS SBA!None!ABS SBA!<h>\n*log messages, i.e QDebug\n</h>\n<h>\n*asserts\n</h>\n<h>\n*debugging tools, i.e. gdb\n</h>'
'31!ABS SBA!title!ABS SBA!None!ABS SBA!PyQt Essentials Training'
'32!ABS SBA!subtitle!ABS SBA!None!ABS SBA!3-day session'
'33!ABS SBA!h_Overview!ABS SBA!None!ABS SBA!Understanding fundamental and advance topics in Qt Programming\nUnderstanding signals and slots concept\nUnderstanding Widget\nUnderstanding QPainter and 2D painting\nUnderstanding QML/QtQuick'
'34!ABS SBA!h_Duration!ABS SBA!None!ABS SBA!Three days - 15 hours (5 hours a day)\n4hrs lecture, 1hr practical lab review'
'35!ABS SBA!h_Trainer!ABS SBA!None!ABS SBA!<a href="https://www.linkedin.com/in/pravinkumarsinha">http://www.linkedin.com/in/pravinkumarsinha</a>'
'36!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'37!ABS SBA!h_Audience!ABS SBA!None!ABS SBA!Professional embedded Software developers\nProfessional GUI developers'
'38!ABS SBA!h_Prerequisite!ABS SBA!None!ABS SBA!<b>Knowledge of Python programming</b>\nPrior knowledge to Python3.x is required.\nAdvance Python training agenda is available at\n<a href=http://minhinc.42web.io/training/py/advance-py-slides.php>http://minhinc.42web.io/training/py/advance-py-slides.php</a>\n\nPdf document can be downloaded from\n<a href=http://minhinc.42web.io/training/advance-py-slides.pdf>http://minhinc.42web.io/training/advance-py-slides.pdf</a>\n\n<b>Knowledge of Design Patterns Concepts</b>\nQt uses GOF desing patterns in co-relating python classes.\nGet slides at\n<a href=http://minhinc.42web.io/training/dp/advance-dp-slides.php>http://minhinc.42web.io/training/dp/advance-dp-slides.php</a>\n\n<b>Knowledge of GUI and other concepts</b>\nQt is used for GUI development and many other technologies including Networks,\noperating systems, Database, scripting. Basic knowledge of these domains are\nrequired as per the Qt is developed for the particular domain.'
'39!ABS SBA!h_hr!ABS SBA!None!ABS SBA!None'
'40!ABS SBA!h_Setup!ABS SBA!None!ABS SBA!Ubuntu 18 LTS, Qt 5.11/5.12'
'41!ABS SBA!h2_Lecture!ABS SBA!None!ABS SBA!Lecture session will be course content presentation through the trainer.\nAny source code example related to the topic will be demonstrated, it would\ninclude executing the binaries.\nComplete lecture material can be downloaded from\n<a href="http://minhinc.42web.io/training/advance-qt-slides.pdf">http://minhinc.42web.io/training/advance-qt-slides.pdf</a>'
'42!ABS SBA!h2_Labs!ABS SBA!None!ABS SBA!Labs session would be completely hands on session where each example (with\nexample data and execution instruction) would be provided to the students. Students\ncan verify their results with the results provided in the material.'
'101!ABS SBA!Event Management!ABS SBA!*Creating Custom Events!ABS SBA!<h>\n*Event flow and Handling\n - Event handling through callback \n</h>\n<h>\n*Polymorphism\n - Event handling through message map\n</h>\n<h>\n*Synthetic and hardware events\n - Custom events\n - Sending and receiving custom events\n - Posting events\n</h>\n<h>\n*Custom event\n</h>\n<h>\n*Event filtering\n</h>'
'102!ABS SBA!Event Management, Cont..!ABS SBA!*Event Filtering!ABS SBA!<h>\n*Event loops\n - QCoreApplication\n - QEventDispatcher\n - exec()\n</h>\n<h>\n*Event filters\n - Registering event filter\n - Installing event filter\n</h>\n<h>\n*Timer events\n</h>\n<h>\n*Signal & Slots communication & delivery\n</h>\n<h>\n*Data passing and Signal mapper\n</h>\n<h>\n*Signal & Slot\n</h>\n<h>\n*Signal Mapper\n</h>'
'105!ABS SBA!Misc!ABS SBA!None!ABS SBA!*Integrating with Visual Studio\n - Download qt bundle for windows MSVC\n - Configure Visual Studio for Qt\n*Integrating C# application with QT-UI\n -QtSharp'
      resume      
      tech      
'1!ABS SBA!py!ABS SBA!{\n"1":"<!--Learn Python Through YouTube Video!!-->\\\n<table width=\\"100%\\" align=\\"center\\" cellpadding=\\"0\\" cellspacing=\\"0\\" style=\\"max-width:youtubeimagewidth;\\">\\\n<tr><td height=\\"50\\"></td></tr>\\\n<tr>\\\n <td align=\\"left\\"><a href=\\"https://www.youtube.com/c/minhinc\\" style=\\"text-decoration:none;font-size:18px;font-weight:bold;color:#000\\">Python : youtubetitle</a></td>\\\n</tr>\\\n<tr><td height=\\"10\\"></td></tr>\\\n<tr>\\\n <td align=\\"center\\"><pre style=\\"font-size:24px;color:#666\\">YouTube Channel <a href=\\"https://www.youtube.com/c/minhinc\\" style=\\"text-decoration:none;font-size:24px;background-color:#a3b1be;color:#004000;font-family:arial, helvetica, sans;font-weight:bold\\">Minh Inc</a></pre></td>\\\n</tr>\\\n<tr><td height=\\"10\\"></td></tr>\\\n<tr>\\\n <td align=\\"right\\"><a href=\\"https://www.youtube.com/c/minhinc/?sub_confirmation=1\\" style=\\"text-decoration:none;display:block;color:#ffffff;font-size:14px;text-align:center;width:80px;line-height:30px;border-radius:2px;background-color:#cc0000;font-family:arial, helvetica, sans;\\">Subscribe</a></td>\\\n</tr>\\\n<tr>\\\n <td align=\\"center\\"><a href=\\"https://www.youtube.com/watch?v=youtubeid\\"><img src=\\"http://minhinc.42web.io/image/youtubeid.jpg\\" width=\\"100%\\"/></a></td>\\\n</tr>\\\n<tr>\\\n <td align=\\"left\\"><a href=\\"https://www.youtube.com/c/minhinc\\" style=\\"text-decoration:none;font-size:14px;font-weight:bold;color:#000\\">youtubetitle</a></td>\\\n</tr>\\\n<tr><td height=\\"50\\"></td></tr>\\\n<tr style=\\"margin-top:100px\\"><td  align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io\\"><img src=\\"http://minhinc.42web.io/image/topconLogo.png\\"/></a>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:20px\\">Sent To : XXX</pre>\\\n <pre style=\\"text-align:center;margin-top:5px\\"><a href=\\"http://minhinc.42web.io/about/unsubscribe_wn.php?email=XXX\\" target=\\"_blank\\" style=\\"color:#0000ff;font-weight:bold;font-family:arial,helvetica,sans-serif;font-size:9pt;\\">Unsubscribe</a></pre>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:-10px\\"><br><br>#85,P&T,Bangalore-94,India, +91 9483160610 <img src=\\"http://minhinc.42web.io/image/whatsapp_s.png\\"/><br><a href=\\"mailto\\">sales@minhinc.com</a><br><a href=\\"http://minhinc.42web.io\\">http://minhinc.42web.io</a></pre>\\\n</td></tr>\\\n</table>",\n"youtube":[["Meta class in Singleton class creation in Python -Part 5 | Python | www.minhinc.com | Jun 2021", "YjxvZD_dj5g"],["Meta class in class hierarchy - Part 4 | Python | subclass meta class | www.minhinc.com | Jun 2021", "STnjJwapgiI"],["Meta class and class attributes modification - Part 3 | Python | www.minhinc.com | Jun 2021", "Qjwo4o8Lzrc"],["Meta class and Class Instance Object creation - Part 2 | Python | www.minhinc.com | Jun 2021", "Gt2yBusHaM4"],["Meta class and Class object creation in Python - Part 1 | www.minhinc.com | 10 Jun 2021", "uGCPWlpaCBA"],["Install Qt PySide6 and Uml through pyreverse | Reverse Engineering | May 2021","kTxAwQeAvtk"],["Python Chain Of Responsibility Design Pattern | www.minhinc.com | Dec 07 2019", "gHfl4FUzdpU"],["Python static class variable | www.minhinc.com | Nov 27 2019", "kO_xuHw9J9c"], ["PyReverse - UML class diagram from python code. | www.minhInc.com | Nov 14 2019", "lAXRzxTgTww"]],\n"2":"<!--Online Python Training-->\\\n<table width=625 align=\\"center\\">\\\n<col style=\\"width:33%\\"/>\\\n<col style=\\"width:33%\\"/>\\\n<col style=\\"width:33%\\"/>\\\n<tr><td colspan=\\"3\\" align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io/\\" style=\\"font-size:11pt;color:#444;text-decoration:none\\">Online Training</a> | <a href=\\"http://minhinc.42web.io/training/py\\" style=\\"font-size:11pt;color:#444;text-decoration:none\\">Online Course Material</a> | <a href=\\"http://minhinc.42web.io/about/online\\" style=\\"font-size:11pt;color:#444;text-decoration:none\\">Lesser Rates</a>\\\n</td></tr>\\\n<tr style=\\"margin-top:100px;border:1px solid red\\"><td colspan=\\"3\\" align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io\\"><img src=\\"http://minhinc.42web.io/image/topconLogo.png\\"/></a>\\\n</td></tr>\\\n\\\n<tr height=300px><td colspan=\\"1\\">\\\n<img src=\\"http://minhinc.42web.io/image/file1_s.gif\\" style=\\"max-height:200px\\"/>\\\n</td>\\\n<td colspan=\\"2\\" align=\\"right\\">\\\n<pre style=\\"color:#f26522;font-size:16pt;font-family:Arial;font-weight:bold;text-align:left\\">Get Online Training On Python</pre>\\\n<pre style=\\"width:80%;text-align:left;font-size:12pt;font-family:georgia,\'times new roman\';color:#444;white-space:pre-wrap\\">We provide online training on Python with 6 weeks of training spanning over one and half months. 5-6 hrs every week.</pre>\\\n<a href=\\"http://minhinc.42web.io\\" style=\\"text-decoration:none;display:block;color:#fff;font-size:16px;text-align:center;width:160px;line-height:50px;margin:30px auto;border-radius:2px;background-color:#53616e;font-family:arial, helvetica, sans;\\">...Read More</a>\\\n</td></tr>\\\n \\\n<tr height=300px><td colspan=\\"2\\" align=\\"left\\">\\\n<pre style=\\"color:#f26522;font-size:16pt;font-family:Arial;font-weight:bold;text-align:right;\\">Online Training Content</pre>\\\n<pre style=\\"width:80%;text-align:left;font-size:12pt;font-family:georgia,\'times new roman\';color:#444;white-space:pre-wrap\\">Course content for Python are made online. Course contents are available in Pdf downloadable format also. Participants can practice before coming to the training.</pre>\\\n<a href=\\"http://minhinc.42web.io/training/py\\" style=\\"text-decoration:none;display:block;color:#fff;font-size:16px;text-align:center;width:160px;line-height:50px;margin:30px auto;border-radius:2px;background-color:#53616e;font-family:arial, helvetica, sans;\\">...Read More</a>\\\n</td>\\\n<td colspan=\\"1\\">\\\n<img src=\\"http://minhinc.42web.io/image/file2_s.gif\\" align=\\"right\\" style=\\"max-height:200px\\"/>\\\n</td></tr>\\\n \\\n<tr height=300px><td colspan=\\"1\\">\\\n<img src=\\"http://minhinc.42web.io/image/file_py3_s.gif\\" style=\\"max-height:200px\\"/>\\\n</td>\\\n<td colspan=\\"2\\" align=\\"right\\">\\\n<pre style=\\"color:#f26522;font-size:16pt;font-family:Arial;font-weight:bold;text-align:left\\">Fee Structure and Next Training ...</pre>\\\n<pre style=\\"width:80%;text-align:left;font-size:12pt;font-family:georgia,\'times new roman\';color:#444;white-space:pre-wrap\\">We have 1 disclosures in Python. Fee structure is made affordable at <b>$400 or 19500/-</b> for each participants. Next training is scheduled for advance python in MMYY</pre>\\\n<a href=\\"http://minhinc.42web.io/about/online\\" style=\\"text-decoration:none;display:block;color:#fff;font-size:16px;text-align:center;width:160px;line-height:50px;margin:30px auto;border-radius:2px;background-color:#53616e;font-family:arial, helvetica, sans;\\">...Read More</a>\\\n</td></tr>\\\n \\\n<tr style=\\"margin-top:100px\\"><td colspan=\\"3\\" align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io\\"><img src=\\"http://minhinc.42web.io/image/topconLogo.png\\"/></a>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:20px\\">Sent To : XXX</pre>\\\n <pre style=\\"text-align:center;margin-top:5px\\"><a href=\\"http://minhinc.42web.io/about/unsubscribe_wn.php?email=XXX\\" target=\\"_blank\\" style=\\"color:#0000ff;font-weight:bold;font-family:arial,helvetica,sans-serif;font-size:9pt;\\">Unsubscribe</a></pre>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:-10px\\"><br><br>#85,P&T,Bangalore-94,India, +91 9483160610 <img src=\\"http://minhinc.42web.io/image/whatsapp_s.png\\"/><br><a href=\\"mailto\\">sales@minhinc.com</a><br><a href=\\"http://minhinc.42web.io\\">http://minhinc.42web.io</a></pre>\\\n</td></tr>\\\n</table>"\n}'
'2!ABS SBA!c!ABS SBA!None'
'3!ABS SBA!cpp!ABS SBA!{\n"1":"<!--Learn C++ through YouTube Video!!-->\\\n<table width=youtubeimagewidth align=\\"center\\" cellpadding=\\"0\\" cellspacing=\\"0\\">\\\n<tr><td height=\\"50\\"></td></tr>\\\n<tr>\\\n <td width=\\"youtubeimagewidth\\" align=\\"left\\"><a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ\\" style=\\"text-decoration:none;font-size:18px;font-weight:bold;color:#000\\">Qt/Qml : youtubetitle</a></td>\\\n</tr>\\\n<tr><td height=\\"10\\"></td></tr>\\\n<tr>\\\n <td align=\\"center\\"><pre style=\\"font-size:24px;color:#666\\">YouTube Channel <a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ\\" style=\\"text-decoration:none;font-size:24px;background-color:#a3b1be;color:#004000;font-family:arial, helvetica, sans;font-weight:bold\\">Minh Inc</a></pre></td>\\\n</tr>\\\n<tr><td height=\\"10\\"></td></tr>\\\n<tr>\\\n <td align=\\"right\\"><a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ/?sub_confirmation=1\\" style=\\"text-decoration:none;display:block;color:#ffffff;font-size:14px;text-align:center;width:80px;line-height:30px;border-radius:2px;background-color:#cc0000;font-family:arial, helvetica, sans;\\">Subscribe</a></td>\\\n</tr>\\\n<tr>\\\n <td align=\\"center\\"><a href=\\"https://www.youtube.com/watch?v=youtubeid\\"><img src=\\"http://minhinc.42web.io/image/youtubeid.jpg\\" style=\\"max-width:youtubeimagewidth\\"/></a></td>\\\n</tr>\\\n<tr>\\\n <td align=\\"left\\"><a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ\\" style=\\"text-decoration:none;font-size:14px;font-weight:bold;color:#000\\">youtubetitle</a></td>\\\n</tr>\\\n<tr><td height=\\"50\\"></td></tr>\\\n<tr style=\\"margin-top:100px\\"><td  align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io\\"><img src=\\"http://minhinc.42web.io/image/topconLogo.png\\"/></a>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:20px\\">Sent To : XXX</pre>\\\n <pre style=\\"text-align:center;margin-top:5px\\"><a href=\\"http://minhinc.42web.io/about/unsubscribe_wn.php?email=XXX\\" target=\\"_blank\\" style=\\"color:#0000ff;font-weight:bold;font-family:arial,helvetica,sans-serif;font-size:9pt;\\">Unsubscribe</a></pre>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:-10px\\"><br><br>#85,P&T,Bangalore-94,India, +91 9483160610 <img src=\\"http://minhinc.42web.io/image/whatsapp_s.png\\"/><br><a href=\\"mailto\\">sales@minhinc.com</a><br><a href=\\"http://minhinc.42web.io\\">http://minhinc.42web.io</a></pre>\\\n</td></tr>\\\n</table>",\n"old_1":"<!--Learn C++ through YouTube Video!!-->\\\n<table width=625 align=\\"center\\" cellpadding=\\"0\\" cellspacing=\\"0\\">\\\n<tr><td colspan=\\"3\\" height=\\"50\\"></td></tr>\\\n<tr>\\\n <td width=\\"youtubewidth\\"</td><td width=\\"youtubeimagewidth\\" align=\\"left\\"><a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ\\" style=\\"text-decoration:none;font-size:18px;font-weight:bold;color:#000\\">C++ : youtubetitle</a></td><td width=\\"youtubewidth\\"></td>\\\n</tr>\\\n<tr><td colspan=\\"3\\" height=\\"10\\"></td></tr>\\\n<tr>\\\n <td colspan=\\"3\\" align=\\"center\\"><pre style=\\"font-size:24px;color:#666\\">YouTube Channel <a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ\\" style=\\"text-decoration:none;font-size:24px;background-color:#a3b1be;color:#004000;font-family:arial, helvetica, sans;font-weight:bold\\">Minh Inc</a></pre></td>\\\n</tr>\\\n<tr><td colspan=\\"3\\" height=\\"10\\"></td></tr>\\\n<tr>\\\n<td></td><td align=\\"right\\"><a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ/?sub_confirmation=1\\" style=\\"text-decoration:none;display:block;color:#ffffff;font-size:14px;text-align:center;width:80px;line-height:30px;border-radius:2px;background-color:#cc0000;font-family:arial, helvetica, sans;\\">Subscribe</a></td>\\\n</tr>\\\n<tr>\\\n <td colspan=\\"3\\" align=\\"center\\"><a href=\\"https://www.youtube.com/watch?v=youtubeid\\"><img src=\\"http://minhinc.42web.io/image/youtubeid.jpg\\" style=\\"max-width:youtubeimagewidthpx\\"/></a></td>\\\n</tr>\\\n<tr>\\\n <td></td><td align=\\"left\\"><a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ\\" style=\\"text-decoration:none;font-size:14px;font-weight:bold;color:#000\\">youtubetitle</a></td><td></td>\\\n</tr>\\\n<tr><td colspan=\\"3\\" height=\\"50\\"></td></tr>\\\n<tr style=\\"margin-top:100px\\"><td colspan=\\"3\\" align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io\\"><img src=\\"http://minhinc.42web.io/image/topconLogo.png\\"/></a>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:20px\\">Sent To : XXX</pre>\\\n <pre style=\\"text-align:center;margin-top:5px\\"><a href=\\"http://minhinc.42web.io/about/unsubscribe_wn.php?email=XXX\\" target=\\"_blank\\" style=\\"color:#0000ff;font-weight:bold;font-family:arial,helvetica,sans-serif;font-size:9pt;\\">Unsubscribe</a></pre>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:-10px\\"><br><br>#85,P&T,Bangalore-94,India, +91 9483160610 <img src=\\"http://minhinc.42web.io/image/whatsapp_s.png\\"/><br><a href=\\"mailto\\">sales@minhinc.com</a><br><a href=\\"http://minhinc.42web.io\\">http://minhinc.42web.io</a></pre>\\\n</td></tr>\\\n</table>",\n"youtube":[["Qt QScrollArea - Part 3 | www.minhinc.com", "JzN7JVIQ94w"], ["Qt QScrollArea - Part 2 | www.minhinc.com", "o_W1XMcwUnc"], ["Qt QScrollArea - Part 1 | www.minhinc.com", "YGRYnCG-F7M"], ["Qt QScrollArea | www.minhinc.com", "aF1SszSlq9E"], ["Qt Resources - Part 2 RCC Staticlib | Jan 06 2020", "RM94MIBC3Jc"], ["Qt Resources - Part 1 qresource qrc | www.minhinc.com | Jan 05 2020", "8Yv81yIFpbI"], ["Qt Library - Part 3 QLibrary Late Binding | www.minhinc.com | Jan 03 2020", "Pguk9gwiGqs"], ["Qt Library - Part 2 Dynamic | www.minhinc.com | Jan 02 2020", "9plgeE9gCWo"], ["Qt Library - Part 1 Static | www.minhinc.com | Jan 01 2020", "yCaFuT_JIyc"], ["Qt QPainter Analog Clock | www.minhinc.com | Dec 31 2019", "W8Q39V3RBhw"], ["Qt Plugin - Part 1 Creation | www.minhinc.com | Dec 22 2019", "wOMcuH0kQqY"], ["Qt Plugin - Part 2 Load | www.minhinc.com | Dec 23 2019", "cNLofeat7Ec"], ["Qt Custom Widget - Part 2 Containment | www.minhinc.com | Dec 14 2019", "lIQSvW_aD2g"], ["Qt Custom Widget - Part 1 Inheritance | www.minhinc.com | Dec 13 2019", "-HaMWJVYAzE"], ["Qt Coordinate System - Part 2, Solar System | www.minhinc.com | Dec 10 2019", "QcvBbsjSLZA"], ["Qt Coordinate System - Part 1 | www.minhinc.com | Dec 09 2019", "hNYWlT9rADg"], ["Qt QWidget | www.minhinc.com | Dec 08 2019", "FaOlt-M1UL0"], ["Qt QObject - Part 2 | www.minhinc.com | Dec 06 2019", "KD7Ggq1iP1M"], ["Qt QObject - Part 1 | www.minhinc.com | Dec 05 2019", "IPUifRmWGrw"], ["Qt Custom Events | www.minhinc.com | Dec 04 2019", "GVKHXRWX4Lk"], ["Qt Event Filtering | www.minhinc.com | Dec 03 2019", "uAaxbROmymI"], ["Qt Install on Linux in 2 ways. Ubuntu 18.04 | www.minhinc.com | Nov 30 2019", "2lKB7vEBHBo"], ["Qt Meta Object - Part 2 | www.minhinc.com | Nov 26 2019", "glNYRahiTrE"], ["Qt Meta Object - Part 1 | www.minhinc.com | Nov 25 2019", "FivBdWjy-vw"]],\n"2":"<!--Online C++ Training-->\\\n<table width=625 align=\\"center\\">\\\n<col style=\\"width:33%\\"/>\\\n<col style=\\"width:33%\\"/>\\\n<col style=\\"width:33%\\"/>\\\n<tr><td colspan=\\"3\\" align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io/\\" style=\\"font-size:11pt;color:#444;text-decoration:none\\">Online Training</a> | <a href=\\"http://minhinc.42web.io/training/cpp\\" style=\\"font-size:11pt;color:#444;text-decoration:none\\">Online Course Material</a> | <a href=\\"http://minhinc.42web.io/about/online\\" style=\\"font-size:11pt;color:#444;text-decoration:none\\">Lesser Rates</a>\\\n</td></tr>\\\n<tr style=\\"margin-top:100px;border:1px solid red\\"><td colspan=\\"3\\" align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io\\"><img src=\\"http://minhinc.42web.io/image/topconLogo.png\\"/></a>\\\n</td></tr>\\\n\\\n<tr height=300px><td colspan=\\"1\\">\\\n<img src=\\"http://minhinc.42web.io/image/file_cpp1_s.gif\\" style=\\"max-height:200px\\"/>\\\n</td>\\\n<td colspan=\\"2\\" align=\\"right\\">\\\n<pre style=\\"color:#f26522;font-size:16pt;font-family:Arial;font-weight:bold;text-align:left\\">Get Online Training On C++</pre>\\\n<pre style=\\"width:80%;text-align:left;font-size:12pt;font-family:georgia,\'times new roman\';color:#444;white-space:pre-wrap\\">We provide world class online training on C++ with 6 weeks of training spanning over one and half months. 5-6 hrs every week.</pre>\\\n<a href=\\"http://minhinc.42web.io\\" style=\\"text-decoration:none;display:block;color:#fff;font-size:16px;text-align:center;width:160px;line-height:50px;margin:30px auto;border-radius:2px;background-color:#53616e;font-family:arial, helvetica, sans;\\">...Read More</a>\\\n</td></tr>\\\n \\\n<tr height=300px><td colspan=\\"2\\" align=\\"left\\">\\\n<pre style=\\"color:#f26522;font-size:16pt;font-family:Arial;font-weight:bold;text-align:right;\\">Online Training Content</pre>\\\n<pre style=\\"width:80%;text-align:left;font-size:12pt;font-family:georgia,\'times new roman\';color:#444;white-space:pre-wrap\\">Course content for C++ are made online. Course contents are available in Pdf downloadable format also. Participants can practice before coming to the training.</pre>\\\n<a href=\\"http://minhinc.42web.io/training/cpp\\" style=\\"text-decoration:none;display:block;color:#fff;font-size:16px;text-align:center;width:160px;line-height:50px;margin:30px auto;border-radius:2px;background-color:#53616e;font-family:arial, helvetica, sans;\\">...Read More</a>\\\n</td>\\\n<td colspan=\\"1\\">\\\n<img src=\\"http://minhinc.42web.io/image/file_cpp2_s.gif\\" align=\\"right\\" style=\\"max-height:200px\\"/>\\\n</td></tr>\\\n \\\n<tr height=300px><td colspan=\\"1\\">\\\n<img src=\\"http://minhinc.42web.io/image/file3_s.gif\\" style=\\"max-height:200px\\"/>\\\n</td>\\\n<td colspan=\\"2\\" align=\\"right\\">\\\n<pre style=\\"color:#f26522;font-size:16pt;font-family:Arial;font-weight:bold;text-align:left\\">Fee Structure and Next Training ...</pre>\\\n<pre style=\\"width:80%;text-align:left;font-size:12pt;font-family:georgia,\'times new roman\';color:#444;white-space:pre-wrap\\">We have 6 disclosures in C++. Fee structure is made affordable at <b>$400 or 19500/-</b> for each participants. Next training is scheduled for C++ in MMYY</pre>\\\n<a href=\\"http://minhinc.42web.io/about/online\\" style=\\"text-decoration:none;display:block;color:#fff;font-size:16px;text-align:center;width:160px;line-height:50px;margin:30px auto;border-radius:2px;background-color:#53616e;font-family:arial, helvetica, sans;\\">...Read More</a>\\\n</td></tr>\\\n \\\n<tr style=\\"margin-top:100px\\"><td colspan=\\"3\\" align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io\\"><img src=\\"http://minhinc.42web.io/image/topconLogo.png\\"/></a>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:20px\\">Sent To : XXX</pre>\\\n <pre style=\\"text-align:center;margin-top:5px\\"><a href=\\"http://minhinc.42web.io/about/unsubscribe_wn.php?email=XXX\\" target=\\"_blank\\" style=\\"color:#0000ff;font-weight:bold;font-family:arial,helvetica,sans-serif;font-size:9pt;\\">Unsubscribe</a></pre>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:-10px\\"><br><br>#85,P&T,Bangalore-94,India, +91 9483160610 <img src=\\"http://minhinc.42web.io/image/whatsapp_s.png\\"/><br><a href=\\"mailto\\">sales@minhinc.com</a><br><a href=\\"http://minhinc.42web.io\\">http://minhinc.42web.io</a></pre>\\\n</td></tr>\\\n</table>"\n}'
'4!ABS SBA!qt!ABS SBA!{\n"1":"<!--Learn Qt/QML Through YouTube!!-->\\\n<table width=\\"100%\\" align=\\"center\\" cellpadding=\\"0\\" cellspacing=\\"0\\" style=\\"max-width:youtubeimagewidth;\\">\\\n<tr><td height=\\"50\\"></td></tr>\\\n<tr>\\\n <td align=\\"left\\"><a href=\\"https://www.youtube.com/c/minhinc\\" style=\\"text-decoration:none;font-size:18px;font-weight:bold;color:#000\\">Qt/Qml : youtubetitle</a></td>\\\n</tr>\\\n<tr><td height=\\"10\\"></td></tr>\\\n<tr>\\\n <td align=\\"center\\"><pre style=\\"font-size:24px;color:#666\\">YouTube Channel <a href=\\"https://www.youtube.com/c/minhinc\\" style=\\"text-decoration:none;font-size:24px;background-color:#a3b1be;color:#004000;font-family:arial, helvetica, sans;font-weight:bold\\">Minh Inc</a></pre></td>\\\n</tr>\\\n<tr><td height=\\"10\\"></td></tr>\\\n<tr>\\\n <td align=\\"right\\"><a href=\\"https://www.youtube.com/c/minhinc/?sub_confirmation=1\\" style=\\"text-decoration:none;display:block;color:#ffffff;font-size:14px;text-align:center;width:80px;line-height:30px;border-radius:2px;background-color:#cc0000;font-family:arial, helvetica, sans;\\">Subscribe</a></td>\\\n</tr>\\\n<tr>\\\n <td align=\\"center\\"><a href=\\"https://www.youtube.com/watch?v=youtubeid\\"><img src=\\"http://minhinc.42web.io/image/youtubeid.jpg\\" width=\\"100%\\"/></a></td>\\\n</tr>\\\n<tr>\\\n <td align=\\"left\\"><a href=\\"https://www.youtube.com/c/minhinc\\" style=\\"text-decoration:none;font-size:14px;font-weight:bold;color:#000\\">youtubetitle</a></td>\\\n</tr>\\\n<tr><td height=\\"50\\"></td></tr>\\\n<tr style=\\"margin-top:100px\\"><td  align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io\\"><img src=\\"http://minhinc.42web.io/image/topconLogo.png\\"/></a>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:20px\\">Sent To : XXX</pre>\\\n <pre style=\\"text-align:center;margin-top:5px\\"><a href=\\"http://minhinc.42web.io/about/unsubscribe_wn.php?email=XXX\\" target=\\"_blank\\" style=\\"color:#0000ff;font-weight:bold;font-family:arial,helvetica,sans-serif;font-size:9pt;\\">Unsubscribe</a></pre>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:-10px\\"><br><br>#85,P&T,Bangalore-94,India, +91 9483160610 <img src=\\"http://minhinc.42web.io/image/whatsapp_s.png\\"/><br><a href=\\"mailto\\">sales@minhinc.com</a><br><a href=\\"http://minhinc.42web.io\\">http://minhinc.42web.io</a></pre>\\\n</td></tr>\\\n</table>",\n"youtube":[["Install Qt PySide6 and Uml through pyreverse | Reverse Engineering | May 2021","kTxAwQeAvtk"],["Qt QScrollArea - Part 3 | www.minhinc.com", "JzN7JVIQ94w"],["Qt QScrollArea - Part 2 | www.minhinc.com", "o_W1XMcwUnc"], ["Qt QScrollArea - Part 1 | www.minhinc.com", "YGRYnCG-F7M"], ["Qt QScrollArea | www.minhinc.com", "aF1SszSlq9E"], ["Qml Custom Slider Part 2 60fps | www.minhinc.com | Jan 08 2020", "qyWunbEO88w"], ["Qml Custom Slider Part 1 | www.minhinc.com | Jan 07 2020", "Rkg6CD05Urk"], ["Qt Resources - Part 2 RCC Staticlib | Jan 06 2020", "RM94MIBC3Jc"], ["Qt Resources - Part 1 qresource qrc | www.minhinc.com | Jan 05 2020", "8Yv81yIFpbI"], ["Qml Transition | www.minhinc.com | Jan 04 2020", "jUqPG62NrRo"], ["Qt Library - Part 3 QLibrary Late Binding | www.minhinc.com | Jan 03 2020", "Pguk9gwiGqs"], ["Qt Library - Part 2 Dynamic | www.minhinc.com | Jan 02 2020", "9plgeE9gCWo"], ["Qt Library - Part 1 Static | www.minhinc.com | Jan 01 2020", "yCaFuT_JIyc"], ["Qt QPainter Analog Clock | www.minhinc.com | Dec 31 2019", "W8Q39V3RBhw"], ["Qml Transformation - Part 2 Translate Scale l www.minhinc.com | Dec 30 2019", "Q9j-fRWGed8"], ["Qml Controls | www.minhinc.com | Dec 29 2019", "5dYr8qpqDXg"], ["Qml States - Part 2 | www.minhinc.com | Dec 27 2019", "cDf9OiVsCeU"], ["Qml Transformation - Part 1 | www.minhinc.com | Dec 28 2019", "frC9nZGrLAM"], ["Qml States - Part 1 | www.minhinc.com | Dec 26 2019", "Y1tAvBliWa4"], ["Qml Alias. Public Private Property | www.minhinc.com | Dec 25 2019", "CJSdQBs9AxM"], ["Qml Repeater | www.minhinc.com | Dec 24 2019", "wnkKBWD95u0"], ["Qt Plugin - Part 1 Creation | www.minhinc.com | Dec 22 2019", "wOMcuH0kQqY"], ["Qt Plugin - Part 2 Load | www.minhinc.com | Dec 23 2019", "cNLofeat7Ec"], ["Qml QtObject Singleton - Part 2 | www.minhinc.com | Dec 21 2019", "OJBDk4VUzKk"], ["Qml QtObject Singleton - Part 1| www.minhinc.com | Dec 20 2019", "uzL9BV_VWYc"], ["Qml Plugin and qmldir | www.minhinc.com | Dec 19 2019", "19ibdDN0ZPo"], ["Qml Plugin Library | www.minhinc.com | Dec 18 2019", "UxnOiAejgtQ"], ["Qml Dynamic Item Creation Part - 2 Qt.createComponent | www.minhinc.com | Dec 17 2019", "ZVvGC9jegA8"], ["Qml Dynamic Item Creation Part-1 Loader | www.minhinc.com | Dec 16 2019", "uYfiKCyaps8"], ["Qml Property Binding | www.minhinc.com | Dec 15 2019", "nXfqFRJnk0s"], ["Qt Custom Widget - Part 2 Containment | www.minhinc.com | Dec 14 2019", "lIQSvW_aD2g"], ["Qt Custom Widget - Part 1 Inheritance | www.minhinc.com | Dec 13 2019", "-HaMWJVYAzE"], ["Qml Custom Painted Item QQuickPaintedItem | www.minhinc.com | Dec 12 2019", "E7LfWTJr_is"], ["Qml FocusScope | www.minhinc.com | Dec 11 2019", "lIAway_X3E8"], ["Qt Coordinate System - Part 2, Solar System | www.minhinc.com | Dec 10 2019", "QcvBbsjSLZA"], ["Qt Coordinate System - Part 1 | www.minhinc.com | Dec 09 2019", "hNYWlT9rADg"], ["Qt QWidget | www.minhinc.com | Dec 08 2019", "FaOlt-M1UL0"], ["Qt QObject - Part 2 | www.minhinc.com | Dec 06 2019", "KD7Ggq1iP1M"], ["Qt QObject - Part 1 | www.minhinc.com | Dec 05 2019", "IPUifRmWGrw"], ["Qt Custom Events | www.minhinc.com | Dec 04 2019", "GVKHXRWX4Lk"], ["Qt Event Filtering | www.minhinc.com | Dec 03 2019", "uAaxbROmymI"], ["Qml Inheritance | www.minhinc.com | Dec 02 2019", "g5LsBYS_t8U"], ["QML Component Overview | www.minhinc.com | Dec 01 2019", "bq9GD0c0hYQ"], ["Qt Install on Linux in 2 ways. Ubuntu 18.04 | www.minhinc.com | Nov 30 2019", "2lKB7vEBHBo"], ["Qml Export Qt C++ class and Object to Qml | www.minhinc.com | Nov 29 2019", "8MKAd5zzClQ"], ["Qt Meta Object - Part 2 | www.minhinc.com | Nov 26 2019", "glNYRahiTrE"], ["Qt Meta Object - Part 1 | www.minhinc.com | Nov 25 2019", "FivBdWjy-vw"]],\n"2":"<!--Online Qt/QML Training-->\\\n<table width=625 align=\\"center\\">\\\n<col style=\\"width:33%\\"/>\\\n<col style=\\"width:33%\\"/>\\\n<col style=\\"width:33%\\"/>\\\n<tr><td colspan=\\"3\\" align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io/\\" style=\\"font-size:11pt;color:#444;text-decoration:none\\">Online Training</a> | <a href=\\"http://minhinc.42web.io/training/qt\\" style=\\"font-size:11pt;color:#444;text-decoration:none\\">Online Course Material</a> | <a href=\\"http://minhinc.42web.io/about/online\\" style=\\"font-size:11pt;color:#444;text-decoration:none\\">Lesser Rates</a>\\\n</td></tr>\\\n<tr style=\\"margin-top:100px;border:1px solid red\\"><td colspan=\\"3\\" align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io\\"><img src=\\"http://minhinc.42web.io/image/topconLogo.png\\"/></a>\\\n</td></tr>\\\n\\\n<tr height=300px><td colspan=\\"1\\">\\\n<img src=\\"http://minhinc.42web.io/image/file1_s.gif\\" style=\\"max-height:200px\\"/>\\\n</td>\\\n<td colspan=\\"2\\" align=\\"right\\">\\\n<pre style=\\"color:#f26522;font-size:16pt;font-family:Arial;font-weight:bold;text-align:left\\">Get Online Training On Qt/Qml</pre>\\\n<pre style=\\"width:80%;text-align:left;font-size:12pt;font-family:georgia,\'times new roman\';color:#444;white-space:pre-wrap\\">We provide online training on Qt/QML with 6 weeks of training spanning over one and half months. 5-6 hrs every week.</pre>\\\n<a href=\\"http://minhinc.42web.io\\" style=\\"text-decoration:none;display:block;color:#fff;font-size:16px;text-align:center;width:160px;line-height:50px;margin:30px auto;border-radius:2px;background-color:#53616e;font-family:arial, helvetica, sans;\\">...Read More</a>\\\n</td></tr>\\\n \\\n<tr height=300px><td colspan=\\"2\\" align=\\"left\\">\\\n<pre style=\\"color:#f26522;font-size:16pt;font-family:Arial;font-weight:bold;text-align:right;\\">Online Training Content</pre>\\\n<pre style=\\"width:80%;text-align:left;font-size:12pt;font-family:georgia,\'times new roman\';color:#444;white-space:pre-wrap\\">Course content for Qt/Qml are made online. Course contents are available in Pdf downloadable format also. Participants can practice before coming to the training.</pre>\\\n<a href=\\"http://minhinc.42web.io/training/qt\\" style=\\"text-decoration:none;display:block;color:#fff;font-size:16px;text-align:center;width:160px;line-height:50px;margin:30px auto;border-radius:2px;background-color:#53616e;font-family:arial, helvetica, sans;\\">...Read More</a>\\\n</td>\\\n<td colspan=\\"1\\">\\\n<img src=\\"http://minhinc.42web.io/image/file2_s.gif\\" align=\\"right\\" style=\\"max-height:200px\\"/>\\\n</td></tr>\\\n \\\n<tr height=300px><td colspan=\\"1\\">\\\n<img src=\\"http://minhinc.42web.io/image/file3_s.gif\\" style=\\"max-height:200px\\"/>\\\n</td>\\\n<td colspan=\\"2\\" align=\\"right\\">\\\n<pre style=\\"color:#f26522;font-size:16pt;font-family:Arial;font-weight:bold;text-align:left\\">Fee Structure and Next Training ...</pre>\\\n<pre style=\\"width:80%;text-align:left;font-size:12pt;font-family:georgia,\'times new roman\';color:#444;white-space:pre-wrap\\">We have 5 disclosures in Qt. Fee structure is made affordable at <b>$400 or 19500/-</b> for each participants. Next training is scheduled for advance qml in MMYY</pre>\\\n<a href=\\"http://minhinc.42web.io/about/online\\" style=\\"text-decoration:none;display:block;color:#fff;font-size:16px;text-align:center;width:160px;line-height:50px;margin:30px auto;border-radius:2px;background-color:#53616e;font-family:arial, helvetica, sans;\\">...Read More</a>\\\n</td></tr>\\\n \\\n<tr style=\\"margin-top:100px\\"><td colspan=\\"3\\" align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io\\"><img src=\\"http://minhinc.42web.io/image/topconLogo.png\\"/></a>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:20px\\">Sent To : XXX</pre>\\\n <pre style=\\"text-align:center;margin-top:5px\\"><a href=\\"http://minhinc.42web.io/about/unsubscribe_wn.php?email=XXX\\" target=\\"_blank\\" style=\\"color:#0000ff;font-weight:bold;font-family:arial,helvetica,sans-serif;font-size:9pt;\\">Unsubscribe</a></pre>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:-10px\\"><br><br>#85,P&T,Bangalore-94,India, +91 9483160610 <img src=\\"http://minhinc.42web.io/image/whatsapp_s.png\\"/><br><a href=\\"mailto\\">sales@minhinc.com</a><br><a href=\\"http://minhinc.42web.io\\">http://minhinc.42web.io</a></pre>\\\n</td></tr>\\\n</table>"\n}'
'5!ABS SBA!li!ABS SBA!None'
'6!ABS SBA!ldd!ABS SBA!None'
'7!ABS SBA!gl!ABS SBA!None'
'8!ABS SBA!qml!ABS SBA!{\n"1":"<!--Learn Qt/QML Through YouTube!!-->\\\n<table width=youtubeimagewidth align=\\"center\\" cellpadding=\\"0\\" cellspacing=\\"0\\">\\\n<tr><td height=\\"50\\"></td></tr>\\\n<tr>\\\n <td width=\\"youtubeimagewidth\\" align=\\"left\\"><a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ\\" style=\\"text-decoration:none;font-size:18px;font-weight:bold;color:#000\\">Qt/Qml : youtubetitle</a></td>\\\n</tr>\\\n<tr><td height=\\"10\\"></td></tr>\\\n<tr>\\\n <td align=\\"center\\"><pre style=\\"font-size:24px;color:#666\\">YouTube Channel <a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ\\" style=\\"text-decoration:none;font-size:24px;background-color:#a3b1be;color:#004000;font-family:arial, helvetica, sans;font-weight:bold\\">Minh Inc</a></pre></td>\\\n</tr>\\\n<tr><td height=\\"10\\"></td></tr>\\\n<tr>\\\n <td align=\\"right\\"><a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ/?sub_confirmation=1\\" style=\\"text-decoration:none;display:block;color:#ffffff;font-size:14px;text-align:center;width:80px;line-height:30px;border-radius:2px;background-color:#cc0000;font-family:arial, helvetica, sans;\\">Subscribe</a></td>\\\n</tr>\\\n<tr>\\\n <td align=\\"center\\"><a href=\\"https://www.youtube.com/watch?v=youtubeid\\"><img src=\\"http://minhinc.42web.io/image/youtubeid.jpg\\" style=\\"max-width:youtubeimagewidth\\"/></a></td>\\\n</tr>\\\n<tr>\\\n <td align=\\"left\\"><a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ\\" style=\\"text-decoration:none;font-size:14px;font-weight:bold;color:#000\\">youtubetitle</a></td>\\\n</tr>\\\n<tr><td height=\\"50\\"></td></tr>\\\n<tr style=\\"margin-top:100px\\"><td  align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io\\"><img src=\\"http://minhinc.42web.io/image/topconLogo.png\\"/></a>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:20px\\">Sent To : XXX</pre>\\\n <pre style=\\"text-align:center;margin-top:5px\\"><a href=\\"http://minhinc.42web.io/about/unsubscribe_wn.php?email=XXX\\" target=\\"_blank\\" style=\\"color:#0000ff;font-weight:bold;font-family:arial,helvetica,sans-serif;font-size:9pt;\\">Unsubscribe</a></pre>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:-10px\\"><br><br>#85,P&T,Bangalore-94,India, +91 9483160610 <img src=\\"http://minhinc.42web.io/image/whatsapp_s.png\\"/><br><a href=\\"mailto\\">sales@minhinc.com</a><br><a href=\\"http://minhinc.42web.io\\">http://minhinc.42web.io</a></pre>\\\n</td></tr>\\\n</table>",\n"youtube":[["Qml Custom Slider Part 2 60fps | www.minhinc.com | Jan 08 2020", "qyWunbEO88w"], ["Qml Custom Slider Part 1 | www.minhinc.com | Jan 07 2020", "Rkg6CD05Urk"], ["Qml Transition | www.minhinc.com | Jan 04 2020", "jUqPG62NrRo"], ["Qml Transformation - Part 2 Translate Scale l www.minhinc.com | Dec 30 2019", "Q9j-fRWGed8"], ["Qml Controls | www.minhinc.com | Dec 29 2019", "5dYr8qpqDXg"], ["Qml States - Part 2 | www.minhinc.com | Dec 27 2019", "cDf9OiVsCeU"], ["Qml Transformation - Part 1 | www.minhinc.com | Dec 28 2019", "frC9nZGrLAM"], ["Qml States - Part 1 | www.minhinc.com | Dec 26 2019", "Y1tAvBliWa4"], ["Qml Alias. Public Private Property | www.minhinc.com | Dec 25 2019", "CJSdQBs9AxM"], ["Qml Repeater | www.minhinc.com | Dec 24 2019", "wnkKBWD95u0"], ["Qml QtObject Singleton - Part 2 | www.minhinc.com | Dec 21 2019", "OJBDk4VUzKk"], ["Qml QtObject Singleton - Part 1| www.minhinc.com | Dec 20 2019", "uzL9BV_VWYc"], ["Qml Plugin and qmldir | www.minhinc.com | Dec 19 2019", "19ibdDN0ZPo"], ["Qml Plugin Library | www.minhinc.com | Dec 18 2019", "UxnOiAejgtQ"], ["Qml Dynamic Item Creation Part - 2 Qt.createComponent | www.minhinc.com | Dec 17 2019", "ZVvGC9jegA8"], ["Qml Dynamic Item Creation Part-1 Loader | www.minhinc.com | Dec 16 2019", "uYfiKCyaps8"], ["Qml Property Binding | www.minhinc.com | Dec 15 2019", "nXfqFRJnk0s"], ["Qml Custom Painted Item QQuickPaintedItem | www.minhinc.com | Dec 12 2019", "E7LfWTJr_is"], ["Qml FocusScope | www.minhinc.com | Dec 11 2019", "lIAway_X3E8"], ["Qml Inheritance | www.minhinc.com | Dec 02 2019", "g5LsBYS_t8U"], ["QML Component Overview | www.minhinc.com | Dec 01 2019", "bq9GD0c0hYQ"], ["Qml Export Qt C++ class and Object to Qml | www.minhinc.com | Nov 29 2019", "8MKAd5zzClQ"]]\n}'
'9!ABS SBA!dp!ABS SBA!{\n"1":"<!--Learn Design Patterns through YouTube Video!!-->\\\n<table width=youtubeimagewidth align=\\"center\\" cellpadding=\\"0\\" cellspacing=\\"0\\">\\\n<tr><td height=\\"50\\"></td></tr>\\\n<tr>\\\n <td width=\\"youtubeimagewidth\\" align=\\"left\\"><a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ\\" style=\\"text-decoration:none;font-size:18px;font-weight:bold;color:#000\\">Qt/Qml : youtubetitle</a></td>\\\n</tr>\\\n<tr><td height=\\"10\\"></td></tr>\\\n<tr>\\\n <td align=\\"center\\"><pre style=\\"font-size:24px;color:#666\\">YouTube Channel <a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ\\" style=\\"text-decoration:none;font-size:24px;background-color:#a3b1be;color:#004000;font-family:arial, helvetica, sans;font-weight:bold\\">Minh Inc</a></pre></td>\\\n</tr>\\\n<tr><td height=\\"10\\"></td></tr>\\\n<tr>\\\n <td align=\\"right\\"><a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ/?sub_confirmation=1\\" style=\\"text-decoration:none;display:block;color:#ffffff;font-size:14px;text-align:center;width:80px;line-height:30px;border-radius:2px;background-color:#cc0000;font-family:arial, helvetica, sans;\\">Subscribe</a></td>\\\n</tr>\\\n<tr>\\\n <td align=\\"center\\"><a href=\\"https://www.youtube.com/watch?v=youtubeid\\"><img src=\\"http://minhinc.42web.io/image/youtubeid.jpg\\" style=\\"max-width:youtubeimagewidth\\"/></a></td>\\\n</tr>\\\n<tr>\\\n <td align=\\"left\\"><a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ\\" style=\\"text-decoration:none;font-size:14px;font-weight:bold;color:#000\\">youtubetitle</a></td>\\\n</tr>\\\n<tr><td height=\\"50\\"></td></tr>\\\n<tr style=\\"margin-top:100px\\"><td  align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io\\"><img src=\\"http://minhinc.42web.io/image/topconLogo.png\\"/></a>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:20px\\">Sent To : XXX</pre>\\\n <pre style=\\"text-align:center;margin-top:5px\\"><a href=\\"http://minhinc.42web.io/about/unsubscribe_wn.php?email=XXX\\" target=\\"_blank\\" style=\\"color:#0000ff;font-weight:bold;font-family:arial,helvetica,sans-serif;font-size:9pt;\\">Unsubscribe</a></pre>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:-10px\\"><br><br>#85,P&T,Bangalore-94,India, +91 9483160610 <img src=\\"http://minhinc.42web.io/image/whatsapp_s.png\\"/><br><a href=\\"mailto\\">sales@minhinc.com</a><br><a href=\\"http://minhinc.42web.io\\">http://minhinc.42web.io</a></pre>\\\n</td></tr>\\\n</table>",\n"old_1":"<!--Learn Design Patterns through YouTube Video!!-->\\\n<table width=625 align=\\"center\\" cellpadding=\\"0\\" cellspacing=\\"0\\">\\\n<tr><td colspan=\\"3\\" height=\\"50\\"></td></tr>\\\n<tr>\\\n <td width=\\"youtubewidth\\"</td><td width=\\"youtubeimagewidth\\" align=\\"left\\"><a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ\\" style=\\"text-decoration:none;font-size:18px;font-weight:bold;color:#000\\">Design Patterns : youtubetitle</a></td><td width=\\"youtubewidth\\"></td>\\\n</tr>\\\n<tr><td colspan=\\"3\\" height=\\"10\\"></td></tr>\\\n<tr>\\\n <td colspan=\\"3\\" align=\\"center\\"><pre style=\\"font-size:24px;color:#666\\">YouTube Channel <a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ\\" style=\\"text-decoration:none;font-size:24px;background-color:#a3b1be;color:#004000;font-family:arial, helvetica, sans;font-weight:bold\\">Minh Inc</a></pre></td>\\\n</tr>\\\n<tr><td colspan=\\"3\\" height=\\"10\\"></td></tr>\\\n<tr>\\\n<td></td><td align=\\"right\\"><a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ/?sub_confirmation=1\\" style=\\"text-decoration:none;display:block;color:#ffffff;font-size:14px;text-align:center;width:80px;line-height:30px;border-radius:2px;background-color:#cc0000;font-family:arial, helvetica, sans;\\">Subscribe</a></td>\\\n</tr>\\\n<tr>\\\n <td colspan=\\"3\\" align=\\"center\\"><a href=\\"https://www.youtube.com/watch?v=youtubeid\\"><img src=\\"http://minhinc.42web.io/image/youtubeid.jpg\\" style=\\"max-width:youtubeimagewidthpx\\"/></a></td>\\\n</tr>\\\n<tr>\\\n <td></td><td align=\\"left\\"><a href=\\"https://www.youtube.com/channel/UChmiKM2jr7e9iUOrVPKRTXQ\\" style=\\"text-decoration:none;font-size:14px;font-weight:bold;color:#000\\">youtubetitle</a></td><td></td>\\\n</tr>\\\n<tr><td colspan=\\"3\\" height=\\"50\\"></td></tr>\\\n<tr style=\\"margin-top:100px\\"><td colspan=\\"3\\" align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io\\"><img src=\\"http://minhinc.42web.io/image/topconLogo.png\\"/></a>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:20px\\">Sent To : XXX</pre>\\\n <pre style=\\"text-align:center;margin-top:5px\\"><a href=\\"http://minhinc.42web.io/about/unsubscribe_wn.php?email=XXX\\" target=\\"_blank\\" style=\\"color:#0000ff;font-weight:bold;font-family:arial,helvetica,sans-serif;font-size:9pt;\\">Unsubscribe</a></pre>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:-10px\\"><br><br>#85,P&T,Bangalore-94,India, +91 9483160610 <img src=\\"http://minhinc.42web.io/image/whatsapp_s.png\\"/><br><a href=\\"mailto\\">sales@minhinc.com</a><br><a href=\\"http://minhinc.42web.io\\">http://minhinc.42web.io</a></pre>\\\n</td></tr>\\\n</table>",\n"youtube":[["Python Chain Of Responsibility Design Pattern | www.minhinc.com | Dec 07 2019", "gHfl4FUzdpU"]],\n"2":"<!--Online Design Patterns Training-->\\\n<table width=625 align=\\"center\\">\\\n<col style=\\"width:33%\\"/>\\\n<col style=\\"width:33%\\"/>\\\n<col style=\\"width:33%\\"/>\\\n<tr><td colspan=\\"3\\" align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io/\\" style=\\"font-size:11pt;color:#444;text-decoration:none\\">Online Training</a> | <a href=\\"http://minhinc.42web.io/training/dp\\" style=\\"font-size:11pt;color:#444;text-decoration:none\\">Online Course Material</a> | <a href=\\"http://minhinc.42web.io/about/online\\" style=\\"font-size:11pt;color:#444;text-decoration:none\\">Lesser Rates</a>\\\n</td></tr>\\\n<tr style=\\"margin-top:100px;border:1px solid red\\"><td colspan=\\"3\\" align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io\\"><img src=\\"http://minhinc.42web.io/image/topconLogo.png\\"/></a>\\\n</td></tr>\\\n\\\n<tr height=300px><td colspan=\\"1\\">\\\n<img src=\\"http://minhinc.42web.io/image/file_dp1_s.gif\\" style=\\"max-height:200px\\"/>\\\n</td>\\\n<td colspan=\\"2\\" align=\\"right\\">\\\n<pre style=\\"color:#f26522;font-size:16pt;font-family:Arial;font-weight:bold;text-align:left\\">Get Online Training On Design Patterns</pre>\\\n<pre style=\\"width:80%;text-align:left;font-size:12pt;font-family:georgia,\'times new roman\';color:#444;white-space:pre-wrap\\">We provide world class online training on Design Patterns in C++ with 6 weeks of training spanning over one and half months. 5-6 hrs every week.</pre>\\\n<a href=\\"http://minhinc.42web.io\\" style=\\"text-decoration:none;display:block;color:#fff;font-size:16px;text-align:center;width:160px;line-height:50px;margin:30px auto;border-radius:2px;background-color:#53616e;font-family:arial, helvetica, sans;\\">...Read More</a>\\\n</td></tr>\\\n \\\n<tr height=300px><td colspan=\\"2\\" align=\\"left\\">\\\n<pre style=\\"color:#f26522;font-size:16pt;font-family:Arial;font-weight:bold;text-align:right;\\">Online Training Content</pre>\\\n<pre style=\\"width:80%;text-align:left;font-size:12pt;font-family:georgia,\'times new roman\';color:#444;white-space:pre-wrap\\">Course content for Design Patterns are made online. Course contents are available in Pdf downloadable format also. Participants can practice before coming to the training.</pre>\\\n<a href=\\"http://minhinc.42web.io/training/dp\\" style=\\"text-decoration:none;display:block;color:#fff;font-size:16px;text-align:center;width:160px;line-height:50px;margin:30px auto;border-radius:2px;background-color:#53616e;font-family:arial, helvetica, sans;\\">...Read More</a>\\\n</td>\\\n<td colspan=\\"1\\">\\\n<img src=\\"http://minhinc.42web.io/image/file_dp2_s.gif\\" align=\\"right\\" style=\\"max-height:200px\\"/>\\\n</td></tr>\\\n \\\n<tr height=300px><td colspan=\\"1\\">\\\n<img src=\\"http://minhinc.42web.io/image/file3_s.gif\\" style=\\"max-height:200px\\"/>\\\n</td>\\\n<td colspan=\\"2\\" align=\\"right\\">\\\n<pre style=\\"color:#f26522;font-size:16pt;font-family:Arial;font-weight:bold;text-align:left\\">Fee Structure and Next Training ...</pre>\\\n<pre style=\\"width:80%;text-align:left;font-size:12pt;font-family:georgia,\'times new roman\';color:#444;white-space:pre-wrap\\">We have 3 disclosures in Design Patterns. Fee structure is made affordable at <b>$400 or 19500/-</b> for each participants. Next training is scheduled for Design Patterns in MMYY</pre>\\\n<a href=\\"http://minhinc.42web.io/about/online\\" style=\\"text-decoration:none;display:block;color:#fff;font-size:16px;text-align:center;width:160px;line-height:50px;margin:30px auto;border-radius:2px;background-color:#53616e;font-family:arial, helvetica, sans;\\">...Read More</a>\\\n</td></tr>\\\n \\\n<tr style=\\"margin-top:100px\\"><td colspan=\\"3\\" align=\\"center\\">\\\n <a href=\\"http://minhinc.42web.io\\"><img src=\\"http://minhinc.42web.io/image/topconLogo.png\\"/></a>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:20px\\">Sent To : XXX</pre>\\\n <pre style=\\"text-align:center;margin-top:5px\\"><a href=\\"http://minhinc.42web.io/about/unsubscribe_wn.php?email=XXX\\" target=\\"_blank\\" style=\\"color:#0000ff;font-weight:bold;font-family:arial,helvetica,sans-serif;font-size:9pt;\\">Unsubscribe</a></pre>\\\n <pre style=\\"text-align:center;font-size:8pt;font-family:arial,helvetica,sans-serif;color:#000000;margin-top:-10px\\"><br><br>#85,P&T,Bangalore-94,India, +91 9483160610 <img src=\\"http://minhinc.42web.io/image/whatsapp_s.png\\"/><br><a href=\\"mailto\\">sales@minhinc.com</a><br><a href=\\"http://minhinc.42web.io\\">http://minhinc.42web.io</a></pre>\\\n</td></tr>\\\n</table>"\n}'
'10!ABS SBA!all!ABS SBA!{\n"s":"Product Development in Qt",\n"t":"text/plain",\n"2":"Hello,\\\n\\\nI would like to know whether you publish article in technology like design patterns and c++.  I have an article on Design Patterns in C++ with innovative set of examples. Please let me know your terms and conditions with monetary compensation if you publish such article. I shall send the article draft upon your confirmation.\\\nKind regards,\\\n-- \\\nPravin\\\npravin@minhinc.com\\\n#85, 5th Main, P&T Colony, Bangalore-94, India\\\nhttp://minhinc.42web.io",\n"1":"Dear Sir/Madam,\\\n\\\nWe are a small firm providing training and services in developing GUI for Qt (desktop and embedded).\\\n\\\nWe have many disclosures in Qt (desktop and embedded) published acrossed various publishers.\\\n\\\nSince your company develop products in Qt and we provide services in Qt GUI developement we can be a potential partner to get associated with in India.\\\n\\\nPlease let me know if this may be of interest so that we can arrange a conference for further details.\\\n\\\nThank you.\\\n\\\nKind regards,\\\n-- \\\nPravin\\\nMobile/whatsapp: +91 9483160610; Skype: pravin@minhinc.com\\\n#85, 5th Main, P&T Colony, Bangalore-94, India\\\nhttp://minhinc.42web.io",\n"3":"Dear Sir/Madam,\\\n\\\nAs you probably know, our company provides training and services in developing GUI for Qt (desktop and embedded).\\\n\\\nWe have many HMI disclosures in Qt (desktop and embedded) published acrossed various publishers.\\\n\\\nSince your company develop products in HMI and we provide services in Qt GUI developement we can be a potential partner to get associated with in India.\\\n\\\nPlease let me know if this may be of interest and we can arrange a conference for further details.\\\n\\\nThank you.\\\n\\\nKind regards,\\\n-- \\\nPravin\\\nMobile/whatsapp: +91 9483160610; Skype: pravin@minhinc.com\\\n#85, 5th Main, P&T Colony, Bangalore-94, India\\\nhttp://minhinc.42web.io"\n}'
      track      
